---
uid: mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
title: Povolit automatizované testování částí | Microsoft Docs
author: microsoft
description: Krok 12 ukazuje, jak vyvíjet sadu automatizovaných testů jednotek, které ověřují naše funkce NerdDinner a které nám poskytnou jistotu udělat změny...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: a19ff2ce-3f7e-4358-9a51-a1403da9c63e
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
msc.type: authoredcontent
ms.openlocfilehash: 09a7aa186605a6cce48ee94028425ded957c00d3
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/06/2020
ms.locfileid: "78541676"
---
# <a name="enable-automated-unit-testing"></a><span data-ttu-id="0abe9-103">Povolení automatického testování jednotek</span><span class="sxs-lookup"><span data-stu-id="0abe9-103">Enable Automated Unit Testing</span></span>

<span data-ttu-id="0abe9-104">od [Microsoftu](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="0abe9-104">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="0abe9-105">Stáhnout PDF</span><span class="sxs-lookup"><span data-stu-id="0abe9-105">Download PDF</span></span>](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> <span data-ttu-id="0abe9-106">Toto je krok 12 bezplatného [kurzu aplikace "NerdDinner"](introducing-the-nerddinner-tutorial.md) , který vás provede procesem vytvoření malé, ale dokončené webové aplikace pomocí ASP.NET MVC 1.</span><span class="sxs-lookup"><span data-stu-id="0abe9-106">This is step 12 of a free ["NerdDinner" application tutorial](introducing-the-nerddinner-tutorial.md) that walks-through how to build a small, but complete, web application using ASP.NET MVC 1.</span></span>
> 
> <span data-ttu-id="0abe9-107">Krok 12 ukazuje, jak vyvíjet sadu automatizovaných testů jednotek, které ověřují naše funkce NerdDinner a které nám poskytnou jistotu, že v budoucnu bude dělat změny a vylepšení aplikace.</span><span class="sxs-lookup"><span data-stu-id="0abe9-107">Step 12 shows how to develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>
> 
> <span data-ttu-id="0abe9-108">Pokud používáte ASP.NET MVC 3, doporučujeme vám postupovat podle [Začínáme s kurzy pro](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) [hudební úložiště](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) MVC 3 nebo MVC.</span><span class="sxs-lookup"><span data-stu-id="0abe9-108">If you are using ASP.NET MVC 3, we recommend you follow the [Getting Started With MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) or [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) tutorials.</span></span>

## <a name="nerddinner-step-12-unit-testing"></a><span data-ttu-id="0abe9-109">NerdDinner krok 12: testování částí</span><span class="sxs-lookup"><span data-stu-id="0abe9-109">NerdDinner Step 12: Unit Testing</span></span>

<span data-ttu-id="0abe9-110">Pojďme vyvíjet sadu automatizovaných testů jednotek, které ověřují naše funkce NerdDinner a které nám poskytnou jistotu, že v budoucnu bude dělat změny a vylepšení aplikace.</span><span class="sxs-lookup"><span data-stu-id="0abe9-110">Let's develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>

### <a name="why-unit-test"></a><span data-ttu-id="0abe9-111">Proč testování částí?</span><span class="sxs-lookup"><span data-stu-id="0abe9-111">Why Unit Test?</span></span>

<span data-ttu-id="0abe9-112">Na jednotce po jednom ráno máte prudký inspiraciý blesk o aplikaci, na které pracujete.</span><span class="sxs-lookup"><span data-stu-id="0abe9-112">On the drive into work one morning you have a sudden flash of inspiration about an application you are working on.</span></span> <span data-ttu-id="0abe9-113">Zjistíte, že se vám dá udělat změna, kterou můžete implementovat. tím se aplikace výrazně zlepší.</span><span class="sxs-lookup"><span data-stu-id="0abe9-113">You realize there is a change you can implement that will make the application dramatically better.</span></span> <span data-ttu-id="0abe9-114">Může se jednat o refaktoring, který vyčistí kód, přidá novou funkci nebo opraví chybu.</span><span class="sxs-lookup"><span data-stu-id="0abe9-114">It might be a refactoring that cleans up the code, adds a new feature, or fixes a bug.</span></span>

<span data-ttu-id="0abe9-115">Otázka, na kterou vás přijde, když jste dorazíte na váš počítač, je to, jak bezpečné je toto vylepšení?</span><span class="sxs-lookup"><span data-stu-id="0abe9-115">The question that confronts you when you arrive at your computer is – "how safe is it to make this improvement?"</span></span> <span data-ttu-id="0abe9-116">Co dělat v případě, že změna má vedlejší účinky nebo je něco rušena?</span><span class="sxs-lookup"><span data-stu-id="0abe9-116">What if making the change has side effects or breaks something?</span></span> <span data-ttu-id="0abe9-117">Tato změna může být jednoduchá a implementace bude trvat jenom pár minut, ale co když trvá několik hodin k ručnímu otestování všech scénářů aplikací?</span><span class="sxs-lookup"><span data-stu-id="0abe9-117">The change might be simple and only take a few minutes to implement, but what if it takes hours to manually test out all of the application scenarios?</span></span> <span data-ttu-id="0abe9-118">Co když zapomenete pokrýt scénář a převedená aplikace přejde do produkčního prostředí?</span><span class="sxs-lookup"><span data-stu-id="0abe9-118">What if you forget to cover a scenario and a broken application goes into production?</span></span> <span data-ttu-id="0abe9-119">Je díky tomuto vylepšení skutečně všechno úsilí?</span><span class="sxs-lookup"><span data-stu-id="0abe9-119">Is making this improvement really worth all the effort?</span></span>

<span data-ttu-id="0abe9-120">Automatizované testy jednotek můžou poskytovat bezpečnostní síť, která vám umožní průběžně vylepšovat aplikace a vyhnout se nebojte kódu, na kterém pracujete.</span><span class="sxs-lookup"><span data-stu-id="0abe9-120">Automated unit tests can provide a safety net that enables you to continually enhance your applications, and avoid being afraid of the code you are working on.</span></span> <span data-ttu-id="0abe9-121">Díky automatizovaným testům, které rychle ověřují funkčnost, můžete kódovat s jistotou a pomoct vám v tom, abyste mohli dělat vylepšení, která by mohla být neoprávněná.</span><span class="sxs-lookup"><span data-stu-id="0abe9-121">Having automated tests that quickly verify functionality enables you to code with confidence – and empower you to make improvements you might otherwise not have felt comfortable doing.</span></span> <span data-ttu-id="0abe9-122">Také vám pomůžou vytvářet řešení, která jsou udržovatelná a delší životnost – což vede k mnohem vyšší návratnosti investic.</span><span class="sxs-lookup"><span data-stu-id="0abe9-122">They also help create solutions that are more maintainable and have a longer lifetime - which leads to a much higher return on investment.</span></span>

<span data-ttu-id="0abe9-123">Rozhraní ASP.NET MVC umožňuje snadnou a přirozenou funkčnost aplikace testování částí.</span><span class="sxs-lookup"><span data-stu-id="0abe9-123">The ASP.NET MVC Framework makes it easy and natural to unit test application functionality.</span></span> <span data-ttu-id="0abe9-124">Také umožňuje pracovní postup vývoje řízený testováním (TDD), který umožňuje vývoj na základě testů.</span><span class="sxs-lookup"><span data-stu-id="0abe9-124">It also enables a Test Driven Development (TDD) workflow that enables test-first based development.</span></span>

### <a name="nerddinnertests-project"></a><span data-ttu-id="0abe9-125">Projekt NerdDinner. Tests</span><span class="sxs-lookup"><span data-stu-id="0abe9-125">NerdDinner.Tests Project</span></span>

<span data-ttu-id="0abe9-126">Když jsme na začátku tohoto kurzu vytvořili naši aplikaci NerdDinner, zobrazila se vám dialogové okno s dotazem, jestli jsme chtěli vytvořit projekt testování částí, abyste mohli přejít k projektu aplikace:</span><span class="sxs-lookup"><span data-stu-id="0abe9-126">When we created our NerdDinner application at the beginning of this tutorial, we were prompted with a dialog asking whether we wanted to create a unit test project to go along with the application project:</span></span>

![](enable-automated-unit-testing/_static/image1.png)

<span data-ttu-id="0abe9-127">Zavedli jsme vybraný přepínač Ano, vytvořit projekt testování částí – což vedlo k tomu, že se přidávají projekt "NerdDinner. Tests" do našeho řešení:</span><span class="sxs-lookup"><span data-stu-id="0abe9-127">We kept the "Yes, create a unit test project" radio button selected – which resulted in a "NerdDinner.Tests" project being added to our solution:</span></span>

![](enable-automated-unit-testing/_static/image2.png)

<span data-ttu-id="0abe9-128">Projekt NerdDinner. Tests odkazuje na sestavení projektu aplikace NerdDinner a umožňuje nám do něj snadno přidat automatizované testy, které ověřují funkčnost aplikace.</span><span class="sxs-lookup"><span data-stu-id="0abe9-128">The NerdDinner.Tests project references the NerdDinner application project assembly, and enables us to easily add automated tests to it that verify the application functionality.</span></span>

### <a name="creating-unit-tests-for-our-dinner-model-class"></a><span data-ttu-id="0abe9-129">Vytváření testů jednotek pro třídu modelu večeře</span><span class="sxs-lookup"><span data-stu-id="0abe9-129">Creating Unit Tests for our Dinner Model Class</span></span>

<span data-ttu-id="0abe9-130">Pojďme přidat některé testy do našeho projektu NerdDinner. Tests, který ověří třídu večeře, kterou jsme vytvořili při sestavování naší vrstvy modelu.</span><span class="sxs-lookup"><span data-stu-id="0abe9-130">Let's add some tests to our NerdDinner.Tests project that verify the Dinner class we created when we built our model layer.</span></span>

<span data-ttu-id="0abe9-131">Začneme vytvořením nové složky v rámci našeho testovacího projektu s názvem "modely", kde budeme umísťovat naše testy související s modelem.</span><span class="sxs-lookup"><span data-stu-id="0abe9-131">We'll start by creating a new folder within our test project called "Models" where we'll place our model-related tests.</span></span> <span data-ttu-id="0abe9-132">Potom Klikneme pravým tlačítkem na složku a vyberte příkaz **Přidat-&gt;nový test** nabídky.</span><span class="sxs-lookup"><span data-stu-id="0abe9-132">We'll then right-click on the folder and choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="0abe9-133">Tím se zobrazí dialogové okno Přidat nový test.</span><span class="sxs-lookup"><span data-stu-id="0abe9-133">This will bring up the "Add New Test" dialog.</span></span>

<span data-ttu-id="0abe9-134">Zvolíme, že se má vytvořit "test jednotky" a pojmenovat ho "DinnerTest.cs":</span><span class="sxs-lookup"><span data-stu-id="0abe9-134">We'll choose to create a "Unit Test" and name it "DinnerTest.cs":</span></span>

![](enable-automated-unit-testing/_static/image3.png)

<span data-ttu-id="0abe9-135">Když klikneme na tlačítko OK, Visual Studio přidá (a otevře) soubor DinnerTest.cs do projektu:</span><span class="sxs-lookup"><span data-stu-id="0abe9-135">When we click the "ok" button Visual Studio will add (and open) a DinnerTest.cs file to the project:</span></span>

![](enable-automated-unit-testing/_static/image4.png)

<span data-ttu-id="0abe9-136">Výchozí šablona testu jednotek sady Visual Studio má v ní spoustu kódů kotlového kódu, který se nachází v malém případě.</span><span class="sxs-lookup"><span data-stu-id="0abe9-136">The default Visual Studio unit test template has a bunch of boiler-plate code within it that I find a little messy.</span></span> <span data-ttu-id="0abe9-137">Pojďme ho vyčistit pouze v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="0abe9-137">Let's clean it up to just contain the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample1.cs)]

<span data-ttu-id="0abe9-138">Atribut [TestClass] u třídy DinnerTest výše ho identifikuje jako třídu, která bude obsahovat testy, a také volitelnou inicializaci testu a kód rozboru.</span><span class="sxs-lookup"><span data-stu-id="0abe9-138">The [TestClass] attribute on the DinnerTest class above identifies it as a class that will contain tests, as well as optional test initialization and teardown code.</span></span> <span data-ttu-id="0abe9-139">V rámci něj můžeme definovat testy přidáním veřejných metod, které mají pro ně atribut [TestMethod].</span><span class="sxs-lookup"><span data-stu-id="0abe9-139">We can define tests within it by adding public methods that have a [TestMethod] attribute on them.</span></span>

<span data-ttu-id="0abe9-140">Níže jsou uvedené první ze dvou testů, které přidáme do naší třídy večeře.</span><span class="sxs-lookup"><span data-stu-id="0abe9-140">Below are the first of two tests we'll add that exercise our Dinner class.</span></span> <span data-ttu-id="0abe9-141">První test ověří, že je naším večeři neplatný, pokud se vytvoří nová večeři, aniž by byly správně nastavené vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="0abe9-141">The first test verifies that our Dinner is invalid if a new Dinner is created without all properties being set correctly.</span></span> <span data-ttu-id="0abe9-142">Druhý test ověří, že je naše večeře platná, když má večeře nastavené všechny vlastnosti s platnými hodnotami:</span><span class="sxs-lookup"><span data-stu-id="0abe9-142">The second test verifies that our Dinner is valid when a Dinner has all properties set with valid values:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample2.cs)]

<span data-ttu-id="0abe9-143">Všimněte si, že naše názvy testů jsou velmi explicitní (a jsou trochu podrobné).</span><span class="sxs-lookup"><span data-stu-id="0abe9-143">You'll notice above that our test names are very explicit (and somewhat verbose).</span></span> <span data-ttu-id="0abe9-144">Provedeme to proto, že můžeme vytvořit stovky nebo tisíce malých testů a chceme zjednodušit rychlé určení záměru a chování každého z nich (zejména při prohlížení seznamu selhání v nástroji Test Runner).</span><span class="sxs-lookup"><span data-stu-id="0abe9-144">We are doing this because we might end up creating hundreds or thousands of small tests, and we want to make it easy to quickly determine the intent and behavior of each of them (especially when we are looking through a list of failures in a test runner).</span></span> <span data-ttu-id="0abe9-145">Názvy testů by měly být pojmenovány po testovaných funkcích.</span><span class="sxs-lookup"><span data-stu-id="0abe9-145">The test names should be named after the functionality they are testing.</span></span> <span data-ttu-id="0abe9-146">Nad\_by měl\_operace použít "substantivum".</span><span class="sxs-lookup"><span data-stu-id="0abe9-146">Above we are using a "Noun\_Should\_Verb" naming pattern.</span></span>

<span data-ttu-id="0abe9-147">Provádíme strukturování testů pomocí vzor testování "AAA" – který představuje "uspořádat, ACT, Assert":</span><span class="sxs-lookup"><span data-stu-id="0abe9-147">We are structuring the tests using the "AAA" testing pattern – which stands for "Arrange, Act, Assert":</span></span>

- <span data-ttu-id="0abe9-148">Uspořádat: nastavení testované jednotky</span><span class="sxs-lookup"><span data-stu-id="0abe9-148">Arrange: Setup the unit being tested</span></span>
- <span data-ttu-id="0abe9-149">ACT: vykonání jednotky v rámci testu a výsledků zachycení</span><span class="sxs-lookup"><span data-stu-id="0abe9-149">Act: Exercise the unit under test and capture results</span></span>
- <span data-ttu-id="0abe9-150">Assert: Ověřte chování.</span><span class="sxs-lookup"><span data-stu-id="0abe9-150">Assert: Verify the behavior</span></span>

<span data-ttu-id="0abe9-151">Při psaní testů chceme zabránit tomu, aby byly jednotlivé testy příliš velké.</span><span class="sxs-lookup"><span data-stu-id="0abe9-151">When we write tests we want to avoid having the individual tests do too much.</span></span> <span data-ttu-id="0abe9-152">Místo toho by každý test měl ověřit pouze jeden koncept (což bude mnohem snazší určit příčinu selhání).</span><span class="sxs-lookup"><span data-stu-id="0abe9-152">Instead each test should verify only a single concept (which will make it much easier to pinpoint the cause of failures).</span></span> <span data-ttu-id="0abe9-153">Dobrým pokynem je vyzkoušet a mít pouze jeden příkaz kontrolního výrazu pro každý test.</span><span class="sxs-lookup"><span data-stu-id="0abe9-153">A good guideline is to try and only have a single assert statement for each test.</span></span> <span data-ttu-id="0abe9-154">Pokud máte více než jeden příkaz kontrolního výrazu v testovací metodě, ujistěte se, že jsou všechny použity pro otestování stejného konceptu.</span><span class="sxs-lookup"><span data-stu-id="0abe9-154">If you have more than one assert statement in a test method, make sure they are all being used to test the same concept.</span></span> <span data-ttu-id="0abe9-155">V případě pochybností proveďte jiný test.</span><span class="sxs-lookup"><span data-stu-id="0abe9-155">When in doubt, make another test.</span></span>

### <a name="running-tests"></a><span data-ttu-id="0abe9-156">Spouštění testů</span><span class="sxs-lookup"><span data-stu-id="0abe9-156">Running Tests</span></span>

<span data-ttu-id="0abe9-157">Visual Studio 2008 Professional (a novější edice) obsahují vestavěný Test Runner, který lze použít ke spuštění projektů testů jednotek sady Visual Studio v rámci rozhraní IDE.</span><span class="sxs-lookup"><span data-stu-id="0abe9-157">Visual Studio 2008 Professional (and higher editions) includes a built-in test runner that can be used to run Visual Studio Unit Test projects within the IDE.</span></span> <span data-ttu-id="0abe9-158">Můžeme vybrat příkaz **test-&gt;spustit-&gt;všechny testy v nabídce řešení** (nebo zadat Ctrl R, A) a spustit všechny naše testy jednotek.</span><span class="sxs-lookup"><span data-stu-id="0abe9-158">We can select the **Test-&gt;Run-&gt;All Tests in Solution** menu command (or type Ctrl R, A) to run all of our unit tests.</span></span> <span data-ttu-id="0abe9-159">Případně můžete umístit kurzor do konkrétní třídy testu nebo testovací metodu a použít **test-&gt;spustit-&gt;testy v aktuálním příkazu místní** nabídky (nebo zadat Ctrl R, t) a spustit podmnožinu jednotek testů.</span><span class="sxs-lookup"><span data-stu-id="0abe9-159">Or alternatively we can position our cursor within a specific test class or test method and use the **Test-&gt;Run-&gt;Tests in Current Context** menu command (or type Ctrl R, T) to run a subset of the unit tests.</span></span>

<span data-ttu-id="0abe9-160">Pojďme umístit kurzor v rámci třídy DinnerTest a zadat "CTRL R, T" pro spuštění dvou testů, které jsme právě definovali.</span><span class="sxs-lookup"><span data-stu-id="0abe9-160">Let's position our cursor within the DinnerTest class and type "Ctrl R, T" to run the two tests we just defined.</span></span> <span data-ttu-id="0abe9-161">Když to uděláte, zobrazí se v sadě Visual Studio okno "Výsledky testů" a zobrazí se výsledky našich testovacích běhů uvedených v tomto příkladu:</span><span class="sxs-lookup"><span data-stu-id="0abe9-161">When we do this a "Test Results" window will appear within Visual Studio and we'll see the results of our test run listed within it:</span></span>

![](enable-automated-unit-testing/_static/image5.png)

<span data-ttu-id="0abe9-162">*Poznámka: v okně výsledků testů VS se ve výchozím nastavení nezobrazuje sloupec název třídy. To můžete přidat tak, že kliknete pravým tlačítkem myši do okna Výsledky testů a použijete příkaz nabídky Přidat/odebrat sloupce.*</span><span class="sxs-lookup"><span data-stu-id="0abe9-162">*Note: The VS test results window does not show the Class Name column by default. You can add this by right-clicking within the Test Results window and using the Add/Remove Columns menu command.*</span></span>

<span data-ttu-id="0abe9-163">Naše dva testy trvalo pouze zlomek sekundy ke spuštění – a jak vidíte, jak jsou předány.</span><span class="sxs-lookup"><span data-stu-id="0abe9-163">Our two tests took only a fraction of a second to run – and as you can see they both passed.</span></span> <span data-ttu-id="0abe9-164">Nyní můžeme přejít a rozšířit tak, že vytvoříte další testy, které ověřují konkrétní pravidla, a pokryjeme dvě pomocné metody – IsUserHost () a IsUserRegistered () – přidané do třídy večeře.</span><span class="sxs-lookup"><span data-stu-id="0abe9-164">We can now go on and augment them by creating additional tests that verify specific rule validations, as well as cover the two helper methods - IsUserHost() and IsUserRegistered() – that we added to the Dinner class.</span></span> <span data-ttu-id="0abe9-165">Všechny tyto testy, které jsou na místě pro třídu večeře, budou mnohem jednodušší a bezpečnější pro přidání nových obchodních pravidel a jejich platnosti do budoucna.</span><span class="sxs-lookup"><span data-stu-id="0abe9-165">Having all these tests in place for the Dinner class will make it much easier and safer to add new business rules and validations to it in the future.</span></span> <span data-ttu-id="0abe9-166">Naši novou logiku pravidla můžeme přidat na večeři a potom během několika sekund ověřit, že se nepřerušila žádná z našich předchozích funkcí logiky.</span><span class="sxs-lookup"><span data-stu-id="0abe9-166">We can add our new rule logic to Dinner, and then within seconds verify that it hasn't broken any of our previous logic functionality.</span></span>

<span data-ttu-id="0abe9-167">Všimněte si, jak použít popisný název testu usnadňuje rychlé pochopení toho, co každý test ověřuje.</span><span class="sxs-lookup"><span data-stu-id="0abe9-167">Notice how using a descriptive test name makes it easy to quickly understand what each test is verifying.</span></span> <span data-ttu-id="0abe9-168">Doporučuje se použít příkaz nabídky **Možnosti nástrojů-&gt;** , otevřít obrazovku konfigurace testovacích nástrojů –&gt;spuštění testu a zkontrolovat, že dvakrát kliknout na neúspěšný nebo neprůkazný výsledek testu jednotek, zobrazí v políčku test bod selhání.</span><span class="sxs-lookup"><span data-stu-id="0abe9-168">I recommend using the **Tools-&gt;Options** menu command, opening the Test Tools-&gt;Test Execution configuration screen, and checking the "Double-clicking a failed or inconclusive unit test result displays the point of failure in the test" checkbox.</span></span> <span data-ttu-id="0abe9-169">To vám umožní dvakrát kliknout na selhání v okně výsledky testu a okamžitě přejít k chybě kontrolního výrazu.</span><span class="sxs-lookup"><span data-stu-id="0abe9-169">This will allow you to double-click on a failure in the test results window and jump immediately to the assert failure.</span></span>

### <a name="creating-dinnerscontroller-unit-tests"></a><span data-ttu-id="0abe9-170">Vytváření testů jednotek DinnersController</span><span class="sxs-lookup"><span data-stu-id="0abe9-170">Creating DinnersController Unit Tests</span></span>

<span data-ttu-id="0abe9-171">Teď vytvoříme několik testů jednotek, které ověřují naše funkce DinnersController.</span><span class="sxs-lookup"><span data-stu-id="0abe9-171">Let's now create some unit tests that verify our DinnersController functionality.</span></span> <span data-ttu-id="0abe9-172">Začneme tak, že kliknete pravým tlačítkem na složku Controllers v rámci našeho testovacího projektu a pak zvolíte příkaz **přidat&gt;nový test** nabídky.</span><span class="sxs-lookup"><span data-stu-id="0abe9-172">We'll start by right-clicking on the "Controllers" folder within our Test project and then choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="0abe9-173">Vytvoříme "test jednotky" a pojmenujte ho "DinnersControllerTest.cs".</span><span class="sxs-lookup"><span data-stu-id="0abe9-173">We'll create a "Unit Test" and name it "DinnersControllerTest.cs".</span></span>

<span data-ttu-id="0abe9-174">Vytvoříme dvě testovací metody, které ověří metodu akce Details () na DinnersController.</span><span class="sxs-lookup"><span data-stu-id="0abe9-174">We'll create two test methods that verify the Details() action method on the DinnersController.</span></span> <span data-ttu-id="0abe9-175">Nejdřív se ověří, že se vrátí zobrazení, když se požaduje stávající večeře.</span><span class="sxs-lookup"><span data-stu-id="0abe9-175">The first will verify that a View is returned when an existing Dinner is requested.</span></span> <span data-ttu-id="0abe9-176">Druhá se ověří, že se vrátí zobrazení "NotFound", když se požaduje neexistující večeře:</span><span class="sxs-lookup"><span data-stu-id="0abe9-176">The second will verify that a "NotFound" view is returned when a non-existent Dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample3.cs)]

<span data-ttu-id="0abe9-177">Výše uvedený kód se zkompiluje čistě.</span><span class="sxs-lookup"><span data-stu-id="0abe9-177">The above code compiles clean.</span></span> <span data-ttu-id="0abe9-178">Když testy spustíme, dojde k jejich selhání:</span><span class="sxs-lookup"><span data-stu-id="0abe9-178">When we run the tests, though, they both fail:</span></span>

![](enable-automated-unit-testing/_static/image6.png)

<span data-ttu-id="0abe9-179">Pokud se podíváme na chybové zprávy, ukážeme, že důvodem neúspěchu testů bylo, že se naše třída DinnersRepository nemohla připojit k databázi.</span><span class="sxs-lookup"><span data-stu-id="0abe9-179">If we look at the error messages, we'll see that the reason the tests failed was because our DinnersRepository class was unable to connect to a database.</span></span> <span data-ttu-id="0abe9-180">Naše aplikace NerdDinner používá řetězec připojení k místnímu SQL Server Express souboru, který je umístěn v adresáři \app\_datového adresáře projektu aplikace NerdDinner.</span><span class="sxs-lookup"><span data-stu-id="0abe9-180">Our NerdDinner application is using a connection-string to a local SQL Server Express file which lives under the \App\_Data directory of the NerdDinner application project.</span></span> <span data-ttu-id="0abe9-181">Vzhledem k tomu, že náš projekt NerdDinner. Tests kompiluje a běží v jiném adresáři, pak projekt aplikace, umístění relativní cesty našeho řetězce připojení je nesprávné.</span><span class="sxs-lookup"><span data-stu-id="0abe9-181">Because our NerdDinner.Tests project compiles and runs in a different directory then the application project, the relative path location of our connection-string is incorrect.</span></span>

<span data-ttu-id="0abe9-182">To *můžeme vyřešit* zkopírováním souboru databáze SQL Express do našeho testovacího projektu a potom do souboru App. config našeho testovacího projektu přidat příslušný testovací připojovací řetězec.</span><span class="sxs-lookup"><span data-stu-id="0abe9-182">We *could* fix this by copying the SQL Express database file to our test project, and then add an appropriate test connection-string to it in the App.config of our test project.</span></span> <span data-ttu-id="0abe9-183">To by vedlo k tomu, že výše uvedené testy nebudou odblokovány a spuštěny.</span><span class="sxs-lookup"><span data-stu-id="0abe9-183">This would get the above tests unblocked and running.</span></span>

<span data-ttu-id="0abe9-184">Testování částí kódu pomocí reálné databáze sice ale přináší množství výzev.</span><span class="sxs-lookup"><span data-stu-id="0abe9-184">Unit testing code using a real database, though, brings with it a number of challenges.</span></span> <span data-ttu-id="0abe9-185">Konkrétně:</span><span class="sxs-lookup"><span data-stu-id="0abe9-185">Specifically:</span></span>

- <span data-ttu-id="0abe9-186">Významně zpomaluje dobu provádění testů jednotek.</span><span class="sxs-lookup"><span data-stu-id="0abe9-186">It significantly slows down the execution time of unit tests.</span></span> <span data-ttu-id="0abe9-187">Čím déle trvá spuštění testů, tím méně pravděpodobně budete provádět často.</span><span class="sxs-lookup"><span data-stu-id="0abe9-187">The longer it takes to run tests, the less likely you are to execute them frequently.</span></span> <span data-ttu-id="0abe9-188">V ideálním případě budete chtít, aby testy jednotek byly schopny běžet v řádu sekund – a mělo by to být něco, co provedete stejně přirozeně jako při kompilování projektu.</span><span class="sxs-lookup"><span data-stu-id="0abe9-188">Ideally you want your unit tests to be able to be run in seconds – and have it be something you do as naturally as compiling the project.</span></span>
- <span data-ttu-id="0abe9-189">V rámci testů ztěžuje logiku nastavení a vyčištění.</span><span class="sxs-lookup"><span data-stu-id="0abe9-189">It complicates the setup and cleanup logic within tests.</span></span> <span data-ttu-id="0abe9-190">Požadujete, aby byl každý test jednotky izolovaný a nezávisle na ostatních (bez vedlejších účinků nebo závislostí).</span><span class="sxs-lookup"><span data-stu-id="0abe9-190">You want each unit test to be isolated and independent of others (with no side effects or dependencies).</span></span> <span data-ttu-id="0abe9-191">Při práci na reálné databázi je nutné mít na vědomí stav a obnovit je mezi testy.</span><span class="sxs-lookup"><span data-stu-id="0abe9-191">When working against a real database you have to be mindful of state and reset it between tests.</span></span>

<span data-ttu-id="0abe9-192">Pojďme se podívat na vzor návrhu s názvem "vložení závislostí", který nám může přispět k obejít těchto problémů a vyhnout se nutnosti používat skutečnou databázi s našimi testy.</span><span class="sxs-lookup"><span data-stu-id="0abe9-192">Let's look at a design pattern called "dependency injection" that can help us work around these issues and avoid the need to use a real database with our tests.</span></span>

### <a name="dependency-injection"></a><span data-ttu-id="0abe9-193">Injektáž závislostí</span><span class="sxs-lookup"><span data-stu-id="0abe9-193">Dependency Injection</span></span>

<span data-ttu-id="0abe9-194">Teď DinnersController je úzce "spojená" se třídou DinnerRepository.</span><span class="sxs-lookup"><span data-stu-id="0abe9-194">Right now DinnersController is tightly "coupled" to the DinnerRepository class.</span></span> <span data-ttu-id="0abe9-195">"Spoj" odkazuje na situaci, kdy třída explicitně spoléhá na jinou třídu, aby fungovala:</span><span class="sxs-lookup"><span data-stu-id="0abe9-195">"Coupling" refers to a situation where a class explicitly relies on another class in order to work:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample4.cs)]

<span data-ttu-id="0abe9-196">Vzhledem k tomu, že třída DinnerRepository vyžaduje přístup k databázi, tak úzce propojená závislost třídy DinnersController na DinnerRepository končí, aby nám vyžadovala testování metod DinnersController akcí.</span><span class="sxs-lookup"><span data-stu-id="0abe9-196">Because the DinnerRepository class requires access to a database, the tightly coupled dependency the DinnersController class has on the DinnerRepository ends up requiring us to have a database in order for the DinnersController action methods to be tested.</span></span>

<span data-ttu-id="0abe9-197">To můžeme obejít tak, že využijete vzor návrhu s názvem "injektáže závislosti" – což je přístup, ke kterému se již implicitně nevytváří závislosti (jako jsou třídy úložiště, které poskytují přístup k datům) ve třídách, které je používají.</span><span class="sxs-lookup"><span data-stu-id="0abe9-197">We can get around this by employing a design pattern called "dependency injection" – which is an approach where dependencies (like repository classes that provide data access) are no longer implicitly created within classes that use them.</span></span> <span data-ttu-id="0abe9-198">Místo toho je možné závislosti explicitně předat třídě, která je používá pomocí argumentů konstruktoru.</span><span class="sxs-lookup"><span data-stu-id="0abe9-198">Instead, dependencies can be explicitly passed to the class that uses them using constructor arguments.</span></span> <span data-ttu-id="0abe9-199">Pokud jsou závislosti definovány pomocí rozhraní, můžeme mít flexibilitu při implementaci "falešného" implementace závislosti pro scénáře testování částí.</span><span class="sxs-lookup"><span data-stu-id="0abe9-199">If the dependencies are defined using interfaces, we then have the flexibility to pass in "fake" dependency implementations for unit test scenarios.</span></span> <span data-ttu-id="0abe9-200">Díky tomu můžeme vytvořit implementace závislostí specifické pro test, které ve skutečnosti nevyžadují přístup k databázi.</span><span class="sxs-lookup"><span data-stu-id="0abe9-200">This enables us to create test-specific dependency implementations that do not actually require access to a database.</span></span>

<span data-ttu-id="0abe9-201">Pokud se chcete podívat, jak to funguje, můžeme implementovat vkládání závislostí s našimi DinnersController.</span><span class="sxs-lookup"><span data-stu-id="0abe9-201">To see this in action, let's implement dependency injection with our DinnersController.</span></span>

#### <a name="extracting-an-idinnerrepository-interface"></a><span data-ttu-id="0abe9-202">Extrakce rozhraní IDinnerRepository</span><span class="sxs-lookup"><span data-stu-id="0abe9-202">Extracting an IDinnerRepository interface</span></span>

<span data-ttu-id="0abe9-203">Náš první krok vytvoří nové rozhraní IDinnerRepository, které zapouzdřuje kontrakty úložiště. naše řadiče potřebují načíst a aktualizovat večeři.</span><span class="sxs-lookup"><span data-stu-id="0abe9-203">Our first step will be to create a new IDinnerRepository interface that encapsulates the repository contract our controllers require to retrieve and update Dinners.</span></span>

<span data-ttu-id="0abe9-204">Tuto kontrakt rozhraní můžeme definovat ručně tak, že kliknete pravým tlačítkem na složku \Models a pak zvolíte příkaz nabídky **Přidat novou položku&gt;** a vytvoříte nové rozhraní s názvem IDinnerRepository.cs.</span><span class="sxs-lookup"><span data-stu-id="0abe9-204">We can define this interface contract manually by right-clicking on the \Models folder, and then choosing the **Add-&gt;New Item** menu command and creating a new interface named IDinnerRepository.cs.</span></span>

<span data-ttu-id="0abe9-205">K automatickému extrakci a vytvoření rozhraní pro nás z naší existující třídy DinnerRepository můžeme použít nástroje refaktoringu, které jsou integrované Visual Studio Professional (a novější edice).</span><span class="sxs-lookup"><span data-stu-id="0abe9-205">Alternatively we can use the refactoring tools built-into Visual Studio Professional (and higher editions) to automatically extract and create an interface for us from our existing DinnerRepository class.</span></span> <span data-ttu-id="0abe9-206">Chcete-li toto rozhraní extrahovat pomocí VS, jednoduše umístěte kurzor do textového editoru ve třídě DinnerRepository a potom klikněte pravým tlačítkem myši a zvolte příkaz **refaktoring-&gt;Extrahování rozhraní** nabídky:</span><span class="sxs-lookup"><span data-stu-id="0abe9-206">To extract this interface using VS, simply position the cursor in the text editor on the DinnerRepository class, and then right-click and choose the **Refactor-&gt;Extract Interface** menu command:</span></span>

![](enable-automated-unit-testing/_static/image7.png)

<span data-ttu-id="0abe9-207">Tím se otevře dialogové okno extrakce rozhraní a požádejte nás o název rozhraní, které se má vytvořit.</span><span class="sxs-lookup"><span data-stu-id="0abe9-207">This will launch the "Extract Interface" dialog and prompt us for the name of the interface to create.</span></span> <span data-ttu-id="0abe9-208">Ve výchozím nastavení bude IDinnerRepository a automaticky vybírat všechny veřejné metody pro existující třídu DinnerRepository pro přidání do rozhraní:</span><span class="sxs-lookup"><span data-stu-id="0abe9-208">It will default to IDinnerRepository and automatically select all public methods on the existing DinnerRepository class to add to the interface:</span></span>

![](enable-automated-unit-testing/_static/image8.png)

<span data-ttu-id="0abe9-209">Po kliknutí na tlačítko OK bude Visual Studio do naší aplikace přidávat nové rozhraní IDinnerRepository:</span><span class="sxs-lookup"><span data-stu-id="0abe9-209">When we click the "ok" button, Visual Studio will add a new IDinnerRepository interface to our application:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample5.cs)]

<span data-ttu-id="0abe9-210">A naše existující třída DinnerRepository se aktualizuje tak, aby implementovala rozhraní:</span><span class="sxs-lookup"><span data-stu-id="0abe9-210">And our existing DinnerRepository class will be updated so that it implements the interface:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample6.cs)]

#### <a name="updating-dinnerscontroller-to-support-constructor-injection"></a><span data-ttu-id="0abe9-211">Aktualizace DinnersController na podporu injektáže konstruktoru</span><span class="sxs-lookup"><span data-stu-id="0abe9-211">Updating DinnersController to support constructor injection</span></span>

<span data-ttu-id="0abe9-212">Teď aktualizujeme třídu DinnersController, aby používala nové rozhraní.</span><span class="sxs-lookup"><span data-stu-id="0abe9-212">We'll now update the DinnersController class to use the new interface.</span></span>

<span data-ttu-id="0abe9-213">Aktuálně DinnersController je pevně zakódována tak, že jeho pole "dinnerRepository" je vždy třída DinnerRepository:</span><span class="sxs-lookup"><span data-stu-id="0abe9-213">Currently DinnersController is hard-coded such that its "dinnerRepository" field is always a DinnerRepository class:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample7.cs)]

<span data-ttu-id="0abe9-214">Změníme ji tak, aby pole dinnerRepository bylo typu IDinnerRepository namísto DinnerRepository.</span><span class="sxs-lookup"><span data-stu-id="0abe9-214">We'll change it so that the "dinnerRepository" field is of type IDinnerRepository instead of DinnerRepository.</span></span> <span data-ttu-id="0abe9-215">Pak přidáme dva veřejné konstruktory DinnersController.</span><span class="sxs-lookup"><span data-stu-id="0abe9-215">We'll then add two public DinnersController constructors.</span></span> <span data-ttu-id="0abe9-216">Jeden z konstruktorů umožňuje předávat IDinnerRepository jako argument.</span><span class="sxs-lookup"><span data-stu-id="0abe9-216">One of the constructors allows an IDinnerRepository to be passed as an argument.</span></span> <span data-ttu-id="0abe9-217">Druhý je výchozí konstruktor, který používá naši stávající implementaci DinnerRepository:</span><span class="sxs-lookup"><span data-stu-id="0abe9-217">The other is a default constructor that uses our existing DinnerRepository implementation:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample8.cs)]

<span data-ttu-id="0abe9-218">Vzhledem k tomu, že ASP.NET MVC ve výchozím nastavení vytvoří třídy kontroléru pomocí výchozích konstruktorů, náš DinnersController za běhu bude k provádění přístupu k datům dál používat třídu DinnerRepository.</span><span class="sxs-lookup"><span data-stu-id="0abe9-218">Because ASP.NET MVC by default creates controller classes using default constructors, our DinnersController at runtime will continue to use the DinnerRepository class to perform data access.</span></span>

<span data-ttu-id="0abe9-219">Nyní můžeme aktualizovat naše testy jednotek, ale k předání "falešné" implementace úložiště večeře pomocí konstruktoru parametru.</span><span class="sxs-lookup"><span data-stu-id="0abe9-219">We can now update our unit tests, though, to pass in a "fake" dinner repository implementation using the parameter constructor.</span></span> <span data-ttu-id="0abe9-220">Toto "falešné" úložiště večeře nebude vyžadovat přístup ke skutečné databázi a místo toho bude používat ukázková data v paměti.</span><span class="sxs-lookup"><span data-stu-id="0abe9-220">This "fake" dinner repository will not require access to a real database, and instead will use in-memory sample data.</span></span>

#### <a name="creating-the-fakedinnerrepository-class"></a><span data-ttu-id="0abe9-221">Vytvoření třídy FakeDinnerRepository</span><span class="sxs-lookup"><span data-stu-id="0abe9-221">Creating the FakeDinnerRepository class</span></span>

<span data-ttu-id="0abe9-222">Pojďme vytvořit třídu FakeDinnerRepository.</span><span class="sxs-lookup"><span data-stu-id="0abe9-222">Let's create a FakeDinnerRepository class.</span></span>

<span data-ttu-id="0abe9-223">Začneme vytvořením "falešného" adresáře v rámci našeho projektu NerdDinner. Tests a následně do něj přidáte novou FakeDinnerRepository třídu (klikněte pravým tlačítkem na složku a vyberte **Přidat-&gt;novou třídu**):</span><span class="sxs-lookup"><span data-stu-id="0abe9-223">We'll begin by creating a "Fakes" directory within our NerdDinner.Tests project and then add a new FakeDinnerRepository class to it (right-click on the folder and choose **Add-&gt;New Class**):</span></span>

![](enable-automated-unit-testing/_static/image9.png)

<span data-ttu-id="0abe9-224">Aktualizujeme kód tak, aby třída FakeDinnerRepository implementovala rozhraní IDinnerRepository.</span><span class="sxs-lookup"><span data-stu-id="0abe9-224">We'll update the code so that the FakeDinnerRepository class implements the IDinnerRepository interface.</span></span> <span data-ttu-id="0abe9-225">Pak na ni můžeme kliknout pravým tlačítkem a zvolit příkaz "implementovat rozhraní IDinnerRepository", který je v místní nabídce:</span><span class="sxs-lookup"><span data-stu-id="0abe9-225">We can then right-click on it and choose the "Implement interface IDinnerRepository" context menu command:</span></span>

![](enable-automated-unit-testing/_static/image10.png)

<span data-ttu-id="0abe9-226">To způsobí, že Visual Studio automaticky přidá všechny členy rozhraní IDinnerRepository do naší třídy FakeDinnerRepository s výchozími implementacemi "stub ven":</span><span class="sxs-lookup"><span data-stu-id="0abe9-226">This will cause Visual Studio to automatically add all of the IDinnerRepository interface members to our FakeDinnerRepository class with default "stub out" implementations:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample9.cs)]

<span data-ttu-id="0abe9-227">Pak můžeme aktualizovat implementaci FakeDinnerRepository, aby fungovala v seznamu v paměti&lt;večeři&gt; z kolekce do ní jako argument konstruktoru:</span><span class="sxs-lookup"><span data-stu-id="0abe9-227">We can then update the FakeDinnerRepository implementation to work off of an in-memory List&lt;Dinner&gt; collection passed to it as a constructor argument:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample10.cs)]

<span data-ttu-id="0abe9-228">Nyní máme falešnou implementaci IDinnerRepository, která nevyžaduje databázi, a může místo toho pracovat v seznamu objektů večeře v paměti.</span><span class="sxs-lookup"><span data-stu-id="0abe9-228">We now have a fake IDinnerRepository implementation that does not require a database, and can instead work off an in-memory list of Dinner objects.</span></span>

#### <a name="using-the-fakedinnerrepository-with-unit-tests"></a><span data-ttu-id="0abe9-229">Použití FakeDinnerRepository s testováním částí</span><span class="sxs-lookup"><span data-stu-id="0abe9-229">Using the FakeDinnerRepository with Unit Tests</span></span>

<span data-ttu-id="0abe9-230">Pojďme se vrátit k testům DinnersController jednotek, které se dřív nezdařily, protože databáze nebyla k dispozici.</span><span class="sxs-lookup"><span data-stu-id="0abe9-230">Let's return to the DinnersController unit tests that failed earlier because the database wasn't available.</span></span> <span data-ttu-id="0abe9-231">Testovací metody můžeme aktualizovat tak, aby používaly FakeDinnerRepository vyplněné pomocí ukázky dat s daty o večeři v paměti pro DinnersController pomocí následujícího kódu:</span><span class="sxs-lookup"><span data-stu-id="0abe9-231">We can update the test methods to use a FakeDinnerRepository populated with sample in-memory Dinner data to the DinnersController using the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample11.cs)]

<span data-ttu-id="0abe9-232">A teď když spustíme tyto testy, oba projdou:</span><span class="sxs-lookup"><span data-stu-id="0abe9-232">And now when we run these tests they both pass:</span></span>

![](enable-automated-unit-testing/_static/image11.png)

<span data-ttu-id="0abe9-233">To nejlepší z nich trvá pouze zlomek sekundy ke spuštění a nevyžadují žádnou složitou logiku nastavení/vyčištění.</span><span class="sxs-lookup"><span data-stu-id="0abe9-233">Best of all, they take only a fraction of a second to run, and do not require any complicated setup/cleanup logic.</span></span> <span data-ttu-id="0abe9-234">Nyní můžeme otestovat všechny naše kódy metod DinnersController akce (včetně výpisu, stránkování, podrobností, vytvoření, aktualizace a odstranění), aniž byste museli se připojit ke skutečné databázi.</span><span class="sxs-lookup"><span data-stu-id="0abe9-234">We can now unit test all of our DinnersController action method code (including listing, paging, details, create, update and delete) without ever needing to connect to a real database.</span></span>

| <span data-ttu-id="0abe9-235">**Vedlejší téma: rozhraní pro vkládání závislostí**</span><span class="sxs-lookup"><span data-stu-id="0abe9-235">**Side Topic: Dependency Injection Frameworks**</span></span> |
| --- |
| <span data-ttu-id="0abe9-236">Provedení ručního vkládání závislostí (podobně jako v předchozím případě) funguje bez problémů, ale je těžší je udržovat, protože se zvyšuje počet závislostí a komponent v aplikaci.</span><span class="sxs-lookup"><span data-stu-id="0abe9-236">Performing manual dependency injection (like we are above) works fine, but does become harder to maintain as the number of dependencies and components in an application increases.</span></span> <span data-ttu-id="0abe9-237">Pro rozhraní .NET existuje několik platforem vkládání závislostí, které vám pomůžou zajistit ještě větší flexibilitu pro správu závislostí.</span><span class="sxs-lookup"><span data-stu-id="0abe9-237">Several dependency injection frameworks exist for .NET that can help provide even more dependency management flexibility.</span></span> <span data-ttu-id="0abe9-238">Tyto architektury, někdy označované také jako "inverze ovládacích prvků" (IoC), poskytují mechanismy, které umožňují další úroveň konfigurace pro zadání a předání závislostí objektům v době běhu (nejčastěji pomocí injektáže konstruktoru). ).</span><span class="sxs-lookup"><span data-stu-id="0abe9-238">These frameworks, also sometimes called "Inversion of Control" (IoC) containers, provide mechanisms that enable an additional level of configuration support for specifying and passing dependencies to objects at runtime (most often using constructor injection).</span></span> <span data-ttu-id="0abe9-239">Mezi nejoblíbenější rozhraní injektáže/IOC závislostí OSS v rozhraní .NET patří: AutoFac, Ninject, Spring.NET, StructureMap a Windsor.</span><span class="sxs-lookup"><span data-stu-id="0abe9-239">Some of the more popular OSS Dependency Injection / IOC frameworks in .NET include: AutoFac, Ninject, Spring.NET, StructureMap, and Windsor.</span></span> <span data-ttu-id="0abe9-240">ASP.NET MVC zpřístupňuje rozhraní API pro rozšiřitelnost, která vývojářům umožňují zapojit se do řešení a vytváření instancí řadičů a která umožňuje čistě integrovat rozhraní injektáže/IoC pro závislosti v rámci tohoto procesu.</span><span class="sxs-lookup"><span data-stu-id="0abe9-240">ASP.NET MVC exposes extensibility APIs that enable developers to participate in the resolution and instantiation of controllers, and which enables Dependency Injection / IoC frameworks to be cleanly integrated within this process.</span></span> <span data-ttu-id="0abe9-241">Použití rozhraní DI/IOC by nám také umožnilo odebrat výchozí konstruktor z našeho DinnersController – což by zcela odebralo spojení mezi ním a DinnerRepository.</span><span class="sxs-lookup"><span data-stu-id="0abe9-241">Using a DI/IOC framework would also enable us to remove the default constructor from our DinnersController – which would completely remove the coupling between it and the DinnerRepository.</span></span> <span data-ttu-id="0abe9-242">V naší aplikaci NerdDinner nebudeme používat rozhraní pro vkládání závislostí/IOC.</span><span class="sxs-lookup"><span data-stu-id="0abe9-242">We won't be using a dependency injection / IOC framework with our NerdDinner application.</span></span> <span data-ttu-id="0abe9-243">Ale je to něco, co můžeme v budoucnu zvážit, pokud se NerdDinner základ kódu a možnosti.</span><span class="sxs-lookup"><span data-stu-id="0abe9-243">But it is something we could consider for the future if the NerdDinner code-base and capabilities grew.</span></span> |

### <a name="creating-edit-action-unit-tests"></a><span data-ttu-id="0abe9-244">Vytváření testů jednotek akcí úprav</span><span class="sxs-lookup"><span data-stu-id="0abe9-244">Creating Edit Action Unit Tests</span></span>

<span data-ttu-id="0abe9-245">Pojďme teď vytvořit několik testů jednotek, které ověřují funkčnost DinnersController.</span><span class="sxs-lookup"><span data-stu-id="0abe9-245">Let's now create some unit tests that verify the Edit functionality of the DinnersController.</span></span> <span data-ttu-id="0abe9-246">Začneme otestováním verze HTTP-GET naší akce úprav:</span><span class="sxs-lookup"><span data-stu-id="0abe9-246">We'll start by testing the HTTP-GET version of our Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample12.cs)]

<span data-ttu-id="0abe9-247">Vytvoříme test, který ověří, že zobrazení, které je zajištěné objektem DinnerFormViewModel, se vrátí zpět, když se požaduje platná večeře:</span><span class="sxs-lookup"><span data-stu-id="0abe9-247">We'll create a test that verifies that a View backed by a DinnerFormViewModel object is rendered back when a valid dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample13.cs)]

<span data-ttu-id="0abe9-248">Když tento test spustíte, zjistíme, že se to nepovede, protože je vyvolána výjimka odkazu s hodnotou null, pokud metoda Edit přistupuje k vlastnosti User.Identity.Name, která provede kontrolu večeři. IsHostedBy ().</span><span class="sxs-lookup"><span data-stu-id="0abe9-248">When we run the test, though, we'll find that it fails because a null reference exception is thrown when the Edit method accesses the User.Identity.Name property to perform the Dinner.IsHostedBy() check.</span></span>

<span data-ttu-id="0abe9-249">Objekt uživatele v základní třídě kontroleru zapouzdřuje podrobnosti o přihlášeném uživateli a při vytváření kontroleru za běhu ho naplní ASP.NET MVC.</span><span class="sxs-lookup"><span data-stu-id="0abe9-249">The User object on the Controller base class encapsulates details about the logged-in user, and is populated by ASP.NET MVC when it creates the controller at runtime.</span></span> <span data-ttu-id="0abe9-250">Vzhledem k tomu, že testujeme DinnersController mimo prostředí webového serveru, objekt uživatele není nastaven (tedy výjimka odkazu s hodnotou null).</span><span class="sxs-lookup"><span data-stu-id="0abe9-250">Because we are testing the DinnersController outside of a web-server environment, the User object isn't set (hence the null reference exception).</span></span>

### <a name="mocking-the-useridentityname-property"></a><span data-ttu-id="0abe9-251">Napodobení vlastnosti User.Identity.Name</span><span class="sxs-lookup"><span data-stu-id="0abe9-251">Mocking the User.Identity.Name property</span></span>

<span data-ttu-id="0abe9-252">Napodobení rozhraní usnadňuje testování tím, že nám umožní dynamicky vytvářet falešné verze závislých objektů, které podporují naše testy.</span><span class="sxs-lookup"><span data-stu-id="0abe9-252">Mocking frameworks make testing easier by enabling us to dynamically create fake versions of dependent objects that support our tests.</span></span> <span data-ttu-id="0abe9-253">Například můžeme použít napodobnou architekturu v testu akcí úprav k dynamickému vytvoření objektu uživatele, který může DinnersController použít k vyhledání simulovaného uživatelského jména.</span><span class="sxs-lookup"><span data-stu-id="0abe9-253">For example, we can use a mocking framework in our Edit action test to dynamically create a User object that our DinnersController can use to lookup a simulated username.</span></span> <span data-ttu-id="0abe9-254">Tím se vyhnete vyjímka nulového odkazu, když spustíme náš test.</span><span class="sxs-lookup"><span data-stu-id="0abe9-254">This will avoid a null reference from being thrown when we run our test.</span></span>

<span data-ttu-id="0abe9-255">Existuje mnoho rozhraní .NET, které lze použít s ASP.NET MVC (můžete zobrazit jejich seznam: [http://www.mockframeworks.com/](http://www.mockframeworks.com/)).</span><span class="sxs-lookup"><span data-stu-id="0abe9-255">There are many .NET mocking frameworks that can be used with ASP.NET MVC (you can see a list of them here: [http://www.mockframeworks.com/](http://www.mockframeworks.com/)).</span></span> <span data-ttu-id="0abe9-256">Pro testování naší aplikace NerdDinner použijeme Open Source modelující rozhraní s názvem "MOQ", které se dá zdarma stáhnout z [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq).</span><span class="sxs-lookup"><span data-stu-id="0abe9-256">For testing our NerdDinner application we'll use an open source mocking framework called "Moq", which can be downloaded for free from [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq).</span></span>

<span data-ttu-id="0abe9-257">Po stažení přidáme odkaz do našeho projektu NerdDinner. Tests do sestavení MOQ. dll:</span><span class="sxs-lookup"><span data-stu-id="0abe9-257">Once downloaded, we'll add a reference in our NerdDinner.Tests project to the Moq.dll assembly:</span></span>

![](enable-automated-unit-testing/_static/image12.png)

<span data-ttu-id="0abe9-258">Pak přidáte pomocnou metodu "CreateDinnersControllerAs (uživatelské jméno)" do naší třídy testu, která převezme uživatelské jméno jako parametr a pak "navýšení" vlastnosti User.Identity.Name na instanci DinnersController:</span><span class="sxs-lookup"><span data-stu-id="0abe9-258">We'll then add a "CreateDinnersControllerAs(username)" helper method to our test class that takes a username as a parameter, and which then "mocks" the User.Identity.Name property on the DinnersController instance:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample14.cs)]

<span data-ttu-id="0abe9-259">Výše používáme MOQ k vytvoření objektu makety, který předstírá objekt ControllerContext (což je to, co ASP.NET MVC projde do tříd kontroleru a zpřístupňuje běhové objekty, jako je uživatel, požadavek, odpověď a relace).</span><span class="sxs-lookup"><span data-stu-id="0abe9-259">Above we are using Moq to create a Mock object that fakes a ControllerContext object (which is what ASP.NET MVC passes to Controller classes to expose runtime objects like User, Request, Response, and Session).</span></span> <span data-ttu-id="0abe9-260">Voláme metodu "SetupGet" na tomto typu, aby označovala, že vlastnost HttpContext.User.Identity.Name v ControllerContext by měla vracet uživatelský řetězec, který předal pomocná metoda.</span><span class="sxs-lookup"><span data-stu-id="0abe9-260">We are calling the "SetupGet" method on the Mock to indicate that the HttpContext.User.Identity.Name property on ControllerContext should return the username string we passed to the helper method.</span></span>

<span data-ttu-id="0abe9-261">Můžeme navýšit libovolný počet ControllerContext vlastností a metod.</span><span class="sxs-lookup"><span data-stu-id="0abe9-261">We can mock any number of ControllerContext properties and methods.</span></span> <span data-ttu-id="0abe9-262">Pro ilustraci toho jsem také přidali volání SetupGet () pro vlastnost Request. Authentication (která není ve skutečnosti nutná pro následující testy, ale pomáhá ilustrovat, jak můžete popsáním vlastností žádosti).</span><span class="sxs-lookup"><span data-stu-id="0abe9-262">To illustrate this I've also added a SetupGet() call for the Request.IsAuthenticated property (which isn't actually needed for the tests below – but which helps illustrate how you can mock Request properties).</span></span> <span data-ttu-id="0abe9-263">Až se dokončíme, přiřadíme instanci ControllerContextového objektu k DinnersController, že se naše pomocná metoda vrátí.</span><span class="sxs-lookup"><span data-stu-id="0abe9-263">When we are done we assign an instance of the ControllerContext mock to the DinnersController our helper method returns.</span></span>

<span data-ttu-id="0abe9-264">Nyní můžeme napsat testy jednotek, které používají tuto pomocnou metodu k testování scénářů úprav týkajících se různých uživatelů:</span><span class="sxs-lookup"><span data-stu-id="0abe9-264">We can now write unit tests that use this helper method to test Edit scenarios involving different users:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample15.cs)]

<span data-ttu-id="0abe9-265">A teď když spustíme testy, které projdou:</span><span class="sxs-lookup"><span data-stu-id="0abe9-265">And now when we run the tests they pass:</span></span>

![](enable-automated-unit-testing/_static/image13.png)

### <a name="testing-updatemodel-scenarios"></a><span data-ttu-id="0abe9-266">Testování scénářů UpdateModel ()</span><span class="sxs-lookup"><span data-stu-id="0abe9-266">Testing UpdateModel() scenarios</span></span>

<span data-ttu-id="0abe9-267">Vytvořili jsme testy, které pokrývají verzi HTTP-GET akce upravit.</span><span class="sxs-lookup"><span data-stu-id="0abe9-267">We've created tests that cover the HTTP-GET version of the Edit action.</span></span> <span data-ttu-id="0abe9-268">Teď vytvoříme některé testy, které ověřují verzi HTTP-POST akce upravit:</span><span class="sxs-lookup"><span data-stu-id="0abe9-268">Let's now create some tests that verify the HTTP-POST version of the Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample16.cs)]

<span data-ttu-id="0abe9-269">Zajímavý nový scénář testování, který podporuje podporu pomocí této metody Action, je jeho využití pomocné metody UpdateModel () na základní třídě kontroleru.</span><span class="sxs-lookup"><span data-stu-id="0abe9-269">The interesting new testing scenario for us to support with this action method is its usage of the UpdateModel() helper method on the Controller base class.</span></span> <span data-ttu-id="0abe9-270">Tuto pomocnou metodu používáme k vytvoření vazby hodnot formuláře-post k naší instanci objektu večeře.</span><span class="sxs-lookup"><span data-stu-id="0abe9-270">We are using this helper method to bind form-post values to our Dinner object instance.</span></span>

<span data-ttu-id="0abe9-271">Níže jsou dva testy, které demonstrují, jak můžeme dodat vyslané hodnoty pro pomocnou metodu UpdateModel (), která se má použít.</span><span class="sxs-lookup"><span data-stu-id="0abe9-271">Below are two tests that demonstrates how we can supply form posted values for the UpdateModel() helper method to use.</span></span> <span data-ttu-id="0abe9-272">Provedeme to tak, že vytvoříme a naplníme objekt objektucollection a pak ho přiřadíte do vlastnosti "ValueProvider" na řadiči.</span><span class="sxs-lookup"><span data-stu-id="0abe9-272">We'll do this by creating and populating a FormCollection object, and then assign it to the "ValueProvider" property on the Controller.</span></span>

<span data-ttu-id="0abe9-273">První test ověří, zda je v úspěšném uložení prohlížeč přesměrován na akci podrobnosti.</span><span class="sxs-lookup"><span data-stu-id="0abe9-273">The first test verifies that on a successful save the browser is redirected to the details action.</span></span> <span data-ttu-id="0abe9-274">Druhý test ověří, zda je při odeslání neplatného vstupu Tato akce znovu znovu zobrazuje zobrazení pro úpravy s chybovou zprávou.</span><span class="sxs-lookup"><span data-stu-id="0abe9-274">The second test verifies that when invalid input is posted the action redisplays the edit view again with an error message.</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample17.cs)]

### <a name="testing-wrap-up"></a><span data-ttu-id="0abe9-275">Testování zabalení</span><span class="sxs-lookup"><span data-stu-id="0abe9-275">Testing Wrap-Up</span></span>

<span data-ttu-id="0abe9-276">Pokryli jsme základní koncepty týkající se tříd kontroleru testování částí.</span><span class="sxs-lookup"><span data-stu-id="0abe9-276">We've covered the core concepts involved in unit testing controller classes.</span></span> <span data-ttu-id="0abe9-277">Tyto techniky můžeme použít k snadnému vytvoření stovek jednoduchých testů, které ověřují chování naší aplikace.</span><span class="sxs-lookup"><span data-stu-id="0abe9-277">We can use these techniques to easily create hundreds of simple tests that verify the behavior of our application.</span></span>

<span data-ttu-id="0abe9-278">Vzhledem k tomu, že naše testy kontrol řadičů a modelů nevyžadují skutečnou databázi, jsou extrémně rychlé a snadno se spouštějí.</span><span class="sxs-lookup"><span data-stu-id="0abe9-278">Because our controller and model tests do not require a real database, they are extremely fast and easy to run.</span></span> <span data-ttu-id="0abe9-279">V řádu sekund budeme moci spustit stovky automatizovaných testů a okamžitě získat zpětnou vazbu, ať už jsme udělali změnu, kterou jsme podařilo přerušiti.</span><span class="sxs-lookup"><span data-stu-id="0abe9-279">We'll be able to execute hundreds of automated tests in seconds, and immediately get feedback as to whether a change we made broke something.</span></span> <span data-ttu-id="0abe9-280">To nám pomůže zajistit nepřetržitou vylepšování naší aplikace, refaktorování a upřesnění naší aplikace.</span><span class="sxs-lookup"><span data-stu-id="0abe9-280">This will help provide us the confidence to continually improve, refactor, and refine our application.</span></span>

<span data-ttu-id="0abe9-281">Pokryli jsme testování jako poslední téma v této kapitole – ale ne, protože testování je něco, co byste měli dělat na konci procesu vývoje!</span><span class="sxs-lookup"><span data-stu-id="0abe9-281">We covered testing as the last topic in this chapter – but not because testing is something you should do at the end of a development process!</span></span> <span data-ttu-id="0abe9-282">V opačném případě byste měli psát automatizované testy co nejdříve v procesu vývoje.</span><span class="sxs-lookup"><span data-stu-id="0abe9-282">On the contrary, you should write automated tests as early as possible in your development process.</span></span> <span data-ttu-id="0abe9-283">Díky tomu můžete při vývoji získat okamžitou zpětnou vazbu, která vám pomůže představit Thoughtfully o scénářích použití vaší aplikace a provede vás návrhem aplikace pomocí čistého vrstvení a přihlašování.</span><span class="sxs-lookup"><span data-stu-id="0abe9-283">Doing so enables you to get immediate feedback as you develop, helps you think thoughtfully about your application's use case scenarios, and guides you to design your application with clean layering and coupling in mind.</span></span>

<span data-ttu-id="0abe9-284">Pozdější kapitola v knize bude diskutovat o vývoji řízených testováním (TDD) a jeho použití s ASP.NET MVC.</span><span class="sxs-lookup"><span data-stu-id="0abe9-284">A later chapter in the book will discuss Test Driven Development (TDD), and how to use it with ASP.NET MVC.</span></span> <span data-ttu-id="0abe9-285">TDD je iterativní postup kódování, kde nejprve zapíšete testy, které váš výsledný kód bude vyhovovat.</span><span class="sxs-lookup"><span data-stu-id="0abe9-285">TDD is an iterative coding practice where you first write the tests that your resulting code will satisfy.</span></span> <span data-ttu-id="0abe9-286">Pomocí TDD zahájíte jednotlivé funkce vytvořením testu, který ověří funkčnost, kterou se chystáte implementovat.</span><span class="sxs-lookup"><span data-stu-id="0abe9-286">With TDD you begin each feature by creating a test that verifies the functionality you are about to implement.</span></span> <span data-ttu-id="0abe9-287">Zapsání testu jednotek jako první vám pomůže zajistit, že tato funkce bude jasně srozumitelná a jak má fungovat.</span><span class="sxs-lookup"><span data-stu-id="0abe9-287">Writing the unit test first helps ensure that you clearly understand the feature and how it is supposed to work.</span></span> <span data-ttu-id="0abe9-288">Až po zápisu testu (a ověření, že se nezdařil), implementujete vlastní funkce, které test ověří.</span><span class="sxs-lookup"><span data-stu-id="0abe9-288">Only after the test is written (and you have verified that it fails) do you then implement the actual functionality the test verifies.</span></span> <span data-ttu-id="0abe9-289">Vzhledem k tomu, že jste už věnovali čas v tom, jak má funkce fungovat, budete mít lepší znalosti o požadavcích a jejich implementaci.</span><span class="sxs-lookup"><span data-stu-id="0abe9-289">Because you've already spent time thinking about the use case of how the feature is supposed to work, you will have a better understanding of the requirements and how best to implement them.</span></span> <span data-ttu-id="0abe9-290">Až budete s implementací hotovi, můžete znovu spustit test – a získat okamžitou zpětnou vazbu k tomu, zda funkce funguje správně.</span><span class="sxs-lookup"><span data-stu-id="0abe9-290">When you are done with the implementation you can re-run the test – and get immediate feedback as to whether the feature works correctly.</span></span> <span data-ttu-id="0abe9-291">V kapitole 10 se budeme zabývat více TDD.</span><span class="sxs-lookup"><span data-stu-id="0abe9-291">We'll cover TDD more in Chapter 10.</span></span>

### <a name="next-step"></a><span data-ttu-id="0abe9-292">Další krok</span><span class="sxs-lookup"><span data-stu-id="0abe9-292">Next Step</span></span>

<span data-ttu-id="0abe9-293">Některé konečné komentáře k zabalení.</span><span class="sxs-lookup"><span data-stu-id="0abe9-293">Some final wrap up comments.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="0abe9-294">[Předchozí](use-ajax-to-implement-mapping-scenarios.md)
> [Další](nerddinner-wrap-up.md)</span><span class="sxs-lookup"><span data-stu-id="0abe9-294">[Previous](use-ajax-to-implement-mapping-scenarios.md)
[Next](nerddinner-wrap-up.md)</span></span>
