---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: Prevence XSRF/CSRF v ASP.NET MVC a webových stránkách | Microsoft Docs
author: Rick-Anderson
description: Padělání žádostí mezi weby (označované také jako XSRF nebo CSRF) představuje útok proti aplikacím hostovaným na webu, kde může škodlivý web ovlivnit interakci...
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 1965063a9b613d0e2857cddcc2165f5fda64ec0c
ms.sourcegitcommit: 7709c0a091b8d55b7b33bad8849f7b66b23c3d72
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 02/19/2020
ms.locfileid: "77455526"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="85f3f-103">Prevence XSRF/CSRF v ASP.NET MVC a na webových stránkách</span><span class="sxs-lookup"><span data-stu-id="85f3f-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>

<span data-ttu-id="85f3f-104">od [Rick Anderson](https://twitter.com/RickAndMSFT)</span><span class="sxs-lookup"><span data-stu-id="85f3f-104">by [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

> <span data-ttu-id="85f3f-105">Padělání žádostí mezi weby (označované také jako XSRF nebo CSRF) představuje útok proti aplikacím hostovaným na webu, kdy škodlivý web může ovlivnit interakci mezi klientským prohlížečem a webem, který tento prohlížeč důvěřuje.</span><span class="sxs-lookup"><span data-stu-id="85f3f-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="85f3f-106">Tyto útoky byly umožněny, protože webové prohlížeče budou automaticky odesílat ověřovací tokeny s každým požadavkem na web.</span><span class="sxs-lookup"><span data-stu-id="85f3f-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="85f3f-107">Kanonický příklad je ověřovací soubor cookie, jako je například ASP. Lístek pro ověřování formulářů netto.</span><span class="sxs-lookup"><span data-stu-id="85f3f-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="85f3f-108">Tyto útoky ale můžou cílit na weby, které používají jakýkoliv mechanismus trvalého ověřování (například ověřování systému Windows, Basic a tak dále).</span><span class="sxs-lookup"><span data-stu-id="85f3f-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="85f3f-109">Útok XSRF se liší od útoku phishing.</span><span class="sxs-lookup"><span data-stu-id="85f3f-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="85f3f-110">Útoky typu phishing vyžadují interakci od oběti.</span><span class="sxs-lookup"><span data-stu-id="85f3f-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="85f3f-111">V útokech na útok phishing se škodlivý web napodobá cílovému webu a oběť se na něj zahájí poskytování citlivých informací útočníkovi.</span><span class="sxs-lookup"><span data-stu-id="85f3f-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="85f3f-112">V útoku XSRF není často potřeba žádná interakce od oběti.</span><span class="sxs-lookup"><span data-stu-id="85f3f-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="85f3f-113">Místo toho se útočník spoléhá na to, že prohlížeč automaticky posílá všechny relevantní soubory cookie do cílového webu.</span><span class="sxs-lookup"><span data-stu-id="85f3f-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="85f3f-114">Další informace naleznete v tématu [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span><span class="sxs-lookup"><span data-stu-id="85f3f-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>

## <a name="anatomy-of-an-attack"></a><span data-ttu-id="85f3f-115">Anatomie útoku</span><span class="sxs-lookup"><span data-stu-id="85f3f-115">Anatomy of an attack</span></span>

<span data-ttu-id="85f3f-116">Pokud chcete projít útokem XSRF, vezměte v úvahu uživatele, který chce provést některé online bankovní transakce.</span><span class="sxs-lookup"><span data-stu-id="85f3f-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="85f3f-117">Tento uživatel nejdřív navštíví WoodgroveBank.com a přihlásí se. v takovém případě bude hlavička odpovědi obsahovat ověřovací soubor cookie:</span><span class="sxs-lookup"><span data-stu-id="85f3f-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="85f3f-118">Vzhledem k tomu, že soubor cookie ověřování je soubor cookie relace, bude při ukončení procesu prohlížeče automaticky vymazán prohlížečem.</span><span class="sxs-lookup"><span data-stu-id="85f3f-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="85f3f-119">Do té doby ale bude prohlížeč automaticky zahrnovat soubor cookie s každým požadavkem na WoodgroveBank.com.</span><span class="sxs-lookup"><span data-stu-id="85f3f-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com.</span></span> <span data-ttu-id="85f3f-120">Uživatel teď chce přenést $1000 na jiný účet, takže vyplní formulář na bankovním webu a prohlížeč tento požadavek provede na server:</span><span class="sxs-lookup"><span data-stu-id="85f3f-120">The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="85f3f-121">Vzhledem k tomu, že tato operace má vedlejší efekt (iniciuje peněžní transakce), banka se pro zahájení této operace rozhodla vyžadovat požadavek HTTP POST.</span><span class="sxs-lookup"><span data-stu-id="85f3f-121">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="85f3f-122">Server přečte ověřovací token z požadavku, vyhledá číslo účtu uživatele, ověří, že existuje dostatek prostředků, a pak transakci inicializuje do cílového účtu.</span><span class="sxs-lookup"><span data-stu-id="85f3f-122">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="85f3f-123">Její online banka je dokončena, uživatel přejde pryč z bankovního serveru a navštíví další místa na webu.</span><span class="sxs-lookup"><span data-stu-id="85f3f-123">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="85f3f-124">Jedna z těchto lokalit – fabrikam.com – obsahuje následující značky na stránce vložené do &lt;IFRAME&gt;:</span><span class="sxs-lookup"><span data-stu-id="85f3f-124">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="85f3f-125">To následně způsobí, že prohlížeč tuto žádost provede:</span><span class="sxs-lookup"><span data-stu-id="85f3f-125">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="85f3f-126">Útočník zneužije skutečnost, že uživatel může mít stále platný ověřovací token pro cílový web, a používá malý fragment kódu JavaScriptu, který způsobí, že prohlížeč vytvoří automaticky příspěvek HTTP do cílové lokality.</span><span class="sxs-lookup"><span data-stu-id="85f3f-126">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="85f3f-127">Pokud je ověřovací token stále platný, bude bankovní web iniciovat přenos $250 na účet výběru útočníka.</span><span class="sxs-lookup"><span data-stu-id="85f3f-127">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="85f3f-128">Neúčinná omezení</span><span class="sxs-lookup"><span data-stu-id="85f3f-128">Ineffective mitigations</span></span>

<span data-ttu-id="85f3f-129">Je zajímavá Poznámka, že ve výše uvedeném scénáři byl přístup k WoodgroveBank.com přes SSL a že soubor cookie pro ověřování pouze SSL nebyl pro vzdoruje útok nedostatečný.</span><span class="sxs-lookup"><span data-stu-id="85f3f-129">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="85f3f-130">Útočník může v jeho &lt;&gt; elementu zadat [schéma identifikátoru URI](http://en.wikipedia.org/wiki/URI_scheme) (https) a prohlížeč bude nadále odesílat soubory cookie s neplatnými hodnotami do cílové lokality, pokud jsou tyto soubory cookie konzistentní se SCHÉMATem identifikátoru URI zamýšleného cíle.</span><span class="sxs-lookup"><span data-stu-id="85f3f-130">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="85f3f-131">Jedna z nich by mohla tvrdí, že by uživatel neměl navštěvovat nedůvěryhodné lokality, protože navštěvují jenom důvěryhodné weby, což může zůstat v bezpečí online.</span><span class="sxs-lookup"><span data-stu-id="85f3f-131">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="85f3f-132">Je to pro vás něco pravdy, ale tato doporučení nejsou vždycky praktická.</span><span class="sxs-lookup"><span data-stu-id="85f3f-132">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="85f3f-133">Například uživatel "důvěřuje" místnímu webu novinek ConsolidatedMessenger.</span><span class="sxs-lookup"><span data-stu-id="85f3f-133">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="85f3f-134">ConsolidatedMessenger.com a přejde k návštěvě tohoto webu, ale tato lokalita má zranitelnost XSS, která útočníkovi umožňuje vložit stejný fragment kódu, který běžel v fabrikam.com.</span><span class="sxs-lookup"><span data-stu-id="85f3f-134">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="85f3f-135">Můžete ověřit, že příchozí požadavky mají v [dokumentaci](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) k vaší doméně referenční hlavičku.</span><span class="sxs-lookup"><span data-stu-id="85f3f-135">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="85f3f-136">Tím se zastaví požadavky unwittingly odeslané z domény třetí strany.</span><span class="sxs-lookup"><span data-stu-id="85f3f-136">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="85f3f-137">Někteří lidé ale z důvodů ochrany osobních údajů zakázali hlavičku tohoto prohlížeče v prohlížeči a útočníci můžou v případě, že má poškozený nějaký nezabezpečený software, někdy tuto hlavičku falešné.</span><span class="sxs-lookup"><span data-stu-id="85f3f-137">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="85f3f-138">Ověření [záhlaví odkazujícího](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) nástroje není považováno za zabezpečený přístup k prevenci útoků XSRF.</span><span class="sxs-lookup"><span data-stu-id="85f3f-138">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="85f3f-139">Zmírnění rizik v modulu runtime webového zásobníku</span><span class="sxs-lookup"><span data-stu-id="85f3f-139">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="85f3f-140">Modul runtime webového zásobníku ASP.NET používá variantu [vzoru tokenu synchronizátoru](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) k obraně před útoky XSRF.</span><span class="sxs-lookup"><span data-stu-id="85f3f-140">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="85f3f-141">Základní forma vzoru tokenu synchronizátoru je, že se na server odesílají dva tokeny anti-XSRF (kromě ověřovacího tokenu): jeden token jako soubor cookie a druhý jako hodnota formuláře.</span><span class="sxs-lookup"><span data-stu-id="85f3f-141">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="85f3f-142">Hodnoty tokenu generované modulem runtime ASP.NET nejsou tímto útočníkem deterministické ani předvídatelné.</span><span class="sxs-lookup"><span data-stu-id="85f3f-142">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="85f3f-143">Po odeslání tokenů Server umožní, aby žádost pokračovala pouze v případě, že obě tokeny přejdou kontrolu porovnání.</span><span class="sxs-lookup"><span data-stu-id="85f3f-143">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="85f3f-144">*Token relace* ověření požadavku XSRF je uložený jako soubor cookie http a v současné době obsahuje následující informace:</span><span class="sxs-lookup"><span data-stu-id="85f3f-144">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="85f3f-145">Token zabezpečení, který se skládá z náhodného 128 identifikátoru.</span><span class="sxs-lookup"><span data-stu-id="85f3f-145">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="85f3f-146">Na následujícím obrázku vidíte token relace žádosti XSRF, který je zobrazený pomocí nástrojů pro vývojáře v Internet Exploreru F12: (Všimněte si, že se jedná o aktuální implementaci a že je předmětný, i když se může změnit.)</span><span class="sxs-lookup"><span data-stu-id="85f3f-146">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="85f3f-147">*Token pole* je uložen jako `<input type="hidden" />` a ve své datové části obsahuje následující informace:</span><span class="sxs-lookup"><span data-stu-id="85f3f-147">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="85f3f-148">Uživatelské jméno přihlášeného uživatele (Pokud je ověřeno).</span><span class="sxs-lookup"><span data-stu-id="85f3f-148">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="85f3f-149">Všechna další data, která poskytuje [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span><span class="sxs-lookup"><span data-stu-id="85f3f-149">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="85f3f-150">Datové části tokenů anti-XSRF jsou šifrované a podepsané, takže nemůžete zobrazit uživatelské jméno při použití nástrojů k prohlédnutí tokenů.</span><span class="sxs-lookup"><span data-stu-id="85f3f-150">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="85f3f-151">Pokud je webová aplikace cílena na ASP.NET 4,0, kryptografické služby jsou k dispozici pomocí rutiny [machineKey. Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) .</span><span class="sxs-lookup"><span data-stu-id="85f3f-151">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="85f3f-152">Pokud je webová aplikace cílena na ASP.NET 4,5 nebo vyšší, kryptografické služby jsou poskytovány rutinou [machineKey. Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) , která nabízí lepší výkon, rozšiřitelnost a zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="85f3f-152">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="85f3f-153">Další podrobnosti najdete v následujících blogových příspěvcích:</span><span class="sxs-lookup"><span data-stu-id="85f3f-153">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="85f3f-154">Vylepšení kryptografie v ASP.NET 4,5, PT. 1</span><span class="sxs-lookup"><span data-stu-id="85f3f-154">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="85f3f-155">Vylepšení kryptografie v ASP.NET 4,5, PT. 2</span><span class="sxs-lookup"><span data-stu-id="85f3f-155">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="85f3f-156">Vylepšení kryptografie v ASP.NET 4,5, PT. 3</span><span class="sxs-lookup"><span data-stu-id="85f3f-156">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="85f3f-157">Generování tokenů</span><span class="sxs-lookup"><span data-stu-id="85f3f-157">Generating the tokens</span></span>

<span data-ttu-id="85f3f-158">Chcete-li generovat tokeny anti-XSRF, zavolejte metodu [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) ze zobrazení MVC nebo @AntiForgery.GetHtml() ze stránky Razor.</span><span class="sxs-lookup"><span data-stu-id="85f3f-158">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="85f3f-159">Runtime pak provede následující kroky:</span><span class="sxs-lookup"><span data-stu-id="85f3f-159">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="85f3f-160">Pokud aktuální požadavek HTTP již obsahuje token relace anti-XSRF (soubor cookie anti-XSRF \_\_RequestVerificationToken), z něj je extrahován token zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="85f3f-160">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="85f3f-161">Pokud požadavek HTTP neobsahuje token relace anti-XSRF nebo pokud se nezdařila extrakce tokenu zabezpečení, vygeneruje se nový náhodný token anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="85f3f-161">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="85f3f-162">Token pole anti-XSRF se vygeneruje pomocí tokenu zabezpečení z kroku (1) výše a identity aktuálně přihlášeného uživatele.</span><span class="sxs-lookup"><span data-stu-id="85f3f-162">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="85f3f-163">(Další informace o určování identity uživatele najdete v části **[scénáře s speciální podporou](#_Scenarios_with_special)** níže.) Kromě toho, pokud je nakonfigurován [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) , modul runtime zavolá svou metodu [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) a zahrne vrácený řetězec do tokenu pole.</span><span class="sxs-lookup"><span data-stu-id="85f3f-163">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="85f3f-164">(Další informace najdete v části **[Konfigurace a rozšiřitelnost](#_Configuration_and_extensibility)** .)</span><span class="sxs-lookup"><span data-stu-id="85f3f-164">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="85f3f-165">Pokud se nový token anti-XSRF vygeneroval v kroku (1), vytvoří se nový token relace, který bude obsahovat a přidá se do kolekce odchozích souborů cookie HTTP.</span><span class="sxs-lookup"><span data-stu-id="85f3f-165">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="85f3f-166">Token pole z kroku (2) bude zabalen do prvku `<input type="hidden" />` a tento kód HTML bude návratovou hodnotou `Html.AntiForgeryToken()` nebo `AntiForgery.GetHtml()`.</span><span class="sxs-lookup"><span data-stu-id="85f3f-166">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="85f3f-167">Ověřování tokenů</span><span class="sxs-lookup"><span data-stu-id="85f3f-167">Validating the tokens</span></span>

<span data-ttu-id="85f3f-168">Aby bylo možné ověřit příchozí tokeny anti-XSRF, vývojář zahrne atribut [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) na svou akci nebo kontroler MVC, nebo volá `@AntiForgery.Validate()` ze své stránky Razor.</span><span class="sxs-lookup"><span data-stu-id="85f3f-168">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="85f3f-169">Modul runtime provede následující kroky:</span><span class="sxs-lookup"><span data-stu-id="85f3f-169">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="85f3f-170">Načte se token příchozí relace a token pole a z každého se Extrahuj token anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="85f3f-170">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="85f3f-171">Tokeny anti-XSRF musí být identické pro každý krok (2) v rutině generování.</span><span class="sxs-lookup"><span data-stu-id="85f3f-171">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="85f3f-172">Pokud je aktuální uživatel ověřený, jeho uživatelské jméno je porovnáno s uživatelským jménem uloženým v tokenu pole.</span><span class="sxs-lookup"><span data-stu-id="85f3f-172">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="85f3f-173">Uživatelská jména se musí shodovat.</span><span class="sxs-lookup"><span data-stu-id="85f3f-173">The usernames must match.</span></span>
3. <span data-ttu-id="85f3f-174">Pokud je nakonfigurován [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) , modul runtime volá svou metodu *ValidateAdditionalData* .</span><span class="sxs-lookup"><span data-stu-id="85f3f-174">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="85f3f-175">Metoda musí vracet logickou hodnotu *true*.</span><span class="sxs-lookup"><span data-stu-id="85f3f-175">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="85f3f-176">V případě úspěšného ověření může požadavek pokračovat.</span><span class="sxs-lookup"><span data-stu-id="85f3f-176">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="85f3f-177">Pokud se ověření nezdaří, rozhraní vyvolá výjimku *HttpAntiForgeryException*.</span><span class="sxs-lookup"><span data-stu-id="85f3f-177">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="85f3f-178">Podmínky selhání</span><span class="sxs-lookup"><span data-stu-id="85f3f-178">Failure conditions</span></span>

<span data-ttu-id="85f3f-179">Počínaje modulem runtime webového zásobníku ASP.NET v2 všechny *HttpAntiForgeryException* , které jsou vyvolány během ověřování, budou obsahovat podrobné informace o tom, co se nepovedlo.</span><span class="sxs-lookup"><span data-stu-id="85f3f-179">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="85f3f-180">Aktuálně definované podmínky selhání jsou:</span><span class="sxs-lookup"><span data-stu-id="85f3f-180">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="85f3f-181">Token relace nebo token formuláře v žádosti chybí.</span><span class="sxs-lookup"><span data-stu-id="85f3f-181">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="85f3f-182">Token relace nebo token formuláře jsou nečitelný.</span><span class="sxs-lookup"><span data-stu-id="85f3f-182">The session token or form token is unreadable.</span></span> <span data-ttu-id="85f3f-183">Nejpravděpodobnější příčinou je, že farma používá neshodné verze ASP.NET webového zásobníku nebo farmy, kde se prvek &lt;machineKey&gt; v souboru Web. config liší mezi počítači.</span><span class="sxs-lookup"><span data-stu-id="85f3f-183">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="85f3f-184">Pomocí nástroje, jako je například Fiddler, můžete tuto výjimku vynutit manipulací s tokenem anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="85f3f-184">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="85f3f-185">Token relace a token pole byly prohozeny.</span><span class="sxs-lookup"><span data-stu-id="85f3f-185">The session token and field token were swapped.</span></span>
- <span data-ttu-id="85f3f-186">Token relace a token pole obsahují neshodné tokeny zabezpečení.</span><span class="sxs-lookup"><span data-stu-id="85f3f-186">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="85f3f-187">Uživatelské jméno vložené v tokenu pole se neshoduje s aktuálním uživatelským jménem přihlášeného uživatele.</span><span class="sxs-lookup"><span data-stu-id="85f3f-187">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="85f3f-188">Metoda *[IAntiForgeryAdditionalDataProvider. ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* vrátila *hodnotu false*.</span><span class="sxs-lookup"><span data-stu-id="85f3f-188">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="85f3f-189">V zařízeních proti sadě anti-XSRF může také probíhat další kontrola během generování nebo ověřování tokenu a selhání během těchto kontrol může způsobit vyvolání výjimek.</span><span class="sxs-lookup"><span data-stu-id="85f3f-189">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="85f3f-190">Další informace najdete v částech [WIF/ACS/ověřování založené na deklaracích](#_WIF_ACS) a možnosti **[Konfigurace a rozšiřitelnost](#_Configuration_and_extensibility)** .</span><span class="sxs-lookup"><span data-stu-id="85f3f-190">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="85f3f-191">Scénáře se zvláštní podporou</span><span class="sxs-lookup"><span data-stu-id="85f3f-191">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="85f3f-192">Anonymní ověření</span><span class="sxs-lookup"><span data-stu-id="85f3f-192">Anonymous authentication</span></span>

<span data-ttu-id="85f3f-193">Systém Anti-XSRF obsahuje speciální podporu pro anonymní uživatele, kde "anonymní" je definováno jako uživatel, kde vlastnost *IIdentity. Authenticated* vrátí *hodnotu false*.</span><span class="sxs-lookup"><span data-stu-id="85f3f-193">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="85f3f-194">Mezi scénáře patří poskytnutí ochrany XSRF na přihlašovací stránku (před ověřením uživatele) a vlastní schémata ověřování, kde aplikace používá jiný mechanismus než *IIdentity* k identifikaci uživatelů.</span><span class="sxs-lookup"><span data-stu-id="85f3f-194">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="85f3f-195">Pro podporu těchto scénářů odvoláte, že tokeny relace a pole jsou spojeny tokenem zabezpečení, což je 128 náhodně generovaný neprůhledný identifikátor.</span><span class="sxs-lookup"><span data-stu-id="85f3f-195">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="85f3f-196">Tento token zabezpečení se používá ke sledování relace jednotlivých uživatelů při navigaci na webu, takže efektivně zachovává účel anonymního identifikátoru.</span><span class="sxs-lookup"><span data-stu-id="85f3f-196">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="85f3f-197">Místo uživatelského jména se používá prázdný řetězec pro rutiny generace a ověřování popsané výše.</span><span class="sxs-lookup"><span data-stu-id="85f3f-197">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="85f3f-198">WIF/ACS/ověřování založené na deklaracích</span><span class="sxs-lookup"><span data-stu-id="85f3f-198">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="85f3f-199">Třídy *IIdentity* integrované do .NET Framework mají obvykle vlastnost, která *IIdentity.Name* postačuje k jednoznačné identifikaci konkrétního uživatele v rámci konkrétní aplikace.</span><span class="sxs-lookup"><span data-stu-id="85f3f-199">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="85f3f-200">*FormsIdentity.Name* například vrátí uživatelské jméno uložené v databázi členství (což je jedinečné pro všechny aplikace v závislosti na dané databázi), *WindowsIdentity.Name* vrátí identitu uživatele kvalifikovanou doménou a tak dále.</span><span class="sxs-lookup"><span data-stu-id="85f3f-200">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="85f3f-201">Tyto systémy neposkytují pouze ověřování. také *identifikují* uživatele k aplikaci.</span><span class="sxs-lookup"><span data-stu-id="85f3f-201">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="85f3f-202">Ověřování založené na deklaracích na druhé straně nemusí nutně vyžadovat určení konkrétního uživatele.</span><span class="sxs-lookup"><span data-stu-id="85f3f-202">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="85f3f-203">Místo toho jsou typy *ClaimsPrincipal* a *hodnota ClaimsIdentity* přidružené k sadě instancí *deklarací* , kde jednotlivé deklarace identity můžou být 18 + roky stáří nebo je správce, aby cokoli jiného.</span><span class="sxs-lookup"><span data-stu-id="85f3f-203">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="85f3f-204">Vzhledem k tomu, že uživatel není nezbytně identifikovaný, modul runtime nemůže pro tohoto konkrétního uživatele použít vlastnost *ClaimsIdentity.Name* jako jedinečný identifikátor.</span><span class="sxs-lookup"><span data-stu-id="85f3f-204">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="85f3f-205">Tým viděli reálné příklady, kde *ClaimsIdentity.Name* vrací *hodnotu null*, vrátí popisný název (zobrazení) nebo jinak vrátí řetězec, který není vhodný pro použití jako jedinečný identifikátor pro uživatele.</span><span class="sxs-lookup"><span data-stu-id="85f3f-205">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="85f3f-206">Mnohé z nasazení, které používají ověřování založené na deklaracích, používá službu [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS), zejména.</span><span class="sxs-lookup"><span data-stu-id="85f3f-206">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="85f3f-207">Služba ACS umožňuje vývojářům nakonfigurovat jednotlivé *zprostředkovatele identity* (například ADFS, poskytovatele účtu Microsoft, poskytovatele OpenID, jako je Yahoo! atd.), a poskytovatele identity vrátí *identifikátory názvů*.</span><span class="sxs-lookup"><span data-stu-id="85f3f-207">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="85f3f-208">Tyto identifikátory názvů můžou obsahovat osobní údaje (PII), jako je e-mailová adresa, nebo by se daly jednat o anonymní osobní identifikátor (PPID).</span><span class="sxs-lookup"><span data-stu-id="85f3f-208">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="85f3f-209">Řazená kolekce členů (poskytovatel identity, identifikátor názvu) dostatečně slouží jako vhodný sledovací token pro konkrétního uživatele při procházení lokality, takže modul runtime webového zásobníku ASP.NET může použít řazenou kolekci členů místo uživatelského jména při generování a ověřují se tokeny pole anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="85f3f-209">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="85f3f-210">Konkrétní identifikátory URI pro poskytovatele identity a identifikátor názvu jsou:</span><span class="sxs-lookup"><span data-stu-id="85f3f-210">The particular URIs for the identity provider and the name identifier are :</span></span>

- `https://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="85f3f-211">(Další informace najdete na této [stránce s dokumentem ACS](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) .)</span><span class="sxs-lookup"><span data-stu-id="85f3f-211">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="85f3f-212">Při generování nebo ověřování tokenu bude modul runtime ASP.NET webového zásobníku za běhu vyzkoušet vazbu na tyto typy:</span><span class="sxs-lookup"><span data-stu-id="85f3f-212">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="85f3f-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (pro sadu SDK pro WIF)</span><span class="sxs-lookup"><span data-stu-id="85f3f-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="85f3f-214">`System.Security.Claims.ClaimsIdentity` (pro .NET 4,5).</span><span class="sxs-lookup"><span data-stu-id="85f3f-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="85f3f-215">Pokud existují tyto typy, a pokud *IIIIdentity* aktuálního uživatele implementuje nebo podtřídí jeden z těchto typů, bude zařízení anti-XSRF při generování a ověřování tokenů používat řazenou kolekci členů (poskytovatel identity, identifikátor názvu) místo uživatelského jména.</span><span class="sxs-lookup"><span data-stu-id="85f3f-215">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="85f3f-216">Pokud žádná taková řazená kolekce členů není k dispozici, požadavek selže s chybou, která popisuje vývojáře postup konfigurace systému anti-XSRF pro pochopení konkrétního mechanismu ověřování založeného na deklaracích, který se používá.</span><span class="sxs-lookup"><span data-stu-id="85f3f-216">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="85f3f-217">Další informace najdete v části **[Konfigurace a rozšiřitelnost](#_Configuration_and_extensibility)** .</span><span class="sxs-lookup"><span data-stu-id="85f3f-217">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="85f3f-218">Ověřování OAuth/OpenID</span><span class="sxs-lookup"><span data-stu-id="85f3f-218">OAuth / OpenID authentication</span></span>

<span data-ttu-id="85f3f-219">V konečném případě má zařízení anti-XSRF zvláštní podporu pro aplikace, které používají ověřování OAuth nebo OpenID.</span><span class="sxs-lookup"><span data-stu-id="85f3f-219">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="85f3f-220">Tato podpora je založená na heuristikě: Pokud aktuální *IIdentity.Name* začíná na http://nebo https://, pak se porovnávání uživatelského jména provede pomocí ordinálního porovnávání namísto výchozí porovnávací metody OrdinalIgnoreCase.</span><span class="sxs-lookup"><span data-stu-id="85f3f-220">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="85f3f-221">Konfigurace a rozšiřitelnost</span><span class="sxs-lookup"><span data-stu-id="85f3f-221">Configuration and extensibility</span></span>

<span data-ttu-id="85f3f-222">V některých případech mohou vývojáři chtít mít užší kontrolu nad chováním generování a ověřování proti více XSRF.</span><span class="sxs-lookup"><span data-stu-id="85f3f-222">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="85f3f-223">Může se třeba stát, že MVC a webové stránky budou automaticky přidávat soubory cookie HTTP do odpovědi nežádoucí a vývojáři si můžou chtít tyto tokeny uchovat jinde.</span><span class="sxs-lookup"><span data-stu-id="85f3f-223">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="85f3f-224">Existují dvě rozhraní API pro pomoc s tímto:</span><span class="sxs-lookup"><span data-stu-id="85f3f-224">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="85f3f-225">Metoda *Gettokens* přijímá jako vstup existující token relace ověření žádosti XSRF (který může být null) a vytváří jako výstup nový token relace ověření žádosti XSRF a token pole.</span><span class="sxs-lookup"><span data-stu-id="85f3f-225">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="85f3f-226">Tokeny jsou jednoduše neprůhledné řetězce bez dekorace; hodnota *formToken* bude pro instanci nezabalená do &lt;vstupní&gt; značce.</span><span class="sxs-lookup"><span data-stu-id="85f3f-226">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="85f3f-227">Hodnota *newCookieToken* může být null. Pokud k tomu dojde, hodnota *oldCookieToken* je stále platná a není nutné nastavit žádné nové soubory cookie odpovědi.</span><span class="sxs-lookup"><span data-stu-id="85f3f-227">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="85f3f-228">Volající *Gettokens* zodpovídá za uchování všech potřebných souborů cookie odpovědí nebo pro vytváření potřebných značek. Samotná metoda *Gettokens* nemění odpověď v podobě vedlejšího efektu.</span><span class="sxs-lookup"><span data-stu-id="85f3f-228">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="85f3f-229">Metoda *Validate* vezme příchozí tokeny relace a pole a spustí výše uvedenou logiku ověřování.</span><span class="sxs-lookup"><span data-stu-id="85f3f-229">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="85f3f-230">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="85f3f-230">AntiForgeryConfig</span></span>

<span data-ttu-id="85f3f-231">Vývojář může nakonfigurovat systém Anti-XSRF z aplikace\_Start.</span><span class="sxs-lookup"><span data-stu-id="85f3f-231">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="85f3f-232">Konfigurace je programová.</span><span class="sxs-lookup"><span data-stu-id="85f3f-232">Configuration is programmatic.</span></span> <span data-ttu-id="85f3f-233">Vlastnosti statického typu *AntiForgeryConfig* jsou popsány níže.</span><span class="sxs-lookup"><span data-stu-id="85f3f-233">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="85f3f-234">Většina uživatelů, kteří používají deklarace identity, bude chtít nastavit vlastnost UniqueClaimTypeIdentifier.</span><span class="sxs-lookup"><span data-stu-id="85f3f-234">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="85f3f-235">**Vlastnost**</span><span class="sxs-lookup"><span data-stu-id="85f3f-235">**Property**</span></span> | <span data-ttu-id="85f3f-236">**Popis**</span><span class="sxs-lookup"><span data-stu-id="85f3f-236">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="85f3f-237">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="85f3f-237">**AdditionalDataProvider**</span></span> | <span data-ttu-id="85f3f-238">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) , který poskytuje další data během generování tokenu a spotřebovává další data během ověřování tokenu.</span><span class="sxs-lookup"><span data-stu-id="85f3f-238">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="85f3f-239">Výchozí hodnota je *null*.</span><span class="sxs-lookup"><span data-stu-id="85f3f-239">The default value is *null*.</span></span> <span data-ttu-id="85f3f-240">Další informace najdete v části [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) .</span><span class="sxs-lookup"><span data-stu-id="85f3f-240">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="85f3f-241">**Vlastnost CookieName**</span><span class="sxs-lookup"><span data-stu-id="85f3f-241">**CookieName**</span></span> | <span data-ttu-id="85f3f-242">Řetězec, který poskytuje název souboru cookie protokolu HTTP, který se používá k uložení tokenu relace anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="85f3f-242">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="85f3f-243">Pokud tato hodnota není nastavená, automaticky se vygeneruje název založený na nasazené virtuální cestě aplikace.</span><span class="sxs-lookup"><span data-stu-id="85f3f-243">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="85f3f-244">Výchozí hodnota je *null*.</span><span class="sxs-lookup"><span data-stu-id="85f3f-244">The default value is *null*.</span></span> |
| <span data-ttu-id="85f3f-245">**Vlastnost requireSSL**</span><span class="sxs-lookup"><span data-stu-id="85f3f-245">**RequireSsl**</span></span> | <span data-ttu-id="85f3f-246">Logická hodnota, která určuje, zda jsou tokeny anti-XSRF požadovány k odeslání přes kanál zabezpečený protokolem SSL.</span><span class="sxs-lookup"><span data-stu-id="85f3f-246">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="85f3f-247">Pokud je tato hodnota *true*, všechny automaticky generované soubory cookie budou mít nastaven příznak "Secure" a rozhraní API pro anti-XSRF, pokud se volá z požadavku, který není odeslán přes protokol SSL.</span><span class="sxs-lookup"><span data-stu-id="85f3f-247">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="85f3f-248">Výchozí hodnota je *false (NEPRAVDA*).</span><span class="sxs-lookup"><span data-stu-id="85f3f-248">The default value is *false*.</span></span> |
| <span data-ttu-id="85f3f-249">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="85f3f-249">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="85f3f-250">Logická hodnota, která určuje, zda má systém Anti-XSRF deaktivovat podporu identit založených na deklaracích identity.</span><span class="sxs-lookup"><span data-stu-id="85f3f-250">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="85f3f-251">Pokud je tato hodnota *true*, systém bude předpokládat, že *IIdentity.Name* je vhodný pro použití jako jedinečný identifikátor podle uživatele a nepokusí se použít speciální *IClaimsIdentity* nebo *ClClaimsIdentity* , jak je popsáno v části [ověřování založené na WIF/ACS/deklaracích](#_WIF_ACS) .</span><span class="sxs-lookup"><span data-stu-id="85f3f-251">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="85f3f-252">Výchozí hodnota je `false`.</span><span class="sxs-lookup"><span data-stu-id="85f3f-252">The default value is `false`.</span></span> |
| <span data-ttu-id="85f3f-253">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="85f3f-253">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="85f3f-254">Řetězec, který označuje typ deklarace identity, který je vhodný pro použití jako jedinečný identifikátor podle uživatele.</span><span class="sxs-lookup"><span data-stu-id="85f3f-254">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="85f3f-255">Pokud je tato hodnota nastavena a aktuální *IIdentity* je založen na deklaracích, systém se pokusí extrahovat deklaraci identity typu určenou parametrem *UniqueClaimTypeIdentifier*a odpovídající hodnota bude použita místo uživatelského jména uživatele při generování tokenu pole.</span><span class="sxs-lookup"><span data-stu-id="85f3f-255">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="85f3f-256">Pokud se typ deklarace identity nenalezne, požadavek na systém se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="85f3f-256">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="85f3f-257">Výchozí hodnota je *null*, což znamená, že systém by měl použít řazenou kolekci členů (poskytovatel identity, identifikátor názvu), jak je popsáno výše v části místo uživatelského jména uživatele.</span><span class="sxs-lookup"><span data-stu-id="85f3f-257">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="85f3f-258">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="85f3f-258">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="85f3f-259">Typ *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* umožňuje vývojářům roztáhnout chování systému anti-XSRF tím, že v každém tokenu Trip další data.</span><span class="sxs-lookup"><span data-stu-id="85f3f-259">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="85f3f-260">Metoda *GetAdditionalData* je volána při každém vygenerování tokenu pole a návratová hodnota je vložena do vygenerovaného tokenu.</span><span class="sxs-lookup"><span data-stu-id="85f3f-260">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="85f3f-261">Implementátor může vracet časové razítko, hodnotu NONCE nebo jakoukoli jinou hodnotu, kterou si z této metody přeje.</span><span class="sxs-lookup"><span data-stu-id="85f3f-261">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="85f3f-262">Podobně metoda *ValidateAdditionalData* je volána při každém ověření tokenu pole a řetězec "další data", který byl vložen v rámci tokenu, je předán metodě.</span><span class="sxs-lookup"><span data-stu-id="85f3f-262">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="85f3f-263">Rutina ověřování by mohla implementovat časový limit (kontrolou aktuálního času v čase, který byl uložen při vytvoření tokenu), rutiny kontroly hodnoty nonce nebo libovolné jiné požadované logiky.</span><span class="sxs-lookup"><span data-stu-id="85f3f-263">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="85f3f-264">Rozhodnutí o návrhu a aspekty zabezpečení</span><span class="sxs-lookup"><span data-stu-id="85f3f-264">Design decisions and security considerations</span></span>

<span data-ttu-id="85f3f-265">Token zabezpečení, který odkazuje na tokeny relace a pole, je technicky nutný jenom při pokusu o ochranu anonymních nebo neověřených uživatelů proti útokům na XSRF.</span><span class="sxs-lookup"><span data-stu-id="85f3f-265">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="85f3f-266">Při ověření uživatele se dá samotný ověřovací token (předpokládaný ve formě souboru cookie) použít jako jednu polovinu páru tokenů synchronizátoru.</span><span class="sxs-lookup"><span data-stu-id="85f3f-266">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="85f3f-267">Existují však platné scénáře ochrany přihlašovacích stránek, ke kterým přirazí neověření uživatelé, a logika anti-XSRF byla jednodušší, protože vždy generuje a ověřuje token zabezpečení, a to i pro ověřené uživatele.</span><span class="sxs-lookup"><span data-stu-id="85f3f-267">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="85f3f-268">Také poskytuje dodatečnou ochranu v případě, že útočník může v případě ohrožení zabezpečení v případě, že je nastavení nebo odhad tokenu relace jinou prahovou hodnotu, aby mohl útočník překonat.</span><span class="sxs-lookup"><span data-stu-id="85f3f-268">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="85f3f-269">Vývojáři by měli při hostování více aplikací v jedné doméně používat upozornění.</span><span class="sxs-lookup"><span data-stu-id="85f3f-269">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="85f3f-270">Například i když jsou *example1.cloudapp.NET* a *example2.cloudapp.NET* různými hostiteli, existuje implicitní vztah důvěryhodnosti mezi všemi hostiteli v doméně *\*. cloudapp.NET* .</span><span class="sxs-lookup"><span data-stu-id="85f3f-270">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="85f3f-271">Tento implicitní vztah důvěryhodnosti [umožňuje potenciálním nedůvěryhodným hostitelům ovlivnit soubory cookie ostatních souborů](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (zásady stejného původu, které řídí požadavky AJAX, nemusí nutně platit pro soubory cookie http).</span><span class="sxs-lookup"><span data-stu-id="85f3f-271">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="85f3f-272">Modul runtime webového zásobníku ASP.NET je v tom, že uživatelské jméno je vložené do tokenu pole, takže i v případě, že škodlivá subdoména může přepsat token relace, nebude pro uživatele možné vygenerovat platný token pole.</span><span class="sxs-lookup"><span data-stu-id="85f3f-272">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="85f3f-273">Pokud se ale v takovém prostředí hostuje, předdefinovaná rutina anti-XSRF se pořád nemůže chránit proti zneužití relace nebo k přihlášení XSRF.</span><span class="sxs-lookup"><span data-stu-id="85f3f-273">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="85f3f-274">Rutiny anti-XSRF momentálně nebrání proti [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="85f3f-274">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="85f3f-275">Aplikace, které se chtějí chránit proti clickjacking, můžou snadno učinit tak, že se každou odpověď pošle hlavičkou možností X-frame: SAMEORIGIN.</span><span class="sxs-lookup"><span data-stu-id="85f3f-275">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="85f3f-276">Tato hlavička je podporovaná všemi nedávnými prohlížeči.</span><span class="sxs-lookup"><span data-stu-id="85f3f-276">This header is supported by all recent browsers.</span></span> <span data-ttu-id="85f3f-277">Další informace najdete na blogu k [internetovým](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx)odkazům, na [blogu SDL](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)a v [OWASP](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="85f3f-277">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="85f3f-278">Modul runtime webového zásobníku ASP.NET může v některých budoucích vydáních vytvořit tuto hlavičku automaticky pomocníkům pro usnadnění a webové stránky, aby se aplikace automaticky chránily proti tomuto útoku.</span><span class="sxs-lookup"><span data-stu-id="85f3f-278">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="85f3f-279">Vývojáři webu by měli pokračovat v zajištění, že jejich lokalita není zranitelná vůči útokům XSS.</span><span class="sxs-lookup"><span data-stu-id="85f3f-279">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="85f3f-280">Útoky XSS jsou velmi výkonné a při úspěšném zneužití by došlo také k přerušení ochrany modulu runtime webového zásobníku ASP.NET proti útokům XSRF.</span><span class="sxs-lookup"><span data-stu-id="85f3f-280">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="85f3f-281">Potvrzení</span><span class="sxs-lookup"><span data-stu-id="85f3f-281">Acknowledgment</span></span>

<span data-ttu-id="85f3f-282">[@LeviBroderick](https://twitter.com/LeviBroderick), který napsal mnoho z bezpečnostních kódů ASP.NET, tyto informace jsou hromadné.</span><span class="sxs-lookup"><span data-stu-id="85f3f-282">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
