---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: Porozumění a zpracování událostí životního cyklu připojení v nástroji Signaler | Microsoft Docs
author: bradygaster
description: Tento článek popisuje, jak používat události vystavené rozhraním API centra.
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/06/2020
ms.locfileid: "78578811"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="0dd5a-103">Principy a zpracování událostí doby platnosti v knihovně SignalR</span><span class="sxs-lookup"><span data-stu-id="0dd5a-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="0dd5a-104">Tento článek poskytuje přehled o připojení signálů, opětovném připojení a událostech odpojení, které můžete zpracovávat, a nastavení časových limitů a udržení, které můžete konfigurovat.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="0dd5a-105">V článku se předpokládá, že už máte nějaké znalosti událostí pro signalizaci a životnost připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="0dd5a-106">Úvod do signalizace najdete v tématu [Úvod do nástroje Signal](../getting-started/introduction-to-signalr.md).</span><span class="sxs-lookup"><span data-stu-id="0dd5a-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="0dd5a-107">Seznam událostí životního cyklu připojení najdete v následujících zdrojích informací:</span><span class="sxs-lookup"><span data-stu-id="0dd5a-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="0dd5a-108">Postup zpracování událostí životního cyklu připojení ve třídě centra</span><span class="sxs-lookup"><span data-stu-id="0dd5a-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="0dd5a-109">Postup zpracování událostí životního cyklu připojení v klientech JavaScript</span><span class="sxs-lookup"><span data-stu-id="0dd5a-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="0dd5a-110">Postup zpracování událostí životního cyklu připojení v klientech rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="0dd5a-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="0dd5a-111">Verze softwaru používané v tomto tématu</span><span class="sxs-lookup"><span data-stu-id="0dd5a-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="0dd5a-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="0dd5a-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="0dd5a-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="0dd5a-113">.NET 4.5</span></span>
> - <span data-ttu-id="0dd5a-114">Signal – verze 2</span><span class="sxs-lookup"><span data-stu-id="0dd5a-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="0dd5a-115">Předchozí verze tohoto tématu</span><span class="sxs-lookup"><span data-stu-id="0dd5a-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="0dd5a-116">Informace o dřívějších verzích nástroje Signal najdete v části [Signal – starší verze](../older-versions/index.md).</span><span class="sxs-lookup"><span data-stu-id="0dd5a-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="0dd5a-117">Dotazy a komentáře</span><span class="sxs-lookup"><span data-stu-id="0dd5a-117">Questions and comments</span></span>
>
> <span data-ttu-id="0dd5a-118">Přečtěte si prosím svůj názor na to, jak se vám tento kurz líbí a co bychom mohli vylepšit v komentářích v dolní části stránky.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="0dd5a-119">Pokud máte dotazy, které přímo nesouvisejí s kurzem, můžete je publikovat do [fóra signálu ASP.NET](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) nebo [StackOverflow.com](http://stackoverflow.com/).</span><span class="sxs-lookup"><span data-stu-id="0dd5a-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="0dd5a-120">Přehled</span><span class="sxs-lookup"><span data-stu-id="0dd5a-120">Overview</span></span>

<span data-ttu-id="0dd5a-121">Tento článek obsahuje následující oddíly:</span><span class="sxs-lookup"><span data-stu-id="0dd5a-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="0dd5a-122">Terminologie a scénáře platnosti připojení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="0dd5a-123">Připojení k signalizaci, přenosová připojení a fyzická připojení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="0dd5a-124">Scénáře odpojení přenosu</span><span class="sxs-lookup"><span data-stu-id="0dd5a-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="0dd5a-125">Scénáře odpojení klienta</span><span class="sxs-lookup"><span data-stu-id="0dd5a-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="0dd5a-126">Scénáře odpojení serveru</span><span class="sxs-lookup"><span data-stu-id="0dd5a-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="0dd5a-127">Nastavení časového limitu a kontroly naživu</span><span class="sxs-lookup"><span data-stu-id="0dd5a-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="0dd5a-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="0dd5a-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="0dd5a-129">Hodnota DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="0dd5a-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="0dd5a-130">Udržení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="0dd5a-131">Postup změny nastavení časových limitů a kontroly udržení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="0dd5a-132">Upozornění uživatele na odpojení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="0dd5a-133">Postup nepřetržitého opětovného připojení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="0dd5a-134">Odpojení klienta v serverovém kódu</span><span class="sxs-lookup"><span data-stu-id="0dd5a-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="0dd5a-135">Zjištění důvodu odpojení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="0dd5a-136">Odkazy na referenční témata rozhraní API odkazují na verzi rozhraní API .NET 4,5.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="0dd5a-137">Pokud používáte .NET 4, přečtěte si téma věnované [verzi rozhraní API rozhraní .NET 4](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="0dd5a-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="0dd5a-138">Terminologie a scénáře platnosti připojení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="0dd5a-139">Obslužná rutina události `OnReconnected` v centru signalizace se dá provést přímo po `OnConnected`, ale ne po `OnDisconnected` pro daného klienta.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="0dd5a-140">Důvodem, proč můžete mít opětovné připojení bez odpojení je, že existuje několik způsobů, jak se v nástroji Signal používá slovo "připojení".</span><span class="sxs-lookup"><span data-stu-id="0dd5a-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="0dd5a-141">Připojení k signalizaci, přenosová připojení a fyzická připojení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="0dd5a-142">Tento článek se rozlišuje mezi *připojeními k signalizaci*, *přenosovým připojením*a *fyzickými připojeními*:</span><span class="sxs-lookup"><span data-stu-id="0dd5a-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="0dd5a-143">**Připojení k signalizaci** odkazuje na logický vztah mezi klientem a adresou URL serveru, který je udržován rozhraním API pro signalizaci a jednoznačně identifikovaný identifikátorem připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="0dd5a-144">Data o tomto vztahu jsou spravována pomocí nástroje Signal a slouží k navázání transportního připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="0dd5a-145">Ukončení relace a signalizace vyřadí data, když klient volá metodu `Stop` nebo se dosáhne časového limitu, když se signál pokusí znovu vytvořit ztracené připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="0dd5a-146">**Přenosové připojení** odkazuje na logický vztah mezi klientem a serverem, který se uchovává v jednom ze čtyř přenosových rozhraní API: WebSockets, server-odesílají události, snímek navždy nebo dlouhé cyklické dotazování.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="0dd5a-147">Signál používá transportní rozhraní API k vytvoření transportního připojení a transportní rozhraní API závisí na existenci fyzického síťového připojení pro vytvoření přenosového připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="0dd5a-148">Přenosové připojení končí, když ho signál ukončí nebo když transportní rozhraní API zjistí, že fyzické připojení je přerušené.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="0dd5a-149">**Fyzické připojení** odkazuje na fyzické síťové odkazy – dráty, bezdrátové signály, směrovače atd., které usnadňují komunikaci mezi klientským počítačem a serverovým počítačem.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="0dd5a-150">Aby bylo možné navázat spojení s připojením, musí být fyzické připojení přítomné a musí se navázat přenosové připojení, aby bylo možné navázat připojení k signalizaci.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="0dd5a-151">Přerušení fyzického připojení ale vždy okamžitě ukončí přenosové připojení nebo připojení k signalizaci, jak bude vysvětleno dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="0dd5a-152">V následujícím diagramu je připojení k signalizaci reprezentované rozhraním API centra a vrstvou PersistentConnection API Signal, přenosové připojení je reprezentované vrstvou přenosů a fyzické připojení je reprezentované řádky mezi serverem. a klienti.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![Diagram architektury Signal](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="0dd5a-154">Při volání metody `Start` v klientovi signalizace poskytujete klientský kód pro signalizaci s veškerými informacemi, které potřebuje, aby bylo možné navázat fyzické připojení k serveru.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="0dd5a-155">Kód klienta signalizace používá tyto informace k vytvoření požadavku HTTP a navázání fyzického připojení, které používá jednu ze čtyř metod přenosu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="0dd5a-156">Pokud není přenosové připojení úspěšné nebo dojde k chybě serveru, připojení k signalizaci se okamžitě neprojeví, protože klient má stále informace, které potřebuje k automatickému opětovnému vytvoření nového transportního připojení ke stejné adrese URL signálu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="0dd5a-157">V tomto scénáři není k dispozici žádný zásah z uživatelské aplikace, a pokud klientský kód Signale vytvoří nové přenosové připojení, nespustí nové připojení k signalizaci.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="0dd5a-158">Kontinuita připojení k signalizaci se odrazí ve skutečnosti, že ID připojení, které je vytvořeno při volání metody `Start`, se nezmění.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="0dd5a-159">Obslužná rutina události `OnReconnected` v centru se spustí, když se po ztrátě automaticky znovu naváže připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="0dd5a-160">Obslužná rutina události `OnDisconnected` se spouští na konci připojení k signalizaci.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="0dd5a-161">Připojení k signalizaci může končit některým z následujících způsobů:</span><span class="sxs-lookup"><span data-stu-id="0dd5a-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="0dd5a-162">Pokud klient volá metodu `Stop`, pošle se na server zpráva o zastavení a klient i server ukončí připojení k signalizaci okamžitě.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="0dd5a-163">Po ztrátě připojení mezi klientem a serverem se klient pokusí znovu připojit a Server počká, až se klient znovu připojí.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="0dd5a-164">Pokud se pokusy o opětovné připojení nezdařily a časové období odpojení skončí, klient i server ukončí připojení k signalizaci.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="0dd5a-165">Klient se ukončí pokus o opětovné připojení a server uvolní jeho reprezentaci připojení k signalizaci.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="0dd5a-166">Pokud klient přestane běžet, aniž by bylo pravděpodobné, že by volal metodu `Stop`, Server počká, až se znovu připojí, a pak ukončí připojení k signalizaci po uplynutí časového limitu odpojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="0dd5a-167">Pokud je server zastavený, klient se pokusí znovu připojit (znovu vytvořit připojení přenosu) a po uplynutí časového limitu odpojení ukončí připojení k signalizaci.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="0dd5a-168">Pokud nedochází k žádným problémům s připojením a uživatelská aplikace ukončí připojení k signalizaci voláním metody `Stop`, připojení k signalizaci a přenosové připojení začíná a končí ve stejnou dobu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="0dd5a-169">V následujících částech jsou podrobněji popsány další informace o dalších scénářích.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="0dd5a-170">Scénáře odpojení přenosu</span><span class="sxs-lookup"><span data-stu-id="0dd5a-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="0dd5a-171">Fyzické připojení může být pomalé nebo mohlo dojít k přerušení připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="0dd5a-172">V závislosti na faktorech, jako je délka přerušení, může být přenosové připojení vyřazeno.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="0dd5a-173">Signalizace se pak pokusí znovu vytvořit připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="0dd5a-174">V některých případech rozhraní API pro přenos připojení zjistí přerušení a uvolní přenos připojení a signál se okamžitě vyhledá, že připojení bylo ztraceno.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="0dd5a-175">V jiných scénářích není rozhraní API pro přenos spojení ani signál, že by bylo připojení ztraceno.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="0dd5a-176">U všech přenosů s výjimkou dlouhého cyklického dotazování používá klient signalizace funkci s názvem *naživu* , aby zkontrolovala ztrátu připojení, kterou transportní rozhraní API nemůže detekovat.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="0dd5a-177">Informace o dlouhých připojeních pro cyklické dotazování najdete v části [nastavení časového limitu a možnosti](#timeoutkeepalive) kontroly pro připojení dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="0dd5a-178">Když je připojení neaktivní, server pravidelně odešle klientovi paket kontroly stavu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="0dd5a-179">Od data, kdy je tento článek napsán, je výchozí frekvence každých 10 sekund.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="0dd5a-180">Díky naslouchání těmto paketům můžou klienti zjistit, jestli došlo k potížím s připojením.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="0dd5a-181">Pokud v případě, že se po krátké době neobdrží paket kontroly a času, klient předpokládá, že dochází k problémům s připojením, jako je například zpomalení nebo přerušení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="0dd5a-182">Pokud se udržení naživu ještě nepřijme po delší době, klient předpokládá, že připojení bylo vyřazené, a začne se pokoušet o opětovné připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="0dd5a-183">Následující diagram znázorňuje události klienta a serveru, které jsou vyvolány v typickém scénáři, pokud dochází k problémům s fyzickým připojením, které nejsou okamžitě rozpoznány transportním rozhraním API.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="0dd5a-184">Diagram se vztahuje na následující okolnosti:</span><span class="sxs-lookup"><span data-stu-id="0dd5a-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="0dd5a-185">Přenos je WebSockets, navždy Frame nebo události odesílané serverem.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="0dd5a-186">Ve fyzickém síťovém připojení dochází k různým dobám přerušení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="0dd5a-187">Rozhraní API pro přenos se nedozvědělo o přerušení, takže signalizace spoléhá na funkce naživu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Odpojení přenosu](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="0dd5a-189">Pokud klient přejde do režimu opětovného připojení, ale nemůže vytvořit přenosové připojení v rámci časového limitu odpojení, server ukončí připojení k signalizaci.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="0dd5a-190">Pokud k tomu dojde, Server provede `OnDisconnected` metodu centra a zařadí do fronty zprávu o odpojení, která se odešle klientovi v případě, že se klient připojí k pozdějšímu připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="0dd5a-191">Pokud se klient pak znovu připojí, obdrží příkaz pro odpojení a zavolá metodu `Stop`.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="0dd5a-192">V tomto scénáři se `OnReconnected` nespustí, když se klient znovu připojí a `OnDisconnected` se nespustí, když klient volá `Stop`.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="0dd5a-193">Tento scénář je znázorněn na následujícím obrázku.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-193">The following diagram illustrates this scenario.</span></span>

![Přerušení přenosu – časový limit serveru](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="0dd5a-195">Události doby života připojení signálů, které mohou být vyvolány na straně klienta, jsou následující:</span><span class="sxs-lookup"><span data-stu-id="0dd5a-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="0dd5a-196">`ConnectionSlow` událost klienta.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="0dd5a-197">Vyvolá se v případě, že před přijetím poslední zprávy nebo potvrzením platnosti byl přijat přednastavený podíl časového limitu kontroly udržení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="0dd5a-198">Výchozí časový limit pro dobu kontroly stavu (udržení) je 2/3 časového limitu udržení naživu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="0dd5a-199">Časový limit kontroly udržení je 20 sekund, takže se zobrazí upozornění přibližně o 13 sekundách.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="0dd5a-200">Ve výchozím nastavení server odesílá příkazy pro ověření stavu kontrolního seznamu každých 10 sekund a klient zkontroluje, jestli se na každých 2 sekundách (jedna třetina rozdílu mezi hodnotou časového limitu kontroly stavu kontroly a hodnotou časového limitu kontroly stavu) kontroluje.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="0dd5a-201">Pokud se transportní rozhraní API dozvědělo o odpojení, může být signál upozorněn na odpojení před úspěšným časovým limitem časového limitu kontroly udržení platnosti.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="0dd5a-202">V takovém případě by se událost `ConnectionSlow` nevyvolala a signál by přešel přímo k události `Reconnecting`.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="0dd5a-203">`Reconnecting` událost klienta.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="0dd5a-204">Vyvolá se, když (a) Transportní rozhraní API zjistí ztrátu připojení, nebo (b) vypršel časový limit kontroly udržení dat, který uplynul od poslední zprávy, nebo byl přijat příkaz pro ověření naživu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="0dd5a-205">Kód klienta signalizace se začne pokoušet znovu připojit.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="0dd5a-206">Tuto událost můžete zpracovat, pokud chcete, aby aplikace probrala určitou akci, když dojde ke ztrátě připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="0dd5a-207">Výchozí časový limit pro udržení naživu je v současné době 20 sekund.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="0dd5a-208">Pokud se Váš klientský kód pokusí zavolat metodu rozbočovače, zatímco je signál v režimu opětovného připojení, signál se pokusí odeslat příkaz.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="0dd5a-209">Ve většině případů tyto pokusy selžou, ale v některých případech se může stát, že budou úspěšné.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="0dd5a-210">Pro události odeslané serverem, navždy a dlouhé cyklické dotazování používá Signal dva komunikační kanály, které klient používá k posílání zpráv a k tomu, které používá k přijímání zpráv.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="0dd5a-211">Kanál použitý k přijetí je trvale otevřený a je ten, který je uzavřený při přerušení fyzického připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="0dd5a-212">Kanál použitý k odeslání zůstává dostupný, takže pokud se obnoví fyzické připojení, může být volání metody z klienta na server úspěšné, než se znovu naváže kanál pro příjem.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="0dd5a-213">Návratová hodnota nebude přijata, dokud signál znovu neotevře kanál použitý k přijetí.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="0dd5a-214">`Reconnected` událost klienta.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="0dd5a-215">Vyvolá se v případě, že je přenosové připojení znovu navázáno.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="0dd5a-216">V centru se spustí obslužná rutina události `OnReconnected`.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="0dd5a-217">`Closed` událost klienta (událost`disconnected` v JavaScriptu).</span><span class="sxs-lookup"><span data-stu-id="0dd5a-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="0dd5a-218">Je aktivována, když časový limit pro odpojení vyprší, když se kód klienta nástroje Signal pokusí znovu připojit po ztrátě připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="0dd5a-219">Výchozí časový limit pro odpojení je 30 sekund.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="0dd5a-220">(Tato událost je vyvolána také v případě, že je připojení ukončeno, protože je volána metoda `Stop`.)</span><span class="sxs-lookup"><span data-stu-id="0dd5a-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="0dd5a-221">Přerušení připojení přenosu, která nejsou zjištěna transportním rozhraním API, a nedělejte prodlevu přijímání příkazů pro ověření platnosti paketů kontroly a času na serveru déle, než je časový limit pro dobu nečinnosti, nemusí způsobit vyvolání všech událostí životního cyklu připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="0dd5a-222">Některá síťová prostředí úmyslně zavřou nečinná připojení a další funkce paketů kontroly stavu, které jim umožňují zabránit tomu, aby tyto sítě věděly, že se připojení k signalizaci používá.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="0dd5a-223">V extrémních případech nemusí být výchozí frekvence příkazů pro ověření stavu připojení k síti k dispozici, aby se zabránilo uzavřeným připojením.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="0dd5a-224">V takovém případě můžete nakonfigurovat, aby bylo možné odesílat příkazy pro ověřování paketů kontroly a častější odesílání.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="0dd5a-225">Další informace najdete v části [nastavení časového limitu a možnosti](#timeoutkeepalive) kontroly pro otevření v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="0dd5a-226">**Důležité**: posloupnost událostí popsaných tady není zaručená.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="0dd5a-227">Signalní je pokaždé, když se každý pokus o vyzvednutí událostí životního cyklu připojení předvídatelným způsobem podle tohoto schématu, ale existuje mnoho variant síťových událostí a mnoha způsobů, kterými se podřídí komunikační architektury, jako jsou třeba transportní rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="0dd5a-228">Například událost `Reconnected` nemusí být vyvolána, když se klient znovu připojí, nebo se může spustit obslužná rutina `OnConnected` na serveru, když se pokus o navázání spojení nezdařil.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="0dd5a-229">V tomto tématu jsou popsány pouze efekty, které by obvykle byly vyprodukovány pomocí určitých typických okolností.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="0dd5a-230">Scénáře odpojení klienta</span><span class="sxs-lookup"><span data-stu-id="0dd5a-230">Client disconnection scenarios</span></span>

<span data-ttu-id="0dd5a-231">V klientském prohlížeči je kód klienta signalizace, který udržuje připojení k signalizaci, spuštěn v kontextu JavaScriptu webové stránky.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="0dd5a-232">To je důvod, proč musí připojení k signalizaci končit při přechodu z jedné stránky na jiný a to je důvod, proč máte k dispozici více připojení s více identifikátory připojení, pokud se připojujete z více oken prohlížeče nebo karet.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="0dd5a-233">Když uživatel zavře okno nebo kartu prohlížeče nebo přejde na novou stránku nebo aktualizuje stránku, okamžitě se ukončí připojení k signalizaci, protože klientský kód signalizace zpracovává událost prohlížeče a zavolá metodu `Stop`.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="0dd5a-234">V těchto scénářích nebo na jakékoli klientské platformě, když vaše aplikace volá metodu `Stop`, obslužná rutina události `OnDisconnected` se okamžitě spustí na serveru a klient vyvolá událost `Closed` (událost je pojmenována `disconnected` v JavaScriptu).</span><span class="sxs-lookup"><span data-stu-id="0dd5a-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="0dd5a-235">Pokud klientská aplikace nebo počítač, který je spuštěný v případě havárie nebo přejde do režimu spánku (například když uživatel zavírá notebook), neoznamuje server informace o tom, co se stalo.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="0dd5a-236">Pokud je server ví, může dojít ke ztrátě klienta z důvodu přerušení připojení a klient se může pokusit o opětovné připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="0dd5a-237">Proto se v těchto scénářích Server počká, aby klient mohl znovu připojit, a `OnDisconnected` se nespustí, dokud nevyprší časový limit odpojení (přibližně 30 sekund ve výchozím nastavení).</span><span class="sxs-lookup"><span data-stu-id="0dd5a-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="0dd5a-238">Tento scénář je znázorněn na následujícím obrázku.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-238">The following diagram illustrates this scenario.</span></span>

![Selhání klientského počítače](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="0dd5a-240">Scénáře odpojení serveru</span><span class="sxs-lookup"><span data-stu-id="0dd5a-240">Server disconnection scenarios</span></span>

<span data-ttu-id="0dd5a-241">Když server přejde do režimu offline, dojde k chybě, recyklace domény aplikace atd.--výsledek může být podobný ztrátě připojení, nebo transportní rozhraní API a odesilatele může okamžitě zjistit, že se server nachází, a signál se může pokusit znovu připojit bez vyvolání události `ConnectionSlow`.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="0dd5a-242">Pokud se klient přepne do režimu opětovného připojení a pokud se server obnoví nebo restartuje nebo se nový server přepne do online režimu před vypršením časového limitu odpojení, klient se znovu připojí k obnovenému nebo novému serveru.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="0dd5a-243">V takovém případě připojení k signalizaci pokračuje na klientovi a vyvolá se `Reconnected` událost.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="0dd5a-244">Na prvním serveru se `OnDisconnected` nikdy neprovede a na novém serveru se `OnReconnected` spustí, i když `OnConnected` pro tohoto klienta na tomto serveru spuštěný.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="0dd5a-245">(Účinek je stejný, pokud se klient znovu připojí ke stejnému serveru po restartování nebo recyklaci domény aplikace, protože když se server restartuje, nemá žádná paměť předchozí aktivity připojení.) Následující diagram předpokládá, že transportní rozhraní API se okamžitě dozvědělo o ztraceném připojení, takže se událost `ConnectionSlow` neaktivuje.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Selhání serveru a opětovné připojení](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="0dd5a-247">Pokud se server v rámci časového limitu odpojení nestane dostupný, ukončí se připojení k signalizaci.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="0dd5a-248">V tomto scénáři je v klientovi vyvolána událost `Closed` (`disconnected` v klientech JavaScript), ale `OnDisconnected` na serveru nikdy není volána.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="0dd5a-249">Následující diagram předpokládá, že transportní rozhraní API neví o ztracených připojeních, takže se detekuje funkcí kontroly naživu a `ConnectionSlow` událostmi.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Selhání serveru a časový limit](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="0dd5a-251">Nastavení časového limitu a kontroly naživu</span><span class="sxs-lookup"><span data-stu-id="0dd5a-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="0dd5a-252">Výchozí hodnoty `ConnectionTimeout`, `DisconnectTimeout`a `KeepAlive` jsou vhodné pro většinu scénářů, ale můžou se změnit, pokud vaše prostředí má speciální požadavky.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="0dd5a-253">Pokud například vaše síťové prostředí ukončí připojení, která jsou nečinná po dobu 5 sekund, možná budete muset snížit hodnotu kontroly stavu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="0dd5a-254">connectionTimeout</span><span class="sxs-lookup"><span data-stu-id="0dd5a-254">ConnectionTimeout</span></span>

<span data-ttu-id="0dd5a-255">Toto nastavení představuje dobu, po kterou může být připojení přenosu otevřeno a čeká na odpověď před zavřením a otevřením nového připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="0dd5a-256">Výchozí hodnota je 110 sekund.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="0dd5a-257">Toto nastavení platí pouze v případě, že funkce kontroly naživu je zakázána, což obvykle platí pouze pro přenos dlouhého cyklického dotazování.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="0dd5a-258">Následující diagram znázorňuje účinek tohoto nastavení při dlouhodobém připojení přenosu s dotazem.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Přenosové připojení dlouhého cyklického dotazování](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="0dd5a-260">Hodnota DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="0dd5a-260">DisconnectTimeout</span></span>

<span data-ttu-id="0dd5a-261">Toto nastavení představuje dobu, po kterou se má čekat po ztrátě připojení přenosu, než se vyvolala událost `Disconnected`.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="0dd5a-262">Výchozí hodnota je 30 sekund.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-262">The default value is 30 seconds.</span></span> <span data-ttu-id="0dd5a-263">Když nastavíte `DisconnectTimeout`, `KeepAlive` se automaticky nastaví na 1/3 hodnoty `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="0dd5a-264">Udržení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-264">KeepAlive</span></span>

<span data-ttu-id="0dd5a-265">Toto nastavení představuje dobu, po kterou se má čekat před odesláním paketu kontroly a času přes nečinné připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="0dd5a-266">Výchozí hodnota je 10 sekund.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-266">The default value is 10 seconds.</span></span> <span data-ttu-id="0dd5a-267">Tato hodnota nesmí být větší než 1/3 hodnoty `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="0dd5a-268">Chcete-li nastavit `DisconnectTimeout` i `KeepAlive`, nastavte `KeepAlive` po `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="0dd5a-269">V opačném případě bude nastavení `KeepAlive` přepsáno, pokud `DisconnectTimeout` automaticky nastaví `KeepAlive` na 1/3 z hodnoty časového limitu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="0dd5a-270">Pokud chcete zakázat funkci udržení naživu, nastavte `KeepAlive` na null.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="0dd5a-271">Funkce kontroly naživu je pro přenos dlouhého cyklického dotazování automaticky zakázaná.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="0dd5a-272">Postup změny nastavení časových limitů a kontroly udržení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="0dd5a-273">Chcete-li změnit výchozí hodnoty pro tato nastavení, nastavte je v `Application_Start` v souboru *Global. asax* , jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="0dd5a-274">Hodnoty uvedené v ukázkovém kódu jsou stejné jako výchozí hodnoty.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="0dd5a-275">Upozornění uživatele na odpojení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="0dd5a-276">V některých aplikacích může být vhodné zobrazit uživateli při potížích s připojením zprávu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="0dd5a-277">Máte několik možností, jak a kdy to udělat.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="0dd5a-278">Následující ukázky kódu jsou pro klienta jazyka JavaScript pomocí vygenerovaného proxy serveru.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="0dd5a-279">Zpracujte událost `connectionSlow`, aby se zobrazila zpráva, jakmile signál ví o problémech s připojením, než se přejde do režimu opětovného připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="0dd5a-280">Zpracujte událost `reconnecting`, aby zobrazila zprávu, když signál zná informace o odpojení a přechází do režimu opětovného připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="0dd5a-281">Zpracuje událost `disconnected`, aby zobrazila zprávu, když vypršel časový limit pokusu o opětovné připojení. V tomto scénáři jediným způsobem, jak znovu navázat spojení se serverem, je restartování připojení k signalizaci voláním metody `Start`, která vytvoří nové ID připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="0dd5a-282">Následující ukázka kódu používá příznak k tomu, abyste se ujistili, že budete vydávat oznámení až po vypršení časového limitu opětovného připojení, ne po normálním ukončení připojení k signalizaci, které bylo způsobené voláním metody `Stop`.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="0dd5a-283">Postup nepřetržitého opětovného připojení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-283">How to continuously reconnect</span></span>

<span data-ttu-id="0dd5a-284">V některých aplikacích můžete chtít automaticky znovu vytvořit připojení po jeho ztrátě a časový limit pokusu o opětovné připojení vypršel. To lze provést voláním metody `Start` z obslužné rutiny události `Closed` (`disconnected` obslužné rutiny události v klientech jazyka JavaScript).</span><span class="sxs-lookup"><span data-stu-id="0dd5a-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="0dd5a-285">Možná budete chtít počkat časový interval před voláním `Start`, abyste se vyhnuli příliš často, když je server nebo fyzické připojení nedostupné.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="0dd5a-286">Následující ukázka kódu je pro JavaScriptový klient využívající vygenerovaný proxy server.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="0dd5a-287">Možným problémem v mobilních klientech je to, že při pokusech o nepřetržité opětovné připojení, když je server nebo fyzické připojení dostupné, by mohlo dojít k zbytečnému vyprázdnění baterie.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="0dd5a-288">Odpojení klienta v serverovém kódu</span><span class="sxs-lookup"><span data-stu-id="0dd5a-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="0dd5a-289">V nástroji Signal verze 2 není k dispozici integrované serverové rozhraní API pro odpojení klientů.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="0dd5a-290">V budoucnu jsou k dispozici [plány pro přidání této funkce](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="0dd5a-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="0dd5a-291">Nejjednodušší způsob, jak odpojit klienta ze serveru, je v aktuálním vydání signalizace implementace metody odpojení na straně klienta a volání této metody ze serveru.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="0dd5a-292">Následující ukázka kódu ukazuje metodu odpojení pro klienta jazyka JavaScript pomocí vygenerovaného proxy serveru.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="0dd5a-293">Zabezpečení – ani tato metoda odpojení klientů ani navržený integrovaný rozhraní API bude řešit scénář napadených klientů, na kterých běží škodlivý kód, protože se klienti mohou znovu připojit nebo by napadený kód mohl odebrat metodu `stopClient` nebo změnit jejich chování.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="0dd5a-294">Příslušné místo pro implementaci stavové ochrany DOS (Denial of Service) není v architektuře ani ve vrstvě serveru, ale spíše v infrastruktuře front-endu.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="0dd5a-295">Zjištění důvodu odpojení</span><span class="sxs-lookup"><span data-stu-id="0dd5a-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="0dd5a-296">Návěstí 2,1 přidá přetížení na server `OnDisconnect` událost, která označuje, jestli se klient úmyslně odpojil, ale nečeká na vypršení časového limitu. Parametr `StopCalled` má hodnotu true, pokud klient explicitně uzavřel připojení.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="0dd5a-297">Pokud v jazyce JavaScript chyba serveru vedla klienta k odpojení, budou informace o chybě předány klientovi jako `$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="0dd5a-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="0dd5a-298">**C#Server kód: `stopCalled` parametr**</span><span class="sxs-lookup"><span data-stu-id="0dd5a-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="0dd5a-299">**JavaScriptový kód klienta: přístup k `lastError` v události `disconnect`.**</span><span class="sxs-lookup"><span data-stu-id="0dd5a-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
