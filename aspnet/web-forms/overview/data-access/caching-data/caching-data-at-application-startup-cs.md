---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
title: Ukládání dat do mezipaměti při spuštěníC#aplikace () | Microsoft Docs
author: rick-anderson
description: V jakékoli webové aplikaci se často používají data a některá data se nepoužívají zřídka. Můžeme vylepšit výkon naší aplikace ASP.NET b...
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 22ca8efa-7cd1-45a7-b9ce-ce6eb3b3ff95
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
msc.type: authoredcontent
ms.openlocfilehash: a0b55b0df1b7843120de284891e16178df23fabe
ms.sourcegitcommit: fe5c7512383a9b0a05d321ff10d3cca1611556f0
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/05/2019
ms.locfileid: "70386601"
---
# <a name="caching-data-at-application-startup-c"></a><span data-ttu-id="7fcd1-104">Ukládání dat do mezipaměti při spuštění aplikace (C#)</span><span class="sxs-lookup"><span data-stu-id="7fcd1-104">Caching Data at Application Startup (C#)</span></span>

<span data-ttu-id="7fcd1-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="7fcd1-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

[<span data-ttu-id="7fcd1-106">Stáhnout PDF</span><span class="sxs-lookup"><span data-stu-id="7fcd1-106">Download PDF</span></span>](caching-data-at-application-startup-cs/_static/datatutorial60cs1.pdf)

> <span data-ttu-id="7fcd1-107">V jakékoli webové aplikaci se často používají data a některá data se nepoužívají zřídka.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-107">In any Web application some data will be frequently used and some data will be infrequently used.</span></span> <span data-ttu-id="7fcd1-108">Výkon naší aplikace ASP.NET můžeme vylepšit načtením předem používaných dat, technika známá jako ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-108">We can improve the performance of our ASP.NET application by loading in advance the frequently-used data, a technique known as Caching.</span></span> <span data-ttu-id="7fcd1-109">V tomto kurzu se dozvíte o jednom z přístupů k proaktivnímu načítání, které slouží k načtení dat do mezipaměti při spuštění aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-109">This tutorial demonstrates one approach to proactive loading, which is to load data into the cache at application startup.</span></span>

## <a name="introduction"></a><span data-ttu-id="7fcd1-110">Úvod</span><span class="sxs-lookup"><span data-stu-id="7fcd1-110">Introduction</span></span>

<span data-ttu-id="7fcd1-111">Dva předchozí kurzy se prohlédly při ukládání dat do mezipaměti v prezentačních a mezipamětních vrstvách.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-111">The two previous tutorials looked at caching data in the Presentation and Caching Layers.</span></span> <span data-ttu-id="7fcd1-112">Při [ukládání dat do mezipaměti](caching-data-with-the-objectdatasource-cs.md)v prvku ObjectDataSource jsme se podívali na použití funkcí pro ukládání do mezipaměti prvku ObjectDataSource k ukládání dat do mezipaměti v prezentační vrstvě.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-112">In [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-cs.md), we looked at using the ObjectDataSource's caching features to cache data in the Presentation Layer.</span></span> <span data-ttu-id="7fcd1-113">[Ukládání dat do mezipaměti v architektuře](caching-data-in-the-architecture-cs.md) v rámci přezkoumané mezipaměti v nové oddělené vrstvě pro ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-113">[Caching Data in the Architecture](caching-data-in-the-architecture-cs.md) examined caching in a new, separate Caching Layer.</span></span> <span data-ttu-id="7fcd1-114">Oba tyto kurzy používaly *reaktivní načítání* při práci s datovou mezipamětí.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-114">Both of these tutorials used *reactive loading* in working with the data cache.</span></span> <span data-ttu-id="7fcd1-115">Při reaktivním načítání pokaždé, když se vyžadují data, systém nejdřív zkontroluje, jestli je v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-115">With reactive loading, each time the data is requested, the system first checks if it's in the cache.</span></span> <span data-ttu-id="7fcd1-116">Pokud ne, přičtou data z původního zdroje, jako je databáze, a pak je uloží do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-116">If not, it grabs the data from the originating source, such as the database, and then stores it in the cache.</span></span> <span data-ttu-id="7fcd1-117">Hlavní výhodou pro reaktivní načítání je jeho snadné implementace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-117">The main advantage to reactive loading is its ease of implementation.</span></span> <span data-ttu-id="7fcd1-118">Jednou z jeho nevýhody je nerovnoměrné výkon napříč požadavky.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-118">One of its disadvantages is its uneven performance across requests.</span></span> <span data-ttu-id="7fcd1-119">Představte si stránku, která používá vrstvu ukládání do mezipaměti z předchozího kurzu pro zobrazení informací o produktu.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-119">Imagine a page that uses the Caching Layer from the preceding tutorial to display product information.</span></span> <span data-ttu-id="7fcd1-120">Pokud je tato stránka navštívena poprvé nebo navštívena poprvé po vyřazení dat uložených v mezipaměti z důvodu omezení paměti nebo zadaného vypršení platnosti, musí být data načtena z databáze.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-120">When this page is visited for the first time, or visited for the first time after the cached data has been evicted due to memory constraints or the specified expiry having been reached, the data must be retrieved from the database.</span></span> <span data-ttu-id="7fcd1-121">Proto tyto požadavky uživatelů budou trvat déle než požadavky uživatelů, které může mezipaměť zpracovat.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-121">Therefore, these users requests will take longer than users requests that can be served by the cache.</span></span>

<span data-ttu-id="7fcd1-122">*Proaktivní načítání* poskytuje alternativní strategii pro správu mezipaměti, která vyhlazuje výkon napříč požadavky načtením dat uložených v mezipaměti, než je budete potřebovat.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-122">*Proactive loading* provides an alternative cache management strategy that smoothes out the performance across requests by loading the cached data before it's needed.</span></span> <span data-ttu-id="7fcd1-123">Proaktivní načítání obvykle používá určitý proces, který buď pravidelně kontroluje, nebo je oznámení, když došlo k aktualizaci podkladových dat.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-123">Typically, proactive loading uses some process that either periodically checks or is notified when there has been an update to the underlying data.</span></span> <span data-ttu-id="7fcd1-124">Tento proces pak aktualizuje mezipaměť, aby se zachovala její aktuálnost.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-124">This process then updates the cache to keep it fresh.</span></span> <span data-ttu-id="7fcd1-125">Proaktivní načítání je užitečné hlavně v případě, že podkladová data pocházejí z pomalého připojení k databázi, webové služby nebo jiného zdroje dat, zejména pomalá.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-125">Proactive loading is especially useful if the underlying data comes from a slow database connection, a Web service, or some other particularly sluggish data source.</span></span> <span data-ttu-id="7fcd1-126">Ale tento přístup k proaktivnímu načítání je obtížnější implementovat, protože vyžaduje vytváření, správu a nasazování procesu pro kontrolu změn a aktualizaci mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-126">But this approach to proactive loading is more difficult to implement, as it requires creating, managing, and deploying a process to check for changes and update the cache.</span></span>

<span data-ttu-id="7fcd1-127">Dalším charakterem proaktivního načítání a typu, který prozkoumáme v tomto kurzu, je načítání dat do mezipaměti při spuštění aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-127">Another flavor of proactive loading, and the type we'll be exploring in this tutorial, is loading data into the cache at application startup.</span></span> <span data-ttu-id="7fcd1-128">Tento přístup je zvláště užitečný pro ukládání statických dat do mezipaměti, jako jsou záznamy v tabulkách pro vyhledávání databáze.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-128">This approach is especially useful for caching static data, such as the records in database lookup tables.</span></span>

> [!NOTE]
> <span data-ttu-id="7fcd1-129">Podrobnější přehled o rozdílech mezi aktivním a reaktivním načítáním a také se seznamy doporučení pro odborníky, nevýhody a implementaci najdete v části [Správa obsahu mezipaměti](https://msdn.microsoft.com/library/ms978503.aspx) v [Průvodci architekturou mezipaměti pro aplikace .NET Framework](https://msdn.microsoft.com/library/ms978498.aspx).</span><span class="sxs-lookup"><span data-stu-id="7fcd1-129">For a more in-depth look at the differences between proactive and reactive loading, as well as lists of pros, cons, and implementation recommendations, refer to the [Managing the Contents of a Cache](https://msdn.microsoft.com/library/ms978503.aspx) section of the [Caching Architecture Guide for .NET Framework Applications](https://msdn.microsoft.com/library/ms978498.aspx).</span></span>

## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a><span data-ttu-id="7fcd1-130">Krok 1: určení dat pro ukládání do mezipaměti při spuštění aplikace</span><span class="sxs-lookup"><span data-stu-id="7fcd1-130">Step 1: Determining What Data to Cache at Application Startup</span></span>

<span data-ttu-id="7fcd1-131">Příklady ukládání do mezipaměti pomocí reaktivního načítání, které jsme prozkoumali v předchozích dvou kurzech, dobře fungují s daty, která se můžou pravidelně měnit a exorbitantly dlouho netrvá.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-131">The caching examples using reactive loading that we examined in the previous two tutorials work well with data that may periodically change and does not take exorbitantly long to generate.</span></span> <span data-ttu-id="7fcd1-132">Pokud se ale data uložená v mezipaměti nikdy nezmění, vyprší platnost používaná reaktivním načítáním nadbytečným.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-132">But if the cached data never changes, the expiry used by reactive loading is superfluous.</span></span> <span data-ttu-id="7fcd1-133">Podobně platí, že pokud se data ukládají do mezipaměti delší dobu, bude nutné, aby uživatelé, jejichž požadavky vyhledali mezipaměť prázdné, musely dlouhodobě počkat, dokud se načtou základní data.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-133">Likewise, if the data being cached takes an exceedingly long time to generate, then those users whose requests find the cache empty will have to endure a lengthy wait while the underlying data is retrieved.</span></span> <span data-ttu-id="7fcd1-134">Zvažte ukládání statických dat a dat, která při spuštění aplikace přebírají výjimečně dlouhou dobu.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-134">Consider caching static data and data that takes an exceptionally long time to generate at application startup.</span></span>

<span data-ttu-id="7fcd1-135">I když databáze obsahují mnoho dynamických, často se měnících hodnot, má většina také spravedlivé množství statických dat.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-135">While databases have many dynamic, frequently-changing values, most also have a fair amount of static data.</span></span> <span data-ttu-id="7fcd1-136">Prakticky všechny datové modely mají například jeden nebo více sloupců, které obsahují určitou hodnotu z pevné sady možností.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-136">For example, virtually all data models have one or more columns that contain a particular value from a fixed set of choices.</span></span> <span data-ttu-id="7fcd1-137">Databázová tabulka `Patients` může mít `PrimaryLanguage` sloupec, jehož sada hodnot by mohla být angličtina, španělština, francouzština, ruština, japonština a tak dále.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-137">A `Patients` database table might have a `PrimaryLanguage` column, whose set of values could be English, Spanish, French, Russian, Japanese, and so on.</span></span> <span data-ttu-id="7fcd1-138">Často tyto typy sloupců jsou implementovány pomocí *vyhledávacích tabulek*.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-138">Oftentimes, these types of columns are implemented using *lookup tables*.</span></span> <span data-ttu-id="7fcd1-139">Místo ukládání řetězcové angličtiny nebo francouzštiny do tabulky `Patients` je vytvořena druhá tabulka, která má obvykle dva sloupce – jedinečný identifikátor a popis řetězce – s záznamem pro každou možnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-139">Rather than storing the string English or French in the `Patients` table, a second table is created that has, commonly, two columns - a unique identifier and a string description - with a record for each possible value.</span></span> <span data-ttu-id="7fcd1-140">Sloupec `PrimaryLanguage` v tabulce `Patients` ukládá odpovídající jedinečný identifikátor ve vyhledávací tabulce.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-140">The `PrimaryLanguage` column in the `Patients` table stores the corresponding unique identifier in the lookup table.</span></span> <span data-ttu-id="7fcd1-141">Na obrázku 1 je primárním jazykem pacienta Jan Novák, ale Johnsonem je ruština.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-141">In Figure 1, patient John Doe's primary language is English, while Ed Johnson's is Russian.</span></span>

![Tabulka jazyky je vyhledávací tabulka, kterou používá tabulka pacientů.](caching-data-at-application-startup-cs/_static/image1.png)

<span data-ttu-id="7fcd1-143">**Obrázek 1**: `Languages` tabulka je vyhledávací tabulka, kterou používá tabulka `Patients`.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-143">**Figure 1**: The `Languages` Table is a Lookup Table Used by the `Patients` Table</span></span>

<span data-ttu-id="7fcd1-144">Uživatelské rozhraní pro úpravy nebo vytvoření nového pacienta by zahrnovalo rozevírací seznam povolených jazyků vyplněný záznamy v `Languages` tabulce.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-144">The user interface for editing or creating a new patient would include a drop-down list of allowable languages populated by the records in the `Languages` table.</span></span> <span data-ttu-id="7fcd1-145">Bez ukládání do mezipaměti, při každém navštívení tohoto rozhraní systém musí zadat dotaz na `Languages` tabulku.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-145">Without caching, each time this interface is visited the system must query the `Languages` table.</span></span> <span data-ttu-id="7fcd1-146">To je wasteful a zbytečné, protože se hodnoty vyhledávací tabulky velmi nečasto mění, pokud je to dřív.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-146">This is wasteful and unnecessary since lookup table values change very infrequently, if ever.</span></span>

<span data-ttu-id="7fcd1-147">Data `Languages` můžeme ukládat do mezipaměti pomocí stejných technik reaktivního načítání, které jsou zkoumány v předchozích kurzech.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-147">We could cache the `Languages` data using the same reactive loading techniques examined in the previous tutorials.</span></span> <span data-ttu-id="7fcd1-148">Opětovné aktivní načítání ale používá vypršení platnosti založené na čase, které není nutné pro data statické vyhledávací tabulky.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-148">Reactive loading, however, uses a time-based expiry, which is not needed for static lookup table data.</span></span> <span data-ttu-id="7fcd1-149">I když je ukládání do mezipaměti pomocí reaktivního načítání lepší než ukládání do mezipaměti, nejlepším řešením je proaktivně načíst data vyhledávací tabulky do mezipaměti při spuštění aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-149">While caching using reactive loading would be better than no caching at all, the best approach would be to proactively load the lookup table data into the cache at application startup.</span></span>

<span data-ttu-id="7fcd1-150">V tomto kurzu se podíváme na to, jak ukládat data vyhledávací tabulky do mezipaměti a dalších statických informací.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-150">In this tutorial we will look at how to cache lookup table data and other static information.</span></span>

## <a name="step-2-examining-the-different-ways-to-cache-data"></a><span data-ttu-id="7fcd1-151">Krok 2: prozkoumání různých způsobů ukládání dat do mezipaměti</span><span class="sxs-lookup"><span data-stu-id="7fcd1-151">Step 2: Examining the Different Ways to Cache Data</span></span>

<span data-ttu-id="7fcd1-152">Informace mohou být programově uloženy v mezipaměti aplikace ASP.NET pomocí různých přístupů.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-152">Information can be programmatically cached in an ASP.NET application using a variety of approaches.</span></span> <span data-ttu-id="7fcd1-153">V předchozích kurzech jsme už viděli, jak používat mezipaměť dat.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-153">We ve already seen how to use the data cache in previous tutorials.</span></span> <span data-ttu-id="7fcd1-154">Alternativně lze objekty programově ukládat do mezipaměti pomocí *statických členů* nebo *stavu aplikace*.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-154">Alternatively, objects can be programmatically cached using *static members* or *application state*.</span></span>

<span data-ttu-id="7fcd1-155">Při práci s třídou musí být obvykle nejprve vytvořena instance před tím, než je možné k nim přistupovat její členové.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-155">When working with a class, typically the class must first be instantiated before its members can be accessed.</span></span> <span data-ttu-id="7fcd1-156">Chcete-li například vyvolat metodu z jedné ze tříd v naší vrstvě obchodní logiky, je nutné nejprve vytvořit instanci třídy:</span><span class="sxs-lookup"><span data-stu-id="7fcd1-156">For example, in order to invoke a method from one of the classes in our Business Logic Layer, we must first create an instance of the class:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample1.cs)]

<span data-ttu-id="7fcd1-157">Předtím, než můžeme vyvolat *SomeMethod* nebo pracovat s *SomeProperty*, je nutné nejprve vytvořit instanci třídy pomocí klíčového slova `new`.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-157">Before we can invoke *SomeMethod* or work with *SomeProperty*, we must first create an instance of the class using the `new` keyword.</span></span> <span data-ttu-id="7fcd1-158">*SomeMethod* a *SomeProperty* jsou spojeny s konkrétní instancí.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-158">*SomeMethod* and *SomeProperty* are associated with a particular instance.</span></span> <span data-ttu-id="7fcd1-159">Životnost těchto členů je svázána s životností jejich přidruženého objektu.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-159">The lifetime of these members is tied to the lifetime of their associated object.</span></span> <span data-ttu-id="7fcd1-160">*Statické členy*na druhé straně jsou proměnné, vlastnosti a metody, které jsou sdíleny mezi *všemi* instancemi třídy, a v důsledku toho mají životnost, pokud je třída.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-160">*Static members*, on the other hand, are variables, properties, and methods that are shared among *all* instances of the class and, consequently, have a lifetime as long as the class.</span></span> <span data-ttu-id="7fcd1-161">Statické členy jsou označeny klíčovým slovem `static`.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-161">Static members are denoted by the keyword `static`.</span></span>

<span data-ttu-id="7fcd1-162">Kromě statických členů lze data ukládat do mezipaměti pomocí stavu aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-162">In addition to static members, data can be cached using application state.</span></span> <span data-ttu-id="7fcd1-163">Každá aplikace ASP.NET udržuje kolekci název/hodnota, která je sdílena napříč všemi uživateli a stránkami aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-163">Each ASP.NET application maintains a name/value collection that's shared across all users and pages of the application.</span></span> <span data-ttu-id="7fcd1-164">Tato kolekce je k dispozici pomocí [vlastnosti`Application`](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx) [třídy`HttpContext`](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)a používá se ve třídě kódu na pozadí stránky ASP.NET, například:</span><span class="sxs-lookup"><span data-stu-id="7fcd1-164">This collection can be accessed using the [`HttpContext` class](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)'s [`Application` property](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx), and used from an ASP.NET page's code-behind class like so:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample2.cs)]

<span data-ttu-id="7fcd1-165">Mezipaměť dat poskytuje mnohem rozsáhlejší rozhraní API pro ukládání dat do mezipaměti, poskytování mechanismů pro vypršení platnosti a časově omezené závislosti na základě časových limitů, priorit položek mezipaměti a tak dále.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-165">The data cache provides a much richer API for caching data, providing mechanisms for time- and dependency-based expiries, cache item priorities, and so forth.</span></span> <span data-ttu-id="7fcd1-166">U statických členů a stavu aplikace musí být takové funkce přidány ručně vývojářem stránky.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-166">With static members and application state, such features must be manually added by the page developer.</span></span> <span data-ttu-id="7fcd1-167">Při ukládání dat do mezipaměti při spuštění aplikace po dobu života aplikace se ale výhody datové mezipaměti moot.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-167">When caching data at application startup for the lifetime of the application, however, the data cache's advantages are moot.</span></span> <span data-ttu-id="7fcd1-168">V tomto kurzu se podíváme na kód, který používá všechny tři techniky pro ukládání statických dat do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-168">In this tutorial we'll look at code that uses all three techniques for caching static data.</span></span>

## <a name="step-3-caching-thesupplierstable-data"></a><span data-ttu-id="7fcd1-169">Krok 3: ukládání dat`Suppliers`tabulky do mezipaměti</span><span class="sxs-lookup"><span data-stu-id="7fcd1-169">Step 3: Caching the`Suppliers`Table Data</span></span>

<span data-ttu-id="7fcd1-170">Tabulky databáze Northwind, které jsme v tomto datu implementovali, neobsahují žádné tradiční vyhledávací tabulky.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-170">The Northwind database tables we ve implemented to date do not include any traditional lookup tables.</span></span> <span data-ttu-id="7fcd1-171">Čtyři tabulky DataTables implementované v naší úrovni DAL všechny tabulky modelů, jejichž hodnoty nejsou statické.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-171">The four DataTables implemented in our DAL all model tables whose values are non-static.</span></span> <span data-ttu-id="7fcd1-172">Místo toho, aby bylo možné přidat nový objekt DataTable k objektu DAL a následně novou třídu a metody do knihoven BLL, vám pro tento kurz stačí předstírat, že data `Suppliers` tabulky jsou statická.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-172">Rather than spending the time to add a new DataTable to the DAL and then a new class and methods to the BLL, for this tutorial let's just pretend that the `Suppliers` table's data is static.</span></span> <span data-ttu-id="7fcd1-173">Proto můžeme tato data ukládat do mezipaměti při spuštění aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-173">Therefore, we could cache this data at application startup.</span></span>

<span data-ttu-id="7fcd1-174">Začněte tím, že ve `CL` složce vytvoříte novou třídu s názvem `StaticCache.cs`.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-174">To start, create a new class named `StaticCache.cs` in the `CL` folder.</span></span>

![Vytvoření třídy StaticCache.cs ve složce CL](caching-data-at-application-startup-cs/_static/image2.png)

<span data-ttu-id="7fcd1-176">**Obrázek 2**: vytvoření třídy `StaticCache.cs` ve složce `CL`</span><span class="sxs-lookup"><span data-stu-id="7fcd1-176">**Figure 2**: Create the `StaticCache.cs` Class in the `CL` Folder</span></span>

<span data-ttu-id="7fcd1-177">Musíme přidat metodu, která načte data při spuštění do příslušného úložiště mezipaměti, a také metody, které vracejí data z této mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-177">We need to add a method that loads the data at startup into the appropriate cache store, as well as methods that return data from this cache.</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample3.cs)]

<span data-ttu-id="7fcd1-178">Výše uvedený kód používá statickou členskou proměnnou `suppliers`pro uchování výsledků z metody `GetSuppliers()` `SuppliersBLL` třídy, která je volána z metody `LoadStaticCache()`.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-178">The above code uses a static member variable, `suppliers`, to hold the results from the `SuppliersBLL` class's `GetSuppliers()` method, which is called from the `LoadStaticCache()` method.</span></span> <span data-ttu-id="7fcd1-179">Metoda `LoadStaticCache()` je určena pro volání během spuštění aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-179">The `LoadStaticCache()` method is meant to be called during the application's start.</span></span> <span data-ttu-id="7fcd1-180">Jakmile budou tato data načtena při spuštění aplikace, jakákoliv stránka, která potřebuje pracovat s daty dodavatele, může volat metodu `GetSuppliers()` `StaticCache` třídy.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-180">Once this data has been loaded at application startup, any page that needs to work with supplier data can call the `StaticCache` class's `GetSuppliers()` method.</span></span> <span data-ttu-id="7fcd1-181">Proto volání databáze k získání dodavatelů proběhne pouze jednou, při spuštění aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-181">Therefore, the call to the database to get the suppliers only happens once, at application start.</span></span>

<span data-ttu-id="7fcd1-182">Místo toho, abyste jako úložiště mezipaměti použili statickou členskou proměnnou, můžeme použít taky stav aplikace nebo mezipaměť dat.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-182">Rather than using a static member variable as the cache store, we could have alternatively used application state or the data cache.</span></span> <span data-ttu-id="7fcd1-183">Následující kód ukazuje třídu, která je předaná, aby používala stav aplikace:</span><span class="sxs-lookup"><span data-stu-id="7fcd1-183">The following code shows the class retooled to use application state:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample4.cs)]

<span data-ttu-id="7fcd1-184">V `LoadStaticCache()`jsou informace o dodavatelích uloženy do *klíče*proměnné aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-184">In `LoadStaticCache()`, the supplier information is stored to the application variable *key*.</span></span> <span data-ttu-id="7fcd1-185">Vrátí se jako příslušný typ (`Northwind.SuppliersDataTable`) z `GetSuppliers()`.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-185">It's returned as the appropriate type (`Northwind.SuppliersDataTable`) from `GetSuppliers()`.</span></span> <span data-ttu-id="7fcd1-186">I když je stav aplikace k dispozici v třídách kódu na pozadí stránek ASP.NET pomocí `Application["key"]`, musí být v architektuře pro získání aktuálního `HttpContext`použita `HttpContext.Current.Application["key"]`.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-186">While application state can be accessed in the code-behind classes of ASP.NET pages using `Application["key"]`, in the architecture we must use `HttpContext.Current.Application["key"]` in order to get the current `HttpContext`.</span></span>

<span data-ttu-id="7fcd1-187">Podobně lze mezipaměť dat použít jako úložiště mezipaměti, jak ukazuje následující kód:</span><span class="sxs-lookup"><span data-stu-id="7fcd1-187">Likewise, the data cache can be used as a cache store, as the following code shows:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample5.cs)]

<span data-ttu-id="7fcd1-188">Chcete-li přidat položku do mezipaměti dat bez vypršení platnosti založené na čase, použijte hodnoty `System.Web.Caching.Cache.NoAbsoluteExpiration` a `System.Web.Caching.Cache.NoSlidingExpiration` jako vstupní parametry.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-188">To add an item to the data cache with no time-based expiry, use the `System.Web.Caching.Cache.NoAbsoluteExpiration` and `System.Web.Caching.Cache.NoSlidingExpiration` values as input parameters.</span></span> <span data-ttu-id="7fcd1-189">Toto konkrétní přetížení metody `Insert` datové mezipaměti bylo vybráno, aby bylo možné zadat *prioritu* položky mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-189">This particular overload of the data cache's `Insert` method was selected so that we could specify the *priority* of the cache item.</span></span> <span data-ttu-id="7fcd1-190">Priorita se používá k určení položek, které se mají uklidit z mezipaměti, když dojde k nízké velikosti dostupné paměti.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-190">The priority is used to determine what items to scavenge from the cache when available memory runs low.</span></span> <span data-ttu-id="7fcd1-191">Tady používáme prioritní `NotRemovable`, která zajišťuje, že se tato položka mezipaměti nebude uklidit.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-191">Here we use the priority `NotRemovable`, which ensures that this cache item won't be scavenged.</span></span>

> [!NOTE]
> <span data-ttu-id="7fcd1-192">Stažení tohoto kurzu implementuje třídu `StaticCache` s použitím přístupu ke statické členské proměnné.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-192">This tutorial's download implements the `StaticCache` class using the static member variable approach.</span></span> <span data-ttu-id="7fcd1-193">Kód pro techniky stavu aplikace a mezipaměti dat je k dispozici v komentářích v souboru třídy.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-193">The code for the application state and data cache techniques is available in the comments in the class file.</span></span>

## <a name="step-4-executing-code-at-application-startup"></a><span data-ttu-id="7fcd1-194">Krok 4: spouštění kódu při spuštění aplikace</span><span class="sxs-lookup"><span data-stu-id="7fcd1-194">Step 4: Executing Code at Application Startup</span></span>

<span data-ttu-id="7fcd1-195">Aby bylo možné spustit kód při prvním spuštění webové aplikace, musíme vytvořit speciální soubor s názvem `Global.asax`.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-195">To execute code when a web application first starts, we need to create a special file named `Global.asax`.</span></span> <span data-ttu-id="7fcd1-196">Tento soubor může obsahovat obslužné rutiny událostí pro události aplikace, relace a na úrovni požadavku a je tady, kde můžeme přidat kód, který se spustí při každém spuštění aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-196">This file can contain event handlers for application-, session-, and request-level events, and it is here where we can add code that will be executed whenever the application starts.</span></span>

<span data-ttu-id="7fcd1-197">Přidejte soubor `Global.asax` do kořenového adresáře webové aplikace tak, že kliknete pravým tlačítkem na název projektu webu v Průzkumník řešení sady Visual Studio a zvolíte možnost Přidat novou položku.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-197">Add the `Global.asax` file to your web application's root directory by right-clicking on the website project name in Visual Studio's Solution Explorer and choosing Add New Item.</span></span> <span data-ttu-id="7fcd1-198">V dialogovém okně Přidat novou položku vyberte typ položky globální třída aplikace a pak klikněte na tlačítko Přidat.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-198">From the Add New Item dialog box, select the Global Application Class item type and then click the Add button.</span></span>

> [!NOTE]
> <span data-ttu-id="7fcd1-199">Pokud již máte soubor `Global.asax` ve vašem projektu, typ položky globální třídy aplikace nebude uveden v dialogovém okně Přidat novou položku.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-199">If you already have a `Global.asax` file in your project, the Global Application Class item type will not be listed in the Add New Item dialog box.</span></span>

<span data-ttu-id="7fcd1-200">[![přidat soubor Global. asax do kořenového adresáře vaší webové aplikace](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="7fcd1-200">[![Add the Global.asax File to Your Web Application's Root Directory](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span></span>

<span data-ttu-id="7fcd1-201">**Obrázek 3**: přidejte soubor `Global.asax` do kořenového adresáře webové aplikace ([kliknutím zobrazíte obrázek v plné velikosti).](caching-data-at-application-startup-cs/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="7fcd1-201">**Figure 3**: Add the `Global.asax` File to Your Web Application's Root Directory ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image5.png))</span></span>

<span data-ttu-id="7fcd1-202">Výchozí šablona souboru `Global.asax` obsahuje pět metod v rámci značky `<script>` na straně serveru:</span><span class="sxs-lookup"><span data-stu-id="7fcd1-202">The default `Global.asax` file template includes five methods within a server-side `<script>` tag:</span></span>

- <span data-ttu-id="7fcd1-203">**`Application_Start`** se spustí při prvním spuštění webové aplikace</span><span class="sxs-lookup"><span data-stu-id="7fcd1-203">**`Application_Start`** executes when the web application first starts</span></span>
- <span data-ttu-id="7fcd1-204">**`Application_End`** se spustí, když se aplikace vypíná.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-204">**`Application_End`** runs when the application is shutting down</span></span>
- <span data-ttu-id="7fcd1-205">**`Application_Error`** se spustí pokaždé, když Neošetřená výjimka dosáhne aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-205">**`Application_Error`** executes whenever an unhandled exception reaches the application</span></span>
- <span data-ttu-id="7fcd1-206">**`Session_Start`** se spustí při vytvoření nové relace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-206">**`Session_Start`** executes when a new session is created</span></span>
- <span data-ttu-id="7fcd1-207">**`Session_End`** se spustí, když vypršela platnost relace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-207">**`Session_End`** runs when a session is expired or abandoned</span></span>

<span data-ttu-id="7fcd1-208">Obslužná rutina události `Application_Start` se během životního cyklu aplikace volá jenom jednou.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-208">The `Application_Start` event handler is called only once during an application's life cycle.</span></span> <span data-ttu-id="7fcd1-209">Aplikace se spustí při prvním vyžádání prostředku ASP.NET z aplikace a pokračuje v jeho spuštění, dokud se aplikace nerestartuje, což může nastat úpravou obsahu složky `/Bin`, úpravou `Global.asax`, úpravou obsahu ve složce `App_Code` nebo úpravou souboru `Web.config` mimo jiné příčiny.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-209">The application starts the first time an ASP.NET resource is requested from the application and continues to run until the application is restarted, which can happen by modifying the contents of the `/Bin` folder, modifying `Global.asax`, modifying the contents in the `App_Code` folder, or modifying the `Web.config` file, among other causes.</span></span> <span data-ttu-id="7fcd1-210">Podrobnější diskuzi o životním cyklu aplikace najdete v tématu [Přehled životního cyklu aplikací ASP.NET](https://msdn.microsoft.com/library/ms178473.aspx) .</span><span class="sxs-lookup"><span data-stu-id="7fcd1-210">Refer to [ASP.NET Application Life Cycle Overview](https://msdn.microsoft.com/library/ms178473.aspx) for a more detailed discussion on the application life cycle.</span></span>

<span data-ttu-id="7fcd1-211">V těchto kurzech potřebujeme přidat kód do metody `Application_Start`, takže nemusíte ostatní odebrat.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-211">For these tutorials we only need to add code to the `Application_Start` method, so feel free to remove the others.</span></span> <span data-ttu-id="7fcd1-212">V `Application_Start`jednoduše zavolejte metodu `LoadStaticCache()` `StaticCache` třídy, která načte a uloží do mezipaměti informace o dodavateli:</span><span class="sxs-lookup"><span data-stu-id="7fcd1-212">In `Application_Start`, simply call the `StaticCache` class's `LoadStaticCache()` method, which will load and cache the supplier information:</span></span>

[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample6.aspx)]

<span data-ttu-id="7fcd1-213">A je to!</span><span class="sxs-lookup"><span data-stu-id="7fcd1-213">That's all there is to it!</span></span> <span data-ttu-id="7fcd1-214">Při spuštění aplikace `LoadStaticCache()` metoda předává informace o dodavateli z knihoven BLL a uloží ji do statické členské proměnné (nebo jakéhokoli úložiště mezipaměti, které jste při použití ve třídě `StaticCache` vyukončili.).</span><span class="sxs-lookup"><span data-stu-id="7fcd1-214">At application startup, the `LoadStaticCache()` method will grab the supplier information from the BLL, and store it in a static member variable (or whatever cache store you ended up using in the `StaticCache` class).</span></span> <span data-ttu-id="7fcd1-215">Chcete-li toto chování ověřit, nastavte zarážku v metodě `Application_Start` a spusťte aplikaci.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-215">To verify this behavior, set a breakpoint in the `Application_Start` method and run your application.</span></span> <span data-ttu-id="7fcd1-216">Všimněte si, že zarážka je dosaženo na začátku aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-216">Note that the breakpoint is hit upon the application starting.</span></span> <span data-ttu-id="7fcd1-217">Následné požadavky však nezpůsobí spuštění metody `Application_Start`.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-217">Subsequent requests, however, do not cause the `Application_Start` method to execute.</span></span>

<span data-ttu-id="7fcd1-218">[![použít zarážku k ověření, zda je prováděna obslužná rutina události Application_Start](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="7fcd1-218">[![Use a Breakpoint to Verify that the Application_Start Event Handler is Being Executed](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span></span>

<span data-ttu-id="7fcd1-219">**Obrázek 4**: pomocí zarážky ověřte, zda je spuštěna obslužná rutina události `Application_Start` ([kliknutím zobrazíte obrázek v plné velikosti).](caching-data-at-application-startup-cs/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="7fcd1-219">**Figure 4**: Use a Breakpoint to Verify that the `Application_Start` Event Handler is Being Executed ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image8.png))</span></span>

> [!NOTE]
> <span data-ttu-id="7fcd1-220">Pokud při prvním spuštění ladění nebudete mít `Application_Start` zarážku, je to proto, že vaše aplikace už je spuštěná.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-220">If you do not hit the `Application_Start` breakpoint when you first start debugging, it is because your application has already started.</span></span> <span data-ttu-id="7fcd1-221">Vynuťte restartování aplikace úpravou `Global.asax` nebo `Web.config` souborů a potom akci opakujte.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-221">Force the application to restart by modifying your `Global.asax` or `Web.config` files and then try again.</span></span> <span data-ttu-id="7fcd1-222">K rychlému restartování aplikace můžete jednoduše přidat (nebo odebrat) prázdný řádek na konci jednoho z těchto souborů.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-222">You can simply add (or remove) a blank line at the end of one of these files to quickly restart the application.</span></span>

## <a name="step-5-displaying-the-cached-data"></a><span data-ttu-id="7fcd1-223">Krok 5: zobrazení dat uložených v mezipaměti</span><span class="sxs-lookup"><span data-stu-id="7fcd1-223">Step 5: Displaying the Cached Data</span></span>

<span data-ttu-id="7fcd1-224">V tomto okamžiku má třída `StaticCache` verzi dat dodavatele v mezipaměti při spuštění aplikace, ke kterému je možné přistupovat prostřednictvím její `GetSuppliers()` metody.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-224">At this point the `StaticCache` class has a version of the supplier data cached at application startup that can be accessed through its `GetSuppliers()` method.</span></span> <span data-ttu-id="7fcd1-225">Pro práci s těmito daty z prezentační vrstvy můžeme použít prvek ObjectDataSource nebo programově vyvolat `GetSuppliers()` metodu `StaticCache` třídy z třídy kódu na pozadí stránky ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-225">To work with this data from the Presentation Layer, we can use an ObjectDataSource or programmatically invoke the `StaticCache` class's `GetSuppliers()` method from an ASP.NET page's code-behind class.</span></span> <span data-ttu-id="7fcd1-226">Pojďme se podívat na použití ovládacích prvků ObjectDataSource a GridView k zobrazení informací o dodavateli v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-226">Let's look at using the ObjectDataSource and GridView controls to display the cached supplier information.</span></span>

<span data-ttu-id="7fcd1-227">Začněte tím, že otevřete stránku `AtApplicationStartup.aspx` ve složce `Caching`.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-227">Start by opening the `AtApplicationStartup.aspx` page in the `Caching` folder.</span></span> <span data-ttu-id="7fcd1-228">Přetáhněte prvek GridView z panelu nástrojů do návrháře, nastavením jeho vlastnosti `ID` na hodnotu `Suppliers`.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-228">Drag a GridView from the Toolbox onto the designer, setting its `ID` property to `Suppliers`.</span></span> <span data-ttu-id="7fcd1-229">Dále můžete z inteligentní značky prvku GridView vytvořit nový prvek ObjectDataSource s názvem `SuppliersCachedDataSource`.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-229">Next, from the GridView's smart tag choose to create a new ObjectDataSource named `SuppliersCachedDataSource`.</span></span> <span data-ttu-id="7fcd1-230">Nakonfigurujte prvek ObjectDataSource tak, aby používal metodu `GetSuppliers()` `StaticCache` třídy.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-230">Configure the ObjectDataSource to use the `StaticCache` class's `GetSuppliers()` method.</span></span>

<span data-ttu-id="7fcd1-231">[![nakonfigurovat prvek ObjectDataSource tak, aby používal třídu StaticCache](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="7fcd1-231">[![Configure the ObjectDataSource to use the StaticCache Class](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span></span>

<span data-ttu-id="7fcd1-232">**Obrázek 5**: Konfigurace prvku ObjectDataSource, aby používal třídu `StaticCache` ([kliknutím zobrazíte obrázek v plné velikosti](caching-data-at-application-startup-cs/_static/image11.png))</span><span class="sxs-lookup"><span data-stu-id="7fcd1-232">**Figure 5**: Configure the ObjectDataSource to use the `StaticCache` Class ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image11.png))</span></span>

<span data-ttu-id="7fcd1-233">[![pomocí metody getsuppliers () načíst data dodavatele v mezipaměti](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="7fcd1-233">[![Use the GetSuppliers() Method to Retrieve the Cached Supplier Data](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span></span>

<span data-ttu-id="7fcd1-234">**Obrázek 6**: použití metody `GetSuppliers()` k načtení dat dodavatele uložených v mezipaměti ([kliknutím zobrazíte obrázek v plné velikosti](caching-data-at-application-startup-cs/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="7fcd1-234">**Figure 6**: Use the `GetSuppliers()` Method to Retrieve the Cached Supplier Data ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image14.png))</span></span>

<span data-ttu-id="7fcd1-235">Po dokončení průvodce bude Visual Studio automaticky přidávat BoundFields pro každé datové pole v `SuppliersDataTable`.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-235">After completing the wizard, Visual Studio will automatically add BoundFields for each of the data fields in `SuppliersDataTable`.</span></span> <span data-ttu-id="7fcd1-236">Deklarativní značky GridView a ObjectDataSource by měly vypadat podobně jako následující:</span><span class="sxs-lookup"><span data-stu-id="7fcd1-236">Your GridView and ObjectDataSource's declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample7.aspx)]

<span data-ttu-id="7fcd1-237">Obrázek 7 zobrazuje stránku při prohlížení v prohlížeči.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-237">Figure 7 shows the page when viewed through a browser.</span></span> <span data-ttu-id="7fcd1-238">Výstup je stejný, ale data byla získána z `SuppliersBLL` třídy knihoven BLL, ale použití třídy `StaticCache` vrátí data dodavatelů jako mezipaměť při spuštění aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-238">The output is the same had we pulled the data from the BLL's `SuppliersBLL` class, but using the `StaticCache` class returns the supplier data as cached at application startup.</span></span> <span data-ttu-id="7fcd1-239">Můžete nastavit zarážky v metodě `GetSuppliers()` `StaticCache` třídy, chcete-li toto chování ověřit.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-239">You can set breakpoints in the `StaticCache` class's `GetSuppliers()` method to verify this behavior.</span></span>

<span data-ttu-id="7fcd1-240">[![data dodavatele v mezipaměti se zobrazí v prvku GridView.](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="7fcd1-240">[![The Cached Supplier Data is Displayed in a GridView](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span></span>

<span data-ttu-id="7fcd1-241">**Obrázek 7**: v prvku GridView se zobrazí data dodavatele uložená v mezipaměti ([kliknutím zobrazíte obrázek v plné velikosti](caching-data-at-application-startup-cs/_static/image17.png)).</span><span class="sxs-lookup"><span data-stu-id="7fcd1-241">**Figure 7**: The Cached Supplier Data is Displayed in a GridView ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image17.png))</span></span>

## <a name="summary"></a><span data-ttu-id="7fcd1-242">Souhrn</span><span class="sxs-lookup"><span data-stu-id="7fcd1-242">Summary</span></span>

<span data-ttu-id="7fcd1-243">Většina datových modelů obsahuje korektní množství statických dat, která jsou obvykle implementována ve formě vyhledávacích tabulek.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-243">Most every data model contains a fair amount of static data, usually implemented in the form of lookup tables.</span></span> <span data-ttu-id="7fcd1-244">Vzhledem k tomu, že jsou tyto informace statické, neexistuje žádný důvod k nepřetržitému přístupu k databázi pokaždé, když se tyto informace musí zobrazit.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-244">Since this information is static, there's no reason to continually access the database each time this information needs to be displayed.</span></span> <span data-ttu-id="7fcd1-245">Kromě toho, vzhledem ke své statické podstatě, při ukládání dat do mezipaměti není nutné, aby vypršela platnost.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-245">Furthermore, due to its static nature, when caching the data there's no need for an expiry.</span></span> <span data-ttu-id="7fcd1-246">V tomto kurzu jsme viděli, jak provést taková data a uložit je do mezipaměti v datové mezipaměti, stavu aplikace a prostřednictvím statické členské proměnné.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-246">In this tutorial we saw how to take such data and cache it in the data cache, application state, and through a static member variable.</span></span> <span data-ttu-id="7fcd1-247">Tyto informace jsou ukládány do mezipaměti při spuštění aplikace a zůstávají v mezipaměti v průběhu životního cyklu aplikace.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-247">This information is cached at application startup and remains in the cache throughout the application's lifetime.</span></span>

<span data-ttu-id="7fcd1-248">V tomto kurzu a minulých dvou jsme se vyhledali při ukládání dat do mezipaměti po dobu životnosti aplikace a také při použití vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-248">In this tutorial and the past two, we ve looked at caching data for the duration of the application's lifetime as well as using time-based expiries.</span></span> <span data-ttu-id="7fcd1-249">Při ukládání databázových dat do mezipaměti může i vypršení časového limitu trvat méně, než je ideální.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-249">When caching database data, though, a time-based expiry may be less than ideal.</span></span> <span data-ttu-id="7fcd1-250">Místo pravidelného vyprázdnění mezipaměti by bylo optimální vyřadit položku z mezipaměti pouze v případě, že jsou upravena podkladová data databáze.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-250">Rather than periodically flushing the cache, it would be optimal to only evict the cached item when the underlying database data is modified.</span></span> <span data-ttu-id="7fcd1-251">Ideální možností je použití závislostí mezipaměti SQL, které probereme v našem dalším kurzu.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-251">This ideal is possible through the use of SQL cache dependencies, which we'll examine in our next tutorial.</span></span>

<span data-ttu-id="7fcd1-252">Šťastné programování!</span><span class="sxs-lookup"><span data-stu-id="7fcd1-252">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="7fcd1-253">O autorovi</span><span class="sxs-lookup"><span data-stu-id="7fcd1-253">About the Author</span></span>

<span data-ttu-id="7fcd1-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), autor 7 ASP/ASP. NET Books a zakladatel of [4GuysFromRolla.com](http://www.4guysfromrolla.com), pracoval s webovými technologiemi Microsoftu od 1998.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="7fcd1-255">Scott funguje jako nezávislý konzultant, Trainer a zapisovač.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-255">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="7fcd1-256">Nejnovější kniha je [*Sams naučit se ASP.NET 2,0 za 24 hodin*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span><span class="sxs-lookup"><span data-stu-id="7fcd1-256">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="7fcd1-257">Dá se získat na [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="7fcd1-257">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="7fcd1-258">nebo prostřednictvím svého blogu, který najdete na adrese [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span><span class="sxs-lookup"><span data-stu-id="7fcd1-258">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="7fcd1-259">Zvláštní díky</span><span class="sxs-lookup"><span data-stu-id="7fcd1-259">Special Thanks To</span></span>

<span data-ttu-id="7fcd1-260">Tato řada kurzů byla přezkoumána mnoha užitečnými kontrolory.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-260">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="7fcd1-261">Kontroloři vedoucích k tomuto kurzu byli Teresa Murphy a Zack Novotný.</span><span class="sxs-lookup"><span data-stu-id="7fcd1-261">Lead reviewers for this tutorial were Teresa Murphy and Zack Jones.</span></span> <span data-ttu-id="7fcd1-262">Uvažujete o přezkoumání mých nadcházejících článků na webu MSDN?</span><span class="sxs-lookup"><span data-stu-id="7fcd1-262">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="7fcd1-263">Pokud ano, vyřaďte mi řádek na [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="7fcd1-263">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="7fcd1-264">[Předchozí](caching-data-in-the-architecture-cs.md)
> [Další](using-sql-cache-dependencies-cs.md)</span><span class="sxs-lookup"><span data-stu-id="7fcd1-264">[Previous](caching-data-in-the-architecture-cs.md)
[Next](using-sql-cache-dependencies-cs.md)</span></span>
