---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
title: Ukládání dat do mezipaměti v architektuře (VB) | Microsoft Docs
author: rick-anderson
description: V předchozím kurzu jsme zjistili, jak používat ukládání do mezipaměti v prezentační vrstvě. V tomto kurzu se naučíme, jak využít naši vrstvený architekt...
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 5e189dd7-f4f9-4f28-9b3a-6cb7d392e9c7
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
msc.type: authoredcontent
ms.openlocfilehash: dc991a205fa7e61f604bc0f26e9b24b3faefd3d3
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/06/2020
ms.locfileid: "78551007"
---
# <a name="caching-data-in-the-architecture-vb"></a><span data-ttu-id="0443a-104">Ukládání dat do mezipaměti v architektuře (VB)</span><span class="sxs-lookup"><span data-stu-id="0443a-104">Caching Data in the Architecture (VB)</span></span>

<span data-ttu-id="0443a-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="0443a-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="0443a-106">[Stáhnout ukázkovou aplikaci](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe) nebo [Stáhnout PDF](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="0443a-106">[Download Sample App](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe) or [Download PDF](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span></span>

> <span data-ttu-id="0443a-107">V předchozím kurzu jsme zjistili, jak používat ukládání do mezipaměti v prezentační vrstvě.</span><span class="sxs-lookup"><span data-stu-id="0443a-107">In the previous tutorial we learned how to apply caching at the Presentation Layer.</span></span> <span data-ttu-id="0443a-108">V tomto kurzu se naučíme, jak využít naši vrstvenou architekturu pro ukládání dat do mezipaměti v rámci vrstvy obchodní logiky.</span><span class="sxs-lookup"><span data-stu-id="0443a-108">In this tutorial we learn how to take advantage of our layered architecture to cache data at the Business Logic Layer.</span></span> <span data-ttu-id="0443a-109">To provedeme rozšířením architektury, aby zahrnovala vrstvu ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="0443a-109">We do this by extending the architecture to include a Caching Layer.</span></span>

## <a name="introduction"></a><span data-ttu-id="0443a-110">Úvod</span><span class="sxs-lookup"><span data-stu-id="0443a-110">Introduction</span></span>

<span data-ttu-id="0443a-111">Jak jsme viděli v předchozím kurzu, ukládání dat v prvku ObjectDataSource s do mezipaměti je tak jednoduché jako nastavení několika vlastností.</span><span class="sxs-lookup"><span data-stu-id="0443a-111">As we saw in the preceding tutorial, caching the ObjectDataSource s data is as simple as setting a couple of properties.</span></span> <span data-ttu-id="0443a-112">Prvek ObjectDataSource bohužel aplikuje ukládání do mezipaměti do prezentační vrstvy, která úzce Couples zásady ukládání do mezipaměti pomocí stránky ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="0443a-112">Unfortunately, the ObjectDataSource applies caching at the Presentation Layer, which tightly couples the caching policies with the ASP.NET page.</span></span> <span data-ttu-id="0443a-113">Jedním z důvodů, proč vytvořit vrstvenou architekturu, je to, aby bylo možné tyto vazby přerušit.</span><span class="sxs-lookup"><span data-stu-id="0443a-113">One of the reasons for creating a layered architecture is to allow such couplings to be broken.</span></span> <span data-ttu-id="0443a-114">Vrstva obchodní logiky například odděluje obchodní logiku ze stránek ASP.NET, zatímco vrstva přístupu k datům odděluje údaje o přístupu k datům.</span><span class="sxs-lookup"><span data-stu-id="0443a-114">The Business Logic Layer, for instance, decouples the business logic from the ASP.NET pages, while the Data Access Layer decouples the data access details.</span></span> <span data-ttu-id="0443a-115">Toto odpojujení obchodní logiky a podrobností přístupu k datům je preferované, protože díky tomu je systém čitelnější, udržovatelnější a flexibilnější, aby se změnila.</span><span class="sxs-lookup"><span data-stu-id="0443a-115">This decoupling of business logic and data access details is preferred, in part, because it makes the system more readable, more maintainable, and more flexible to change.</span></span> <span data-ttu-id="0443a-116">Umožňuje taky znalosti v doméně a rozdělení práce, které vývojář pracuje na prezentační vrstvě. nemusíte být obeznámeni s podrobnostmi o databázi, aby bylo možné svoji úlohu provést.</span><span class="sxs-lookup"><span data-stu-id="0443a-116">It also allows for domain knowledge and division of labor a developer working on the Presentation Layer doesn t need to be familiar with the database s details in order to do her job.</span></span> <span data-ttu-id="0443a-117">Oddělení zásad ukládání do mezipaměti z prezentační vrstvy nabízí podobné výhody.</span><span class="sxs-lookup"><span data-stu-id="0443a-117">Decoupling the caching policy from the Presentation Layer offers similar benefits.</span></span>

<span data-ttu-id="0443a-118">V tomto kurzu rozsadíme naši architekturu tak, aby zahrnovala *vrstvu ukládání do mezipaměti* (nebo CL pro krátké), která využívá naše zásady pro ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="0443a-118">In this tutorial we will augment our architecture to include a *Caching Layer* (or CL for short) that employs our caching policy.</span></span> <span data-ttu-id="0443a-119">Vrstva ukládání do mezipaměti bude zahrnovat `ProductsCL` třídu, která poskytuje přístup k informacím o produktech pomocí metod jako `GetProducts()`, `GetProductsByCategoryID(categoryID)`a tak dále, které při vyvolání se nejprve pokusí načíst data z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="0443a-119">The Caching Layer will include a `ProductsCL` class that provides access to product information with methods like `GetProducts()`, `GetProductsByCategoryID(categoryID)`, and so forth, that, when invoked, will first attempt to retrieve the data from the cache.</span></span> <span data-ttu-id="0443a-120">Pokud je mezipaměť prázdná, tyto metody vyvolá příslušnou metodu `ProductsBLL` v knihoven BLL, která by pak získala data z DAL.</span><span class="sxs-lookup"><span data-stu-id="0443a-120">If the cache is empty, these methods will invoke the appropriate `ProductsBLL` method in the BLL, which would in turn get the data from the DAL.</span></span> <span data-ttu-id="0443a-121">Metody `ProductsCL` mezipaměť dat načtených z knihoven BLL před jejich vrácením.</span><span class="sxs-lookup"><span data-stu-id="0443a-121">The `ProductsCL` methods cache the data retrieved from the BLL before returning it.</span></span>

<span data-ttu-id="0443a-122">Jak ukazuje obrázek 1, CL se nachází mezi vrstvami prezentace a obchodní logiky.</span><span class="sxs-lookup"><span data-stu-id="0443a-122">As Figure 1 shows, the CL resides between the Presentation and Business Logic Layers.</span></span>

![Vrstva ukládání do mezipaměti (CL) je další vrstva v naší architektuře.](caching-data-in-the-architecture-vb/_static/image1.png)

<span data-ttu-id="0443a-124">**Obrázek 1**: vrstva ukládání do mezipaměti (CL) je další vrstva v naší architektuře.</span><span class="sxs-lookup"><span data-stu-id="0443a-124">**Figure 1**: The Caching Layer (CL) is Another Layer in Our Architecture</span></span>

## <a name="step-1-creating-the-caching-layer-classes"></a><span data-ttu-id="0443a-125">Krok 1: vytvoření tříd vrstev pro ukládání do mezipaměti</span><span class="sxs-lookup"><span data-stu-id="0443a-125">Step 1: Creating the Caching Layer Classes</span></span>

<span data-ttu-id="0443a-126">V tomto kurzu vytvoříme velmi jednoduchý CL s jednou třídou `ProductsCL`, která má jenom několik metody.</span><span class="sxs-lookup"><span data-stu-id="0443a-126">In this tutorial we will create a very simple CL with a single class `ProductsCL` that has only a handful of methods.</span></span> <span data-ttu-id="0443a-127">Sestavení kompletní vrstvy ukládání do mezipaměti pro celou aplikaci bude vyžadovat vytváření tříd `CategoriesCL`, `EmployeesCL`a `SuppliersCL` a poskytnutí metody v těchto třídách vrstev pro ukládání do mezipaměti pro jednotlivé metody přístupu k datům nebo úprav v knihoven BLL.</span><span class="sxs-lookup"><span data-stu-id="0443a-127">Building a complete Caching Layer for the entire application would require creating `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes, and providing a method in these Caching Layer classes for each data access or modification method in the BLL.</span></span> <span data-ttu-id="0443a-128">Stejně jako u knihoven BLL a DAL by vrstva ukládání do mezipaměti měla být ideálním způsobem implementována jako samostatný projekt knihovny tříd; budeme ho ale implementovat jako třídu ve složce `App_Code`.</span><span class="sxs-lookup"><span data-stu-id="0443a-128">As with the BLL and DAL, the Caching Layer should ideally be implemented as a separate Class Library project; however, we will implement it as a class in the `App_Code` folder.</span></span>

<span data-ttu-id="0443a-129">Chcete-li efektivněji oddělit třídy CL z tříd DAL a knihoven BLL, nechte vytvořit novou podsložku ve složce `App_Code`.</span><span class="sxs-lookup"><span data-stu-id="0443a-129">To more cleanly separate the CL classes from the DAL and BLL classes, let s create a new subfolder in the `App_Code` folder.</span></span> <span data-ttu-id="0443a-130">Pravým tlačítkem myši klikněte na složku `App_Code` v Průzkumník řešení, vyberte možnost Nová složka a pojmenujte novou složku `CL`.</span><span class="sxs-lookup"><span data-stu-id="0443a-130">Right-click on the `App_Code` folder in the Solution Explorer, choose New Folder, and name the new folder `CL`.</span></span> <span data-ttu-id="0443a-131">Po vytvoření této složky do ní přidejte novou třídu s názvem `ProductsCL.vb`.</span><span class="sxs-lookup"><span data-stu-id="0443a-131">After creating this folder, add to it a new class named `ProductsCL.vb`.</span></span>

![Přidejte novou složku s názvem CL a třídu s názvem ProductsCL. vb.](caching-data-in-the-architecture-vb/_static/image2.png)

<span data-ttu-id="0443a-133">**Obrázek 2**: přidejte novou složku s názvem `CL` a třídu s názvem `ProductsCL.vb`</span><span class="sxs-lookup"><span data-stu-id="0443a-133">**Figure 2**: Add a New Folder Named `CL` and a Class Named `ProductsCL.vb`</span></span>

<span data-ttu-id="0443a-134">Třída `ProductsCL` by měla obsahovat stejnou sadu metod přístupu k datům a úprav, jak se nachází v odpovídající třídě vrstvy obchodní logiky (`ProductsBLL`).</span><span class="sxs-lookup"><span data-stu-id="0443a-134">The `ProductsCL` class should include the same set of data access and modification methods as found in its corresponding Business Logic Layer class (`ProductsBLL`).</span></span> <span data-ttu-id="0443a-135">Místo vytváření všech těchto metod teď stačí sestavit pár, abyste se mohli cítit vzory, které používá CL.</span><span class="sxs-lookup"><span data-stu-id="0443a-135">Rather than creating all of these methods, let s just build a couple here to get a feel for the patterns used by the CL.</span></span> <span data-ttu-id="0443a-136">Konkrétně přidáte do kroku 3 metody `GetProducts()` a `GetProductsByCategoryID(categoryID)` a `UpdateProduct` přetížení v kroku 4.</span><span class="sxs-lookup"><span data-stu-id="0443a-136">In particular, we'll add the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods in Step 3 and an `UpdateProduct` overload in Step 4.</span></span> <span data-ttu-id="0443a-137">Zbývající metody `ProductsCL` a třídy `CategoriesCL`, `EmployeesCL`a `SuppliersCL` můžete přidat do svého volného místa.</span><span class="sxs-lookup"><span data-stu-id="0443a-137">You can add the remaining `ProductsCL` methods and `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes at your leisure.</span></span>

## <a name="step-2-reading-and-writing-to-the-data-cache"></a><span data-ttu-id="0443a-138">Krok 2: čtení a zápis do mezipaměti dat</span><span class="sxs-lookup"><span data-stu-id="0443a-138">Step 2: Reading and Writing to the Data Cache</span></span>

<span data-ttu-id="0443a-139">Funkce ukládání ObjectDataSource do mezipaměti v předchozím kurzu interně používá mezipaměť dat ASP.NET k ukládání dat načtených z knihoven BLL.</span><span class="sxs-lookup"><span data-stu-id="0443a-139">The ObjectDataSource caching feature explored in the preceding tutorial internally uses the ASP.NET data cache to store the data retrieved from the BLL.</span></span> <span data-ttu-id="0443a-140">Mezipaměť dat je také k dispozici programově ze tříd ASP.NET stránky kódu na pozadí nebo z tříd v architektuře webové aplikace s.</span><span class="sxs-lookup"><span data-stu-id="0443a-140">The data cache can also be accessed programmatically from ASP.NET pages code-behind classes or from the classes in the web application s architecture.</span></span> <span data-ttu-id="0443a-141">Pro čtení a zápis do mezipaměti dat ze třídy ASP.NET stránky s kódem na pozadí použijte následující vzor:</span><span class="sxs-lookup"><span data-stu-id="0443a-141">To read and write to the data cache from an ASP.NET page s code-behind class, use the following pattern:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample1.vb)]

<span data-ttu-id="0443a-142">Metoda [`Cache` třídy](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [`Insert`](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) má mnoho přetížení.</span><span class="sxs-lookup"><span data-stu-id="0443a-142">The [`Cache` class](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [`Insert` method](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) has a number of overloads.</span></span> <span data-ttu-id="0443a-143">`Cache("key") = value` a `Cache.Insert(key, value)` jsou synonyma a obě do mezipaměti přidají položku pomocí zadaného klíče bez definovaného vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="0443a-143">`Cache("key") = value` and `Cache.Insert(key, value)` are synonymous and both add an item to the cache using the specified key without a defined expiry.</span></span> <span data-ttu-id="0443a-144">Obvykle chceme zadat vypršení platnosti při přidávání položky do mezipaměti, buď jako závislosti, vypršení časového limitu nebo obojího.</span><span class="sxs-lookup"><span data-stu-id="0443a-144">Typically, we want to specify an expiry when adding an item to the cache, either as a dependency, a time-based expiry, or both.</span></span> <span data-ttu-id="0443a-145">K poskytnutí informací o vypršení platnosti závislosti nebo času použijte jedno z dalších přetížení `Insert` metody.</span><span class="sxs-lookup"><span data-stu-id="0443a-145">Use one of the other `Insert` method s overloads to provide dependency- or time-based expiry information.</span></span>

<span data-ttu-id="0443a-146">Metody vrstev pro ukládání do mezipaměti musí nejdřív ověřit, jestli jsou požadovaná data v mezipaměti, a pokud ano, vrátí se z ní.</span><span class="sxs-lookup"><span data-stu-id="0443a-146">The Caching Layer s methods need to first check if the requested data is in the cache and, if so, return it from there.</span></span> <span data-ttu-id="0443a-147">Pokud požadovaná data nejsou v mezipaměti, musí být vyvolána odpovídající metoda knihoven BLL.</span><span class="sxs-lookup"><span data-stu-id="0443a-147">If the requested data is not in the cache, the appropriate BLL method needs to be invoked.</span></span> <span data-ttu-id="0443a-148">Návratová hodnota by měla být uložená v mezipaměti a pak se vrátila, jak ukazuje následující sekvenční diagram.</span><span class="sxs-lookup"><span data-stu-id="0443a-148">Its return value should be cached and then returned, as the following sequence diagram illustrates.</span></span>

![Metody ukládání vrstvy do mezipaměti vrací data z mezipaměti, pokud je k dispozici.](caching-data-in-the-architecture-vb/_static/image3.png)

<span data-ttu-id="0443a-150">**Obrázek 3**: metody vrstvy ukládání do mezipaměti vrací data z mezipaměti, pokud jsou k dispozici.</span><span class="sxs-lookup"><span data-stu-id="0443a-150">**Figure 3**: The Caching Layer s Methods Return Data from the Cache if it s Available</span></span>

<span data-ttu-id="0443a-151">Pořadí znázorněné na obrázku 3 je provedeno v třídách CL pomocí následujícího vzoru:</span><span class="sxs-lookup"><span data-stu-id="0443a-151">The sequence depicted in Figure 3 is accomplished in the CL classes using the following pattern:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample2.vb)]

<span data-ttu-id="0443a-152">Tady je *typ* dat ukládaných do mezipaměti `Northwind.ProductsDataTable`, například když *klíč* je klíč, který jedinečně identifikuje položku mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="0443a-152">Here, *Type* is the type of data being stored in the cache `Northwind.ProductsDataTable`, for example while *key* is the key that uniquely identifies the cache item.</span></span> <span data-ttu-id="0443a-153">Pokud položka se zadaným *klíčem* není v mezipaměti, pak se *instance* `Nothing` a data se načtou z příslušné metody knihoven BLL a přidají se do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="0443a-153">If the item with the specified *key* is not in the cache, then *instance* will be `Nothing` and the data will be retrieved from the appropriate BLL method and added to the cache.</span></span> <span data-ttu-id="0443a-154">Při dosažení `Return instance` *instance* obsahuje odkaz na data, buď z mezipaměti, nebo z knihoven BLL.</span><span class="sxs-lookup"><span data-stu-id="0443a-154">By the time `Return instance` is reached, *instance* contains a reference to the data, either from the cache or pulled from the BLL.</span></span>

<span data-ttu-id="0443a-155">Při přístupu k datům z mezipaměti nezapomeňte použít výše uvedený vzor.</span><span class="sxs-lookup"><span data-stu-id="0443a-155">Be sure to use the above pattern when accessing data from the cache.</span></span> <span data-ttu-id="0443a-156">Následující vzor, který je na první pohled, vypadá jako ekvivalent, obsahuje drobný rozdíl, který představuje podmínku časování.</span><span class="sxs-lookup"><span data-stu-id="0443a-156">The following pattern, which, at first glance, looks equivalent, contains a subtle difference that introduces a race condition.</span></span> <span data-ttu-id="0443a-157">Konflikty časování je obtížné ladit, protože se odhalují zřídka a je obtížné je reprodukována.</span><span class="sxs-lookup"><span data-stu-id="0443a-157">Race conditions are difficult to debug because they reveal themselves sporadically and are difficult to reproduce.</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample3.vb)]

<span data-ttu-id="0443a-158">Rozdíl v této druhé, nesprávný fragment kódu je místo uložení odkazu na položku v mezipaměti v místní proměnné, k datové mezipaměti se dostanete přímo v podmíněném příkazu *a* v `Return`.</span><span class="sxs-lookup"><span data-stu-id="0443a-158">The difference in this second, incorrect code snippet is that rather than storing a reference to the cached item in a local variable, the data cache is accessed directly in the conditional statement *and* in the `Return`.</span></span> <span data-ttu-id="0443a-159">Představte si, že po dosažení tohoto kódu `Cache("key")` není `Nothing`, ale před dosažením příkazu `Return` systém vyloučí *klíč* z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="0443a-159">Imagine that when this code is reached, `Cache("key")` is not `Nothing`, but before the `Return` statement is reached, the system evicts *key* from the cache.</span></span> <span data-ttu-id="0443a-160">V takovém případě bude kód vracet `Nothing` spíše než objekt očekávaného typu.</span><span class="sxs-lookup"><span data-stu-id="0443a-160">In this rare case, the code will return `Nothing` rather than an object of the expected type.</span></span>

> [!NOTE]
> <span data-ttu-id="0443a-161">Mezipaměť dat je bezpečná pro přístup z více vláken, takže nemusíte synchronizovat přístup k vláknům pro jednoduché čtení nebo zápisy.</span><span class="sxs-lookup"><span data-stu-id="0443a-161">The data cache is thread-safe, so you don't need to synchronize thread access for simple reads or writes.</span></span> <span data-ttu-id="0443a-162">Pokud ale potřebujete provést více operací s daty v mezipaměti, které je potřeba atomicky, zodpovídáte za implementaci zámku nebo nějakého jiného mechanismu, abyste zajistili bezpečnost vlákna.</span><span class="sxs-lookup"><span data-stu-id="0443a-162">However, if you need to perform multiple operations on data in the cache that need to be atomic, you are responsible for implementing a lock or some other mechanism to ensure thread safety.</span></span> <span data-ttu-id="0443a-163">Další informace najdete v tématu [synchronizace přístupu ke službě ASP.NET Cache](http://www.ddj.com/184406369) .</span><span class="sxs-lookup"><span data-stu-id="0443a-163">See [Synchronizing Access to the ASP.NET Cache](http://www.ddj.com/184406369) for more information.</span></span>

<span data-ttu-id="0443a-164">Položka může být programově vyřazena z mezipaměti dat pomocí [metody`Remove`](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) , například takto:</span><span class="sxs-lookup"><span data-stu-id="0443a-164">An item can be programmatically evicted from the data cache using the [`Remove` method](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) like so:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample4.vb)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a><span data-ttu-id="0443a-165">Krok 3: vrácení informací o produktu z`ProductsCL`třídy</span><span class="sxs-lookup"><span data-stu-id="0443a-165">Step 3: Returning Product Information from the`ProductsCL`Class</span></span>

<span data-ttu-id="0443a-166">Pro tento kurz umožňuje implementovat dvě metody pro vracení informací o produktu z `ProductsCL` třídy: `GetProducts()` a `GetProductsByCategoryID(categoryID)`.</span><span class="sxs-lookup"><span data-stu-id="0443a-166">For this tutorial let s implement two methods for returning product information from the `ProductsCL` class: `GetProducts()` and `GetProductsByCategoryID(categoryID)`.</span></span> <span data-ttu-id="0443a-167">Podobně jako u `ProductsBL` třídy v vrstvě obchodní logiky metoda `GetProducts()` v CL vrátí informace o všech produktech jako objekt `Northwind.ProductsDataTable`, zatímco `GetProductsByCategoryID(categoryID)` vrátí všechny produkty ze zadané kategorie.</span><span class="sxs-lookup"><span data-stu-id="0443a-167">Like with the `ProductsBL` class in the Business Logic Layer, the `GetProducts()` method in the CL returns information about all of the products as a `Northwind.ProductsDataTable` object, while `GetProductsByCategoryID(categoryID)` returns all of the products from a specified category.</span></span>

<span data-ttu-id="0443a-168">Následující kód ukazuje část metod v `ProductsCL` třídy:</span><span class="sxs-lookup"><span data-stu-id="0443a-168">The following code shows a portion of the methods in the `ProductsCL` class:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample5.vb)]

<span data-ttu-id="0443a-169">Nejprve si poznamenejte atributy `DataObject` a `DataObjectMethodAttribute` použité pro třídu a metody.</span><span class="sxs-lookup"><span data-stu-id="0443a-169">First, note the `DataObject` and `DataObjectMethodAttribute` attributes applied to the class and methods.</span></span> <span data-ttu-id="0443a-170">Tyto atributy poskytují informace průvodci ObjectDataSource s, který označuje, jaké třídy a metody by se měly zobrazit v krocích průvodce s.</span><span class="sxs-lookup"><span data-stu-id="0443a-170">These attributes provide information to the ObjectDataSource s wizard, indicating what classes and methods should appear in the wizard s steps.</span></span> <span data-ttu-id="0443a-171">Vzhledem k tomu, že třídy CL a metody budou k dispozici z prvku ObjectDataSource v prezentační vrstvě, byly přidány tyto atributy pro zlepšení prostředí v době návrhu.</span><span class="sxs-lookup"><span data-stu-id="0443a-171">Since the CL classes and methods will be accessed from an ObjectDataSource in the Presentation Layer, I added these attributes to enhance the design-time experience.</span></span> <span data-ttu-id="0443a-172">Přečtěte si kurz [Vytvoření vrstvy obchodní logiky](../introduction/creating-a-business-logic-layer-vb.md) a podrobnější popis těchto atributů a jejich efektů.</span><span class="sxs-lookup"><span data-stu-id="0443a-172">Refer back to the [Creating a Business Logic Layer](../introduction/creating-a-business-logic-layer-vb.md) tutorial for a more thorough description on these attributes and their effects.</span></span>

<span data-ttu-id="0443a-173">V metodách `GetProducts()` a `GetProductsByCategoryID(categoryID)` je data vrácená z metody `GetCacheItem(key)` přiřazena místní proměnné.</span><span class="sxs-lookup"><span data-stu-id="0443a-173">In the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods, the data returned from the `GetCacheItem(key)` method is assigned to a local variable.</span></span> <span data-ttu-id="0443a-174">Metoda `GetCacheItem(key)`, kterou prověříme krátce, vrátí konkrétní položku z mezipaměti na základě zadaného *klíče*.</span><span class="sxs-lookup"><span data-stu-id="0443a-174">The `GetCacheItem(key)` method, which we'll examine shortly, returns a particular item from the cache based on the specified *key*.</span></span> <span data-ttu-id="0443a-175">Pokud nejsou taková data v mezipaměti nalezena, jsou načtena z odpovídající metody třídy `ProductsBLL` a poté přidány do mezipaměti pomocí metody `AddCacheItem(key, value)`.</span><span class="sxs-lookup"><span data-stu-id="0443a-175">If no such data is found in cache, it is retrieved from the corresponding `ProductsBLL` class method and then added to the cache using the `AddCacheItem(key, value)` method.</span></span>

<span data-ttu-id="0443a-176">Rozhraní metody `GetCacheItem(key)` a `AddCacheItem(key, value)` s mezipamětí dat, čtení a zápis hodnot v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="0443a-176">The `GetCacheItem(key)` and `AddCacheItem(key, value)` methods interface with the data cache, reading and writing values, respectively.</span></span> <span data-ttu-id="0443a-177">Metoda `GetCacheItem(key)` je jednodušší z těchto dvou.</span><span class="sxs-lookup"><span data-stu-id="0443a-177">The `GetCacheItem(key)` method is the simpler of the two.</span></span> <span data-ttu-id="0443a-178">Jednoduše vrátí hodnotu z třídy Cache pomocí *klíče*předaného:</span><span class="sxs-lookup"><span data-stu-id="0443a-178">It simply returns the value from the Cache class using the passed-in *key*:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample6.vb)]

<span data-ttu-id="0443a-179">`GetCacheItem(key)` nepoužívá hodnotu *klíče* jako dodané, ale místo toho volá metodu `GetCacheKey(key)`, která vrací *klíč* , který je v ProductsCache-.</span><span class="sxs-lookup"><span data-stu-id="0443a-179">`GetCacheItem(key)` does not use *key* value as supplied, but instead calls the `GetCacheKey(key)` method, which returns the *key* prepended with ProductsCache-.</span></span> <span data-ttu-id="0443a-180">`MasterCacheKeyArray`, která obsahuje řetězec ProductsCache, je také používána metodou `AddCacheItem(key, value)`, jak uvidíme za chvíli.</span><span class="sxs-lookup"><span data-stu-id="0443a-180">The `MasterCacheKeyArray`, which holds the string ProductsCache, is also used by the `AddCacheItem(key, value)` method, as we'll see momentarily.</span></span>

<span data-ttu-id="0443a-181">Z třídy ASP.NET s kódem na pozadí lze mezipaměť dat použít pomocí vlastnosti `Page` třídy s [`Cache`](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)a umožňuje syntaxi jako `Cache("key") = value`, jak je popsáno v kroku 2.</span><span class="sxs-lookup"><span data-stu-id="0443a-181">From an ASP.NET page s code-behind class, the data cache can be accessed using the `Page` class s [`Cache` property](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx), and allows for syntax like `Cache("key") = value`, as discussed in Step 2.</span></span> <span data-ttu-id="0443a-182">Z třídy v rámci architektury je k datové mezipaměti možné přistupovat buď pomocí `HttpRuntime.Cache`, nebo `HttpContext.Current.Cache`.</span><span class="sxs-lookup"><span data-stu-id="0443a-182">From a class within the architecture, the data cache can be accessed using either `HttpRuntime.Cache` or `HttpContext.Current.Cache`.</span></span> <span data-ttu-id="0443a-183">Seznámení s modulem pro zápis na blogu [Johnsonem](https://weblogs.asp.net/pjohnson/default.aspx) [. cache vs. HttpContext. Current. cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) poznámky k mírnému využití výkonu při použití `HttpRuntime` místo `HttpContext.Current`; v důsledku toho `ProductsCL` používá `HttpRuntime`.</span><span class="sxs-lookup"><span data-stu-id="0443a-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)'s blog entry [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) notes the slight performance advantage in using `HttpRuntime` instead of `HttpContext.Current`; consequently, `ProductsCL` uses `HttpRuntime`.</span></span>

> [!NOTE]
> <span data-ttu-id="0443a-184">Pokud je vaše architektura implementována pomocí projektů knihovny tříd, budete muset přidat odkaz na `System.Web` sestavení, aby bylo možné použít třídy [`HttpRuntime`](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) a [`HttpContext`](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) .</span><span class="sxs-lookup"><span data-stu-id="0443a-184">If your architecture is implemented using Class Library projects then you will need to add a reference to the `System.Web` assembly in order to use the [`HttpRuntime`](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) and [`HttpContext`](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) classes.</span></span>

<span data-ttu-id="0443a-185">Pokud se položka v mezipaměti nenajde, metody `ProductsCL` třídy s získají data z knihoven BLL a do mezipaměti přidáte pomocí metody `AddCacheItem(key, value)`.</span><span class="sxs-lookup"><span data-stu-id="0443a-185">If the item is not found in the cache, the `ProductsCL` class s methods get the data from the BLL and add it to the cache using the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="0443a-186">K přidání *hodnoty* do mezipaměti můžeme použít následující kód, který používá vypršení druhé doby 60:</span><span class="sxs-lookup"><span data-stu-id="0443a-186">To add *value* to the cache we could use the following code, which uses a 60 second time expiry:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample7.vb)]

<span data-ttu-id="0443a-187">`DateTime.Now.AddSeconds(CacheDuration)` určuje časový limit vypršení platnosti 60 sekund v budoucnosti, zatímco [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) označuje, že neexistují žádné klouzavé vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="0443a-187">`DateTime.Now.AddSeconds(CacheDuration)` specifies the time-based expiry 60 seconds in the future while [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) indicates that there s no sliding expiration.</span></span> <span data-ttu-id="0443a-188">I když toto přetížení `Insert` metody obsahuje vstupní parametry pro absolutní i klouzavé vypršení platnosti, můžete zadat pouze jednu z těchto dvou.</span><span class="sxs-lookup"><span data-stu-id="0443a-188">While this `Insert` method overload has input parameters for both an absolute and sliding expiry, you can only provide one of the two.</span></span> <span data-ttu-id="0443a-189">Pokud se pokusíte zadat absolutní a časový rozsah, metoda `Insert` vyvolá výjimku `ArgumentException`.</span><span class="sxs-lookup"><span data-stu-id="0443a-189">If you attempt to specify both an absolute time and a time span, the `Insert` method will throw an `ArgumentException` exception.</span></span>

> [!NOTE]
> <span data-ttu-id="0443a-190">Tato implementace metody `AddCacheItem(key, value)` v současnosti obsahuje nějaké nedostatky.</span><span class="sxs-lookup"><span data-stu-id="0443a-190">This implementation of the `AddCacheItem(key, value)` method currently has some shortcomings.</span></span> <span data-ttu-id="0443a-191">Tyto problémy budeme řešit a překonat v kroku 4.</span><span class="sxs-lookup"><span data-stu-id="0443a-191">We'll address and overcome these issues in Step 4.</span></span>

## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a><span data-ttu-id="0443a-192">Krok 4: zrušení platnosti mezipaměti při změně dat pomocí architektury</span><span class="sxs-lookup"><span data-stu-id="0443a-192">Step 4: Invalidating the Cache When the Data is Modified Through the Architecture</span></span>

<span data-ttu-id="0443a-193">Spolu s metodami načítání dat musí vrstva ukládání do mezipaměti poskytovat stejné metody jako knihoven BLL pro vkládání, aktualizaci a odstraňování dat.</span><span class="sxs-lookup"><span data-stu-id="0443a-193">Along with data retrieval methods, the Caching Layer needs to provide the same methods as the BLL for inserting, updating, and deleting data.</span></span> <span data-ttu-id="0443a-194">Metody změny dat CL. nemění data uložená v mezipaměti, ale místo toho volají knihoven BLL s odpovídající metodou změny dat a pak neověřuje mezipaměť.</span><span class="sxs-lookup"><span data-stu-id="0443a-194">The CL s data modification methods do not modify the cached data, but rather call the BLL s corresponding data modification method and then invalidate the cache.</span></span> <span data-ttu-id="0443a-195">Jak jsme viděli v předchozím kurzu, jedná se o stejné chování, které prvek ObjectDataSource použije, když jsou povolené jeho funkce ukládání do mezipaměti a jsou vyvolány `Insert`, `Update`nebo `Delete` metody.</span><span class="sxs-lookup"><span data-stu-id="0443a-195">As we saw in the preceding tutorial, this is the same behavior that the ObjectDataSource applies when its caching features are enabled and its `Insert`, `Update`, or `Delete` methods are invoked.</span></span>

<span data-ttu-id="0443a-196">Následující přetížení `UpdateProduct` ukazuje, jak implementovat metody změny dat v CL:</span><span class="sxs-lookup"><span data-stu-id="0443a-196">The following `UpdateProduct` overload illustrates how to implement the data modification methods in the CL:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample8.vb)]

<span data-ttu-id="0443a-197">Je vyvolána vhodná metoda vrstvy pro úpravu dat, ale předtím, než se vrátí jeho odpověď, musíme tuto mezipaměť znehodnotit.</span><span class="sxs-lookup"><span data-stu-id="0443a-197">The appropriate data modification Business Logic Layer method is invoked, but before its response is returned we need to invalidate the cache.</span></span> <span data-ttu-id="0443a-198">Neověřování mezipaměti bohužel není jednoduché, protože `ProductsCL` třídy s `GetProducts()` a `GetProductsByCategoryID(categoryID)` metody každý přidávají položky do mezipaměti s různými klíči a metoda `GetProductsByCategoryID(categoryID)` pro každou jedinečnou hodnotu *KódKategorie*přidá jinou položku mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="0443a-198">Unfortunately, invalidating the cache is not straightforward because the `ProductsCL` class s `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods each add items to the cache with different keys, and the `GetProductsByCategoryID(categoryID)` method adds a different cache item for each unique *categoryID*.</span></span>

<span data-ttu-id="0443a-199">Při devalidaci mezipaměti musíme odebrat *všechny* položky, které mohou být přidány třídou `ProductsCL`.</span><span class="sxs-lookup"><span data-stu-id="0443a-199">When invalidating the cache, we need to remove *all* of the items that may have been added by the `ProductsCL` class.</span></span> <span data-ttu-id="0443a-200">To lze provést přidružením *závislosti mezipaměti* ke každé položce přidané do mezipaměti v metodě `AddCacheItem(key, value)`.</span><span class="sxs-lookup"><span data-stu-id="0443a-200">This can be accomplished by associating a *cache dependency* with the each item added to the cache in the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="0443a-201">V zásadě může být závislost mezipaměti jinou položkou v mezipaměti, souborem v systému souborů nebo daty z databáze Microsoft SQL Server.</span><span class="sxs-lookup"><span data-stu-id="0443a-201">In general, a cache dependency can be another item in the cache, a file on the file system, or data from a Microsoft SQL Server database.</span></span> <span data-ttu-id="0443a-202">Když se závislost změní nebo odebere z mezipaměti, položky mezipaměti, ke kterým je přidružená, se automaticky vyloučí z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="0443a-202">When the dependency changes or is removed from the cache, the cache items it is associated with are automatically evicted from the cache.</span></span> <span data-ttu-id="0443a-203">Pro tento kurz chceme v mezipaměti vytvořit další položku, která slouží jako závislost mezipaměti pro všechny položky přidané prostřednictvím třídy `ProductsCL`.</span><span class="sxs-lookup"><span data-stu-id="0443a-203">For this tutorial, we want to create an additional item in the cache that serves as a cache dependency for all items added through the `ProductsCL` class.</span></span> <span data-ttu-id="0443a-204">Tímto způsobem lze z mezipaměti odebrat všechny tyto položky pouhým odebráním závislosti mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="0443a-204">That way, all of these items can be removed from the cache by simply removing the cache dependency.</span></span>

<span data-ttu-id="0443a-205">Aktualizujte metodu `AddCacheItem(key, value)` tak, aby se všechny položky přidané do mezipaměti prostřednictvím této metody přidružil k závislosti jedné mezipaměti:</span><span class="sxs-lookup"><span data-stu-id="0443a-205">Let s update the `AddCacheItem(key, value)` method so that each item added to the cache through this method is associated with a single cache dependency:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample9.vb)]

<span data-ttu-id="0443a-206">`MasterCacheKeyArray` je pole řetězců, které obsahuje jednu hodnotu ProductsCache.</span><span class="sxs-lookup"><span data-stu-id="0443a-206">`MasterCacheKeyArray` is a string array that holds a single value, ProductsCache.</span></span> <span data-ttu-id="0443a-207">Nejprve se položka mezipaměti přidá do mezipaměti a přiřadí se aktuální datum a čas.</span><span class="sxs-lookup"><span data-stu-id="0443a-207">First, a cache item is added to the cache and assigned the current date and time.</span></span> <span data-ttu-id="0443a-208">Pokud položka mezipaměti již existuje, je aktualizována.</span><span class="sxs-lookup"><span data-stu-id="0443a-208">If the cache item already exists, it is updated.</span></span> <span data-ttu-id="0443a-209">V dalším kroku se vytvoří závislost mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="0443a-209">Next, a cache dependency is created.</span></span> <span data-ttu-id="0443a-210">Konstruktor [`CacheDependency` třídy](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s má několik přetížení, ale ta, která se používá tady, očekává dva vstupy `String` pole.</span><span class="sxs-lookup"><span data-stu-id="0443a-210">The [`CacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s constructor has a number of overloads, but the one being used in here expects two `String` array inputs.</span></span> <span data-ttu-id="0443a-211">První z nich určuje sadu souborů, které mají být použity jako závislosti.</span><span class="sxs-lookup"><span data-stu-id="0443a-211">The first one specifies the set of files to be used as dependencies.</span></span> <span data-ttu-id="0443a-212">Vzhledem k tomu, že nechceme použít žádné závislosti založené na souborech, je pro první vstupní parametr použita hodnota `Nothing`.</span><span class="sxs-lookup"><span data-stu-id="0443a-212">Since we don t want to use any file-based dependencies, a value of `Nothing` is used for the first input parameter.</span></span> <span data-ttu-id="0443a-213">Druhý vstupní parametr určuje sadu klíčů mezipaměti, které se mají použít jako závislosti.</span><span class="sxs-lookup"><span data-stu-id="0443a-213">The second input parameter specifies the set of cache keys to use as dependencies.</span></span> <span data-ttu-id="0443a-214">Tady určíme naši jedinou závislost `MasterCacheKeyArray`.</span><span class="sxs-lookup"><span data-stu-id="0443a-214">Here we specify our single dependency, `MasterCacheKeyArray`.</span></span> <span data-ttu-id="0443a-215">`CacheDependency` pak předává do metody `Insert`.</span><span class="sxs-lookup"><span data-stu-id="0443a-215">The `CacheDependency` is then passed into the `Insert` method.</span></span>

<span data-ttu-id="0443a-216">S touto úpravou `AddCacheItem(key, value)`je zrušení platnosti mezipaměti stejně jednoduché jako odebrání závislosti.</span><span class="sxs-lookup"><span data-stu-id="0443a-216">With this modification to `AddCacheItem(key, value)`, invaliding the cache is as simple as removing the dependency.</span></span>

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample10.vb)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a><span data-ttu-id="0443a-217">Krok 5: volání vrstvy ukládání do mezipaměti z prezentační vrstvy</span><span class="sxs-lookup"><span data-stu-id="0443a-217">Step 5: Calling the Caching Layer from the Presentation Layer</span></span>

<span data-ttu-id="0443a-218">Třídy a metody pro ukládání do mezipaměti lze použít pro práci s daty pomocí technik, které jsme prozkoumali v těchto kurzech.</span><span class="sxs-lookup"><span data-stu-id="0443a-218">The Caching Layer s classes and methods can be used to work with data using the techniques we ve examined throughout these tutorials.</span></span> <span data-ttu-id="0443a-219">Chcete-li znázornit práci s daty uloženými v mezipaměti, uložte změny do třídy `ProductsCL` a poté otevřete stránku `FromTheArchitecture.aspx` ve složce `Caching` a přidejte prvek GridView.</span><span class="sxs-lookup"><span data-stu-id="0443a-219">To illustrate working with cached data, save your changes to the `ProductsCL` class and then open the `FromTheArchitecture.aspx` page in the `Caching` folder and add a GridView.</span></span> <span data-ttu-id="0443a-220">Z inteligentní značky GridView s vytvořte nový prvek ObjectDataSource.</span><span class="sxs-lookup"><span data-stu-id="0443a-220">From the GridView s smart tag, create a new ObjectDataSource.</span></span> <span data-ttu-id="0443a-221">V prvním kroku průvodce s byste měli vidět třídu `ProductsCL` jako jednu z možností z rozevíracího seznamu.</span><span class="sxs-lookup"><span data-stu-id="0443a-221">In the wizard s first step you should see the `ProductsCL` class as one of the options from the drop-down list.</span></span>

<span data-ttu-id="0443a-222">[![třída ProductsCL je obsažena v rozevíracím seznamu obchodních objektů.](caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="0443a-222">[![The ProductsCL Class is Included in the Business Object Drop-Down List](caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)</span></span>

<span data-ttu-id="0443a-223">**Obrázek 4**: třída `ProductsCL` je obsažena v rozevíracím seznamu obchodních objektů ([kliknutím zobrazíte obrázek v plné velikosti](caching-data-in-the-architecture-vb/_static/image6.png)).</span><span class="sxs-lookup"><span data-stu-id="0443a-223">**Figure 4**: The `ProductsCL` Class is Included in the Business Object Drop-Down List ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image6.png))</span></span>

<span data-ttu-id="0443a-224">Po výběru `ProductsCL`klikněte na další.</span><span class="sxs-lookup"><span data-stu-id="0443a-224">After selecting `ProductsCL`, click Next.</span></span> <span data-ttu-id="0443a-225">Rozevírací seznam na kartě vybrat má dvě položky – `GetProducts()` a `GetProductsByCategoryID(categoryID)` a karta aktualizace má jediné `UpdateProduct` přetížení.</span><span class="sxs-lookup"><span data-stu-id="0443a-225">The drop-down list in the SELECT tab has two items - `GetProducts()` and `GetProductsByCategoryID(categoryID)` and the UPDATE tab has the sole `UpdateProduct` overload.</span></span> <span data-ttu-id="0443a-226">Vyberte metodu `GetProducts()` z karty vybrat a `UpdateProducts` metodou na kartě aktualizace a klikněte na Dokončit.</span><span class="sxs-lookup"><span data-stu-id="0443a-226">Choose the `GetProducts()` method from the SELECT tab and the `UpdateProducts` method from the UPDATE tab and click Finish.</span></span>

<span data-ttu-id="0443a-227">[![metody třídy s ProductsCL jsou uvedené v rozevíracích seznamech.](caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="0443a-227">[![The ProductsCL Class s Methods are Listed in the Drop-Down Lists](caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)</span></span>

<span data-ttu-id="0443a-228">**Obrázek 5**: metody třídy `ProductsCL` jsou uvedeny v rozevíracích seznamech ([kliknutím zobrazíte obrázek v plné velikosti](caching-data-in-the-architecture-vb/_static/image9.png)).</span><span class="sxs-lookup"><span data-stu-id="0443a-228">**Figure 5**: The `ProductsCL` Class s Methods are Listed in the Drop-Down Lists ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image9.png))</span></span>

<span data-ttu-id="0443a-229">Po dokončení průvodce nastaví Visual Studio vlastnost ObjectDataSource `OldValuesParameterFormatString` na `original_{0}` a přidá příslušná pole do prvku GridView.</span><span class="sxs-lookup"><span data-stu-id="0443a-229">After completing the wizard, Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}` and add the appropriate fields to the GridView.</span></span> <span data-ttu-id="0443a-230">Změňte vlastnost `OldValuesParameterFormatString` zpět na její výchozí hodnotu, `{0}`a nakonfigurujte prvek GridView tak, aby podporoval stránkování, řazení a úpravy.</span><span class="sxs-lookup"><span data-stu-id="0443a-230">Change the `OldValuesParameterFormatString` property back to its default value, `{0}`, and configure the GridView to support paging, sorting, and editing.</span></span> <span data-ttu-id="0443a-231">Vzhledem k tomu, že přetížení `UploadProducts` používané v CL přijme pouze upravený název produktu a cenu, omezí prvek GridView tak, aby byla pouze tato pole upravitelná.</span><span class="sxs-lookup"><span data-stu-id="0443a-231">Since the `UploadProducts` overload used by the CL accepts only the edited product s name and price, limit the GridView so that only these fields are editable.</span></span>

<span data-ttu-id="0443a-232">V předchozím kurzu jsme definovali prvek GridView, který bude obsahovat pole pro pole `ProductName`, `CategoryName`a `UnitPrice`.</span><span class="sxs-lookup"><span data-stu-id="0443a-232">In the preceding tutorial we defined a GridView to include fields for the `ProductName`, `CategoryName`, and `UnitPrice` fields.</span></span> <span data-ttu-id="0443a-233">Chcete-li replikovat toto formátování a strukturu, v takovém případě by deklarativní označení prvku GridView a ObjectDataSource s mělo vypadat podobně jako v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="0443a-233">Feel free to replicate this formatting and structure, in which case your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](caching-data-in-the-architecture-vb/samples/sample11.aspx)]

<span data-ttu-id="0443a-234">V tuto chvíli máme stránku, která používá vrstvu ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="0443a-234">At this point we have a page that uses the Caching Layer.</span></span> <span data-ttu-id="0443a-235">Chcete-li zobrazit mezipaměť v akci, nastavte zarážky v `ProductsCL` třídy s `GetProducts()` a metody `UpdateProduct`.</span><span class="sxs-lookup"><span data-stu-id="0443a-235">To see the cache in action, set breakpoints in the `ProductsCL` class s `GetProducts()` and `UpdateProduct` methods.</span></span> <span data-ttu-id="0443a-236">Přejděte na stránku v prohlížeči a procházejte kódem při řazení a stránkování, aby se zobrazila data získaná z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="0443a-236">Visit the page in a browser and step through the code when sorting and paging in order to see the data pulled from the cache.</span></span> <span data-ttu-id="0443a-237">Pak aktualizujte záznam a Všimněte si, že mezipaměť je neověřená a v důsledku toho se načte z knihoven BLL při převázání dat na prvek GridView.</span><span class="sxs-lookup"><span data-stu-id="0443a-237">Then update a record and note that the cache is invalidated and, consequently, it is retrieved from the BLL when the data is rebound to the GridView.</span></span>

> [!NOTE]
> <span data-ttu-id="0443a-238">Vrstva ukládání do mezipaměti uvedená v tomto článku ke stažení, která je přiložena k tomuto článku, není dokončena.</span><span class="sxs-lookup"><span data-stu-id="0443a-238">The Caching Layer provided in the download accompanying this article is not complete.</span></span> <span data-ttu-id="0443a-239">Obsahuje pouze jednu třídu, `ProductsCL`, která pouze sport několik metody.</span><span class="sxs-lookup"><span data-stu-id="0443a-239">It contains only one class, `ProductsCL`, which only sports a handful of methods.</span></span> <span data-ttu-id="0443a-240">Kromě toho pouze jedna stránka ASP.NET používá CL (`~/Caching/FromTheArchitecture.aspx`) všichni ostatní, stále na knihoven BLL odkazují přímo.</span><span class="sxs-lookup"><span data-stu-id="0443a-240">Moreover, only a single ASP.NET page uses the CL (`~/Caching/FromTheArchitecture.aspx`) all others still reference the BLL directly.</span></span> <span data-ttu-id="0443a-241">Pokud plánujete použití CL ve vaší aplikaci, všechna volání z prezentační vrstvy by měla přejít na CL, což by vyžadovalo, aby se třídy CL a metody pokryly s těmito třídami a metodami v knihoven BLL aktuálně používané prezentační vrstvou.</span><span class="sxs-lookup"><span data-stu-id="0443a-241">If you plan on using a CL in your application, all calls from the Presentation Layer should go to the CL, which would require that the CL s classes and methods covered those classes and methods in the BLL currently used by the Presentation Layer.</span></span>

## <a name="summary"></a><span data-ttu-id="0443a-242">Souhrn</span><span class="sxs-lookup"><span data-stu-id="0443a-242">Summary</span></span>

<span data-ttu-id="0443a-243">I když lze ukládání do mezipaměti použít v prezentační vrstvě pomocí ovládacích prvků ASP.NET 2,0 s SqlDataSource a ObjectDataSource, v ideálním případě by se odpovědnosti do mezipaměti přenesly na samostatnou vrstvu v architektuře.</span><span class="sxs-lookup"><span data-stu-id="0443a-243">While caching can be applied at the Presentation Layer with ASP.NET 2.0 s SqlDataSource and ObjectDataSource controls, ideally caching responsibilities would be delegated to a separate layer in the architecture.</span></span> <span data-ttu-id="0443a-244">V tomto kurzu jsme vytvořili vrstvu ukládání do mezipaměti, která se nachází mezi prezentační vrstvou a vrstvou obchodní logiky.</span><span class="sxs-lookup"><span data-stu-id="0443a-244">In this tutorial we created a Caching Layer that resides between the Presentation Layer and the Business Logic Layer.</span></span> <span data-ttu-id="0443a-245">Vrstva ukládání do mezipaměti musí poskytovat stejnou sadu tříd a metod, které existují v knihoven BLL a jsou volány z prezentační vrstvy.</span><span class="sxs-lookup"><span data-stu-id="0443a-245">The Caching Layer needs to provide the same set of classes and methods that exist in the BLL and are called from the Presentation Layer.</span></span>

<span data-ttu-id="0443a-246">Příklady vrstev do mezipaměti, které jsme prozkoumali a v předchozích kurzech se projeví *reaktivní načítání*.</span><span class="sxs-lookup"><span data-stu-id="0443a-246">The Caching Layer examples we explored in this and the preceding tutorials exhibited *reactive loading*.</span></span> <span data-ttu-id="0443a-247">Při reaktivním načítání se data načtou do mezipaměti jenom v případě, že se vytvoří požadavek na data a v mezipaměti chybí data.</span><span class="sxs-lookup"><span data-stu-id="0443a-247">With reactive loading, the data is loaded into the cache only when a request for the data is made and that data is missing from the cache.</span></span> <span data-ttu-id="0443a-248">Data je také možné *aktivně načíst* do mezipaměti, což je technika, která načte data do mezipaměti, než je skutečně potřeba.</span><span class="sxs-lookup"><span data-stu-id="0443a-248">Data can also be *proactively loaded* into the cache, a technique that loads the data into the cache before it is actually needed.</span></span> <span data-ttu-id="0443a-249">V dalším kurzu uvidíme příklad proaktivní načítání, když se podíváme na to, jak ukládat statické hodnoty do mezipaměti při spuštění aplikace.</span><span class="sxs-lookup"><span data-stu-id="0443a-249">In the next tutorial we'll see an example of proactive loading when we look at how to store static values into the cache at application startup.</span></span>

<span data-ttu-id="0443a-250">Šťastné programování!</span><span class="sxs-lookup"><span data-stu-id="0443a-250">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="0443a-251">O autorovi</span><span class="sxs-lookup"><span data-stu-id="0443a-251">About the Author</span></span>

<span data-ttu-id="0443a-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), autor 7 ASP/ASP. NET Books a zakladatel of [4GuysFromRolla.com](http://www.4guysfromrolla.com), pracoval s webovými technologiemi Microsoftu od 1998.</span><span class="sxs-lookup"><span data-stu-id="0443a-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="0443a-253">Scott funguje jako nezávislý konzultant, Trainer a zapisovač.</span><span class="sxs-lookup"><span data-stu-id="0443a-253">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="0443a-254">Nejnovější kniha je [*Sams naučit se ASP.NET 2,0 za 24 hodin*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span><span class="sxs-lookup"><span data-stu-id="0443a-254">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="0443a-255">Dá se získat na [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="0443a-255">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="0443a-256">nebo prostřednictvím svého blogu, který najdete na adrese [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span><span class="sxs-lookup"><span data-stu-id="0443a-256">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="0443a-257">Zvláštní díky</span><span class="sxs-lookup"><span data-stu-id="0443a-257">Special Thanks To</span></span>

<span data-ttu-id="0443a-258">Tato řada kurzů byla přezkoumána mnoha užitečnými kontrolory.</span><span class="sxs-lookup"><span data-stu-id="0443a-258">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="0443a-259">Kontrolor pro tento kurz byl Teresa Murphy.</span><span class="sxs-lookup"><span data-stu-id="0443a-259">Lead reviewer for this tutorial was Teresa Murphy.</span></span> <span data-ttu-id="0443a-260">Uvažujete o přezkoumání mých nadcházejících článků na webu MSDN?</span><span class="sxs-lookup"><span data-stu-id="0443a-260">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="0443a-261">Pokud ano, vyřaďte mi řádek na [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="0443a-261">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="0443a-262">[Předchozí](caching-data-with-the-objectdatasource-vb.md)
> [Další](caching-data-at-application-startup-vb.md)</span><span class="sxs-lookup"><span data-stu-id="0443a-262">[Previous](caching-data-with-the-objectdatasource-vb.md)
[Next](caching-data-at-application-startup-vb.md)</span></span>
