---
uid: web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
title: Implementace optimistického řízení souběžnosti (C#) | Microsoft Docs
author: rick-anderson
description: U webové aplikace, která umožňuje více uživatelům upravovat data, existuje riziko, že dva uživatelé mohou současně upravovat stejná data. V tomto tutori...
ms.author: riande
ms.date: 07/17/2006
ms.assetid: 56e15b33-93b8-43ad-8e19-44c6647ea05c
msc.legacyurl: /web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
msc.type: authoredcontent
ms.openlocfilehash: 3cddb0efd28249ffc5708ece39c80581d078a5a2
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/28/2019
ms.locfileid: "74617486"
---
# <a name="implementing-optimistic-concurrency-c"></a><span data-ttu-id="566f2-104">Implementace optimistického řízení souběžnosti (C#)</span><span class="sxs-lookup"><span data-stu-id="566f2-104">Implementing Optimistic Concurrency (C#)</span></span>

<span data-ttu-id="566f2-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="566f2-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="566f2-106">[Stáhnout ukázkovou aplikaci](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_CS.exe) nebo [Stáhnout PDF](implementing-optimistic-concurrency-cs/_static/datatutorial21cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="566f2-106">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_CS.exe) or [Download PDF](implementing-optimistic-concurrency-cs/_static/datatutorial21cs1.pdf)</span></span>

> <span data-ttu-id="566f2-107">U webové aplikace, která umožňuje více uživatelům upravovat data, existuje riziko, že dva uživatelé mohou současně upravovat stejná data.</span><span class="sxs-lookup"><span data-stu-id="566f2-107">For a web application that allows multiple users to edit data, there is the risk that two users may be editing the same data at the same time.</span></span> <span data-ttu-id="566f2-108">V tomto kurzu implementujeme optimistické řízení souběžnosti pro zpracování tohoto rizika.</span><span class="sxs-lookup"><span data-stu-id="566f2-108">In this tutorial we'll implement optimistic concurrency control to handle this risk.</span></span>

## <a name="introduction"></a><span data-ttu-id="566f2-109">Úvod</span><span class="sxs-lookup"><span data-stu-id="566f2-109">Introduction</span></span>

<span data-ttu-id="566f2-110">U webových aplikací, které umožňují uživatelům pouze zobrazovat data nebo pro ty, které obsahují pouze jednoho uživatele, který může upravovat data, neexistuje hrozba dvou souběžných uživatelů, kteří by omylem přepsali nějaké další změny.</span><span class="sxs-lookup"><span data-stu-id="566f2-110">For web applications that only allow users to view data, or for those that include only a single user who can modify data, there's no threat of two concurrent users accidentally overwriting one another's changes.</span></span> <span data-ttu-id="566f2-111">U webových aplikací, které umožňují více uživatelům aktualizovat nebo odstraňovat data, je však možné, že změny jednoho uživatele v konfliktu s jiným souběžným uživatelem.</span><span class="sxs-lookup"><span data-stu-id="566f2-111">For web applications that allow multiple users to update or delete data, however, there's the potential for one user's modifications to clash with another concurrent user's.</span></span> <span data-ttu-id="566f2-112">Pokud neexistují žádné zásady souběžnosti, když dva uživatelé současně upravují jeden záznam, uživatel, který poslední změny potvrdí, přepíše změny provedené v prvním z nich.</span><span class="sxs-lookup"><span data-stu-id="566f2-112">Without any concurrency policy in place, when two users are simultaneously editing a single record, the user who commits her changes last will override the changes made by the first.</span></span>

<span data-ttu-id="566f2-113">Představte si například, že dva uživatelé, Jisun a Sam, navštívili stránku v naší aplikaci, která umožnila návštěvníkům aktualizovat a odstranit produkty prostřednictvím ovládacího prvku GridView.</span><span class="sxs-lookup"><span data-stu-id="566f2-113">For example, imagine that two users, Jisun and Sam, were both visiting a page in our application that allowed visitors to update and delete the products through a GridView control.</span></span> <span data-ttu-id="566f2-114">Obě klikněte na tlačítko Upravit v prvku GridView kolem stejného času.</span><span class="sxs-lookup"><span data-stu-id="566f2-114">Both click the Edit button in the GridView around the same time.</span></span> <span data-ttu-id="566f2-115">Jisun změní název produktu na "Chai čaj" a klikne na tlačítko Aktualizovat.</span><span class="sxs-lookup"><span data-stu-id="566f2-115">Jisun changes the product name to "Chai Tea" and clicks the Update button.</span></span> <span data-ttu-id="566f2-116">Čistým výsledkem je příkaz `UPDATE`, který se pošle do databáze, která nastaví *všechna* pole s aktualizovatelným produktem (i když Jisun aktualizuje jenom jedno pole `ProductName`).</span><span class="sxs-lookup"><span data-stu-id="566f2-116">The net result is an `UPDATE` statement that is sent to the database, which sets *all* of the product's updateable fields (even though Jisun only updated one field, `ProductName`).</span></span> <span data-ttu-id="566f2-117">V tomto okamžiku má databáze hodnoty "Chai čaj", "kategorie nápoje, exotické kapaliny dodavatele a tak dále pro tento konkrétní produkt.</span><span class="sxs-lookup"><span data-stu-id="566f2-117">At this point in time, the database has the values "Chai Tea," the category Beverages, the supplier Exotic Liquids, and so on for this particular product.</span></span> <span data-ttu-id="566f2-118">Ale v prvku GridView na obrazovce Sam se stále zobrazuje název produktu v upravitelném řádku GridView jako "Chai".</span><span class="sxs-lookup"><span data-stu-id="566f2-118">However, the GridView on Sam's screen still shows the product name in the editable GridView row as "Chai".</span></span> <span data-ttu-id="566f2-119">Několik sekund po potvrzení změn Jisun aktualizuje správce Sam kategorii na koření a klikne na aktualizovat.</span><span class="sxs-lookup"><span data-stu-id="566f2-119">A few seconds after Jisun's changes have been committed, Sam updates the category to Condiments and clicks Update.</span></span> <span data-ttu-id="566f2-120">Výsledkem je příkaz `UPDATE` odeslaný do databáze, která nastaví název produktu na "Chai", `CategoryID` na odpovídající ID kategorie nápojů atd.</span><span class="sxs-lookup"><span data-stu-id="566f2-120">This results in an `UPDATE` statement sent to the database that sets the product name to "Chai," the `CategoryID` to the corresponding Beverages category ID, and so on.</span></span> <span data-ttu-id="566f2-121">Změny názvu produktu Jisun byly přepsány.</span><span class="sxs-lookup"><span data-stu-id="566f2-121">Jisun's changes to the product name have been overwritten.</span></span> <span data-ttu-id="566f2-122">Obrázek 1 graficky znázorňuje tuto řadu událostí.</span><span class="sxs-lookup"><span data-stu-id="566f2-122">Figure 1 graphically depicts this series of events.</span></span>

<span data-ttu-id="566f2-123">[![, když dva uživatelé současně aktualizují záznam, u kterých se může změnit jeden uživatel a přepsat ostatní s.](implementing-optimistic-concurrency-cs/_static/image2.png)](implementing-optimistic-concurrency-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-123">[![When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s](implementing-optimistic-concurrency-cs/_static/image2.png)](implementing-optimistic-concurrency-cs/_static/image1.png)</span></span>

<span data-ttu-id="566f2-124">**Obrázek 1**: když dva uživatelé současně aktualizují záznam, který je potenciální pro změny jednoho uživatele, aby přepsal ostatní s ([kliknutím zobrazíte obrázek v plné velikosti).](implementing-optimistic-concurrency-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-124">**Figure 1**: When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image3.png))</span></span>

<span data-ttu-id="566f2-125">Podobně platí, že když se na stránce zobrazí dva uživatelé, může být jedním uživatelem průběhu aktualizace záznamu, když ho odstraní jiný uživatel.</span><span class="sxs-lookup"><span data-stu-id="566f2-125">Similarly, when two users are visiting a page, one user might be in the midst of updating a record when it is deleted by another user.</span></span> <span data-ttu-id="566f2-126">Nebo v případě, že uživatel načte stránku a klikne na tlačítko Odstranit, mohl jiný uživatel změnit obsah tohoto záznamu.</span><span class="sxs-lookup"><span data-stu-id="566f2-126">Or, between when a user loads a page and when they click the Delete button, another user may have modified the contents of that record.</span></span>

<span data-ttu-id="566f2-127">K dispozici jsou tři strategie [řízení souběžnosti](http://en.wikipedia.org/wiki/Concurrency_control) :</span><span class="sxs-lookup"><span data-stu-id="566f2-127">There are three [concurrency control](http://en.wikipedia.org/wiki/Concurrency_control) strategies available:</span></span>

- <span data-ttu-id="566f2-128">**Nedělat nic** – Pokud se souběžným uživatelům mění stejný záznam, nechte si poslední potvrzování změn (výchozí chování).</span><span class="sxs-lookup"><span data-stu-id="566f2-128">**Do Nothing** -if concurrent users are modifying the same record, let the last commit win (the default behavior)</span></span>
- <span data-ttu-id="566f2-129">[**Optimistická souběžnost**](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) – předpokládá, že zatímco v současnosti může dojít ke konfliktům souběžnosti, a pak i velká většina času, ke kterému nedochází, ke konfliktům nedojde. Proto pokud dojde ke konfliktu, stačí informovat uživatele, že jejich změny nelze uložit, protože stejná data změnil jiný uživatel.</span><span class="sxs-lookup"><span data-stu-id="566f2-129">[**Optimistic Concurrency**](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) - assume that while there may be concurrency conflicts every now and then, the vast majority of the time such conflicts won't arise; therefore, if a conflict does arise, simply inform the user that their changes can't be saved because another user has modified the same data</span></span>
- <span data-ttu-id="566f2-130">**Pesimistická souběžnost** – předpokládá, že konflikty souběžnosti jsou maloobchodech a že uživatelé nemůžou tolerovat své změny v důsledku souběžné aktivity jiného uživatele. Proto když jeden uživatel spustí aktualizaci záznamu, zamkne ho a zabrání tak ostatním uživatelům v úpravách nebo odstraňování tohoto záznamu, dokud uživatel nepotvrdí jejich změny.</span><span class="sxs-lookup"><span data-stu-id="566f2-130">**Pessimistic Concurrency** - assume that concurrency conflicts are commonplace and that users won't tolerate being told their changes weren't saved due to another user's concurrent activity; therefore, when one user starts updating a record, lock it, thereby preventing any other users from editing or deleting that record until the user commits their modifications</span></span>

<span data-ttu-id="566f2-131">Všechny naše kurzy proto používaly výchozí strategii překladu souběžnosti – konkrétně si ponechá poslední soubor k zápisu.</span><span class="sxs-lookup"><span data-stu-id="566f2-131">All of our tutorials thus far have used the default concurrency resolution strategy - namely, we've let the last write win.</span></span> <span data-ttu-id="566f2-132">V tomto kurzu podíváme se, jak implementovat optimistické řízení souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-132">In this tutorial we'll examine how to implement optimistic concurrency control.</span></span>

> [!NOTE]
> <span data-ttu-id="566f2-133">V této sérii kurzů se nebudeme pohlížet na pesimistické příklady souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-133">We won't look at pessimistic concurrency examples in this tutorial series.</span></span> <span data-ttu-id="566f2-134">Pesimistická souběžnost se používá zřídka, protože takové zámky, pokud nejsou řádně odstraněné, můžou ostatním uživatelům zabránit v aktualizaci dat.</span><span class="sxs-lookup"><span data-stu-id="566f2-134">Pessimistic concurrency is rarely used because such locks, if not properly relinquished, can prevent other users from updating data.</span></span> <span data-ttu-id="566f2-135">Pokud uživatel například zamkne záznam pro úpravy a potom před jeho odemknutím opustí den, nebude moci tento záznam aktualizovat, dokud původní uživatel nevrátí a nedokončí svoji aktualizaci.</span><span class="sxs-lookup"><span data-stu-id="566f2-135">For example, if a user locks a record for editing and then leaves for the day before unlocking it, no other user will be able to update that record until the original user returns and completes his update.</span></span> <span data-ttu-id="566f2-136">Proto v situacích, kde je používána pesimistická souběžnost, je obvykle časový limit, který, pokud je dosaženo, zrušení zámku.</span><span class="sxs-lookup"><span data-stu-id="566f2-136">Therefore, in situations where pessimistic concurrency is used, there's typically a timeout that, if reached, cancels the lock.</span></span> <span data-ttu-id="566f2-137">Websites pro prodej lístků, které zablokují konkrétní umístění pro umístění po krátké době, kdy uživatel dokončí proces objednávky, je příkladem pesimistické řízení souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-137">Ticket sales websites, which lock a particular seating location for short period while the user completes the order process, is an example of pessimistic concurrency control.</span></span>

## <a name="step-1-looking-at-how-optimistic-concurrency-is-implemented"></a><span data-ttu-id="566f2-138">Krok 1: Podívejte se, jak je Optimistická souběžnost implementována</span><span class="sxs-lookup"><span data-stu-id="566f2-138">Step 1: Looking at How Optimistic Concurrency is Implemented</span></span>

<span data-ttu-id="566f2-139">Optimistické řízení souběžnosti funguje tak, že zajistí, že záznam, který má být aktualizován nebo odstraněn, má stejné hodnoty jako při zahájení procesu aktualizace nebo odstranění.</span><span class="sxs-lookup"><span data-stu-id="566f2-139">Optimistic concurrency control works by ensuring that the record being updated or deleted has the same values as it did when the updating or deleting process started.</span></span> <span data-ttu-id="566f2-140">Například když kliknete na tlačítko Upravit ve upravitelném prvku GridView, hodnoty záznamu se čtou z databáze a zobrazují se v textových polích a dalších webových ovládacích prvcích.</span><span class="sxs-lookup"><span data-stu-id="566f2-140">For example, when clicking the Edit button in an editable GridView, the record's values are read from the database and displayed in TextBoxes and other Web controls.</span></span> <span data-ttu-id="566f2-141">Tyto původní hodnoty jsou uloženy v prvku GridView.</span><span class="sxs-lookup"><span data-stu-id="566f2-141">These original values are saved by the GridView.</span></span> <span data-ttu-id="566f2-142">Později poté, co uživatel provede změny a klikne na tlačítko Aktualizovat, původní hodnoty a nové hodnoty se odešlou do vrstvy obchodní logiky a pak dolů do vrstvy přístupu k datům.</span><span class="sxs-lookup"><span data-stu-id="566f2-142">Later, after the user makes her changes and clicks the Update button, the original values plus the new values are sent to the Business Logic Layer, and then down to the Data Access Layer.</span></span> <span data-ttu-id="566f2-143">Vrstva přístupu k datům musí vydat příkaz SQL, který bude aktualizovat pouze v případě, že původní hodnoty, které uživatel začal upravovat, jsou shodné s hodnotami stále v databázi.</span><span class="sxs-lookup"><span data-stu-id="566f2-143">The Data Access Layer must issue a SQL statement that will only update the record if the original values that the user started editing are identical to the values still in the database.</span></span> <span data-ttu-id="566f2-144">Obrázek 2 znázorňuje tuto posloupnost událostí.</span><span class="sxs-lookup"><span data-stu-id="566f2-144">Figure 2 depicts this sequence of events.</span></span>

<span data-ttu-id="566f2-145">[![aby se aktualizace nebo odstranění zdařily, měly by se původní hodnoty rovnat aktuálním hodnotám databáze.](implementing-optimistic-concurrency-cs/_static/image5.png)](implementing-optimistic-concurrency-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-145">[![For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values](implementing-optimistic-concurrency-cs/_static/image5.png)](implementing-optimistic-concurrency-cs/_static/image4.png)</span></span>

<span data-ttu-id="566f2-146">**Obrázek 2**: aby byla aktualizace nebo odstranění úspěšná, původní hodnoty se musí shodovat s aktuálními hodnotami databáze ([kliknutím zobrazíte obrázek v plné velikosti).](implementing-optimistic-concurrency-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-146">**Figure 2**: For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image6.png))</span></span>

<span data-ttu-id="566f2-147">Existují různé přístupy k implementaci optimistického řízení souběžnosti (viz [Petra a. Bromberg](http://peterbromberg.net/) [optimistická logika souběžného zpracování](http://www.eggheadcafe.com/articles/20050719.asp) pro Stručný pohled na řadu možností).</span><span class="sxs-lookup"><span data-stu-id="566f2-147">There are various approaches to implementing optimistic concurrency (see [Peter A. Bromberg](http://peterbromberg.net/)'s [Optimistic Concurrency Updating Logic](http://www.eggheadcafe.com/articles/20050719.asp) for a brief look at a number of options).</span></span> <span data-ttu-id="566f2-148">Typová datová sada ADO.NET poskytuje jednu implementaci, která může být nakonfigurována pouze pomocí zaškrtnutí políčka.</span><span class="sxs-lookup"><span data-stu-id="566f2-148">The ADO.NET Typed DataSet provides one implementation that can be configured with just the tick of a checkbox.</span></span> <span data-ttu-id="566f2-149">Povolení optimistického řízení souběžnosti pro TableAdapter ve typované datové sadě rozšiřuje příkazy `UPDATE` TableAdapter a `DELETE`, aby zahrnovaly porovnání všech původních hodnot v klauzuli `WHERE`.</span><span class="sxs-lookup"><span data-stu-id="566f2-149">Enabling optimistic concurrency for a TableAdapter in the Typed DataSet augments the TableAdapter's `UPDATE` and `DELETE` statements to include a comparison of all of the original values in the `WHERE` clause.</span></span> <span data-ttu-id="566f2-150">Následující příkaz `UPDATE` například aktualizuje název a cenu produktu pouze v případě, že aktuální hodnoty databáze jsou rovny hodnotám, které byly původně načteny při aktualizaci záznamu v prvku GridView.</span><span class="sxs-lookup"><span data-stu-id="566f2-150">The following `UPDATE` statement, for example, updates the name and price of a product only if the current database values are equal to the values that were originally retrieved when updating the record in the GridView.</span></span> <span data-ttu-id="566f2-151">Parametry `@ProductName` a `@UnitPrice` obsahují nové hodnoty zadané uživatelem, zatímco `@original_ProductName` a `@original_UnitPrice` obsahují hodnoty, které byly původně načteny do prvku GridView při kliknutí na tlačítko pro úpravy:</span><span class="sxs-lookup"><span data-stu-id="566f2-151">The `@ProductName` and `@UnitPrice` parameters contain the new values entered by the user, whereas `@original_ProductName` and `@original_UnitPrice` contain the values that were originally loaded into the GridView when the Edit button was clicked:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample1.sql)]

> [!NOTE]
> <span data-ttu-id="566f2-152">Tento příkaz `UPDATE` byl pro čtení zjednodušen.</span><span class="sxs-lookup"><span data-stu-id="566f2-152">This `UPDATE` statement has been simplified for readability.</span></span> <span data-ttu-id="566f2-153">V praxi by `UnitPrice` v klauzuli `WHERE` došlo k většímu podílu, protože `UnitPrice` může obsahovat `NULL` s a kontrola, zda `NULL = NULL` Always vrátí hodnotu false (místo toho musíte použít `IS NULL`).</span><span class="sxs-lookup"><span data-stu-id="566f2-153">In practice, the `UnitPrice` check in the `WHERE` clause would be more involved since `UnitPrice` can contain `NULL` s and checking if `NULL = NULL` always returns False (instead you must use `IS NULL`).</span></span>

<span data-ttu-id="566f2-154">Kromě použití jiného podkladového příkazu `UPDATE` konfigurace TableAdapter na použití optimistické souběžnosti mění také signaturu svých přímých metod databáze.</span><span class="sxs-lookup"><span data-stu-id="566f2-154">In addition to using a different underlying `UPDATE` statement, configuring a TableAdapter to use optimistic concurrency also modifies the signature of its DB direct methods.</span></span> <span data-ttu-id="566f2-155">Navrácení z našeho prvního kurzu, [*Vytvoření vrstvy přístupu k datům*](../introduction/creating-a-data-access-layer-cs.md), na kterou přímo metody databáze dostaly ty, které jako vstupní parametry přijaly seznam skalárních hodnot (spíše než silně typované instance DataRow nebo DataTable).</span><span class="sxs-lookup"><span data-stu-id="566f2-155">Recall from our first tutorial, [*Creating a Data Access Layer*](../introduction/creating-a-data-access-layer-cs.md), that DB direct methods were those that accepts a list of scalar values as input parameters (rather than a strongly-typed DataRow or DataTable instance).</span></span> <span data-ttu-id="566f2-156">Při použití optimistické souběžnosti metoda DB Direct `Update()` a `Delete()` zahrnuje vstupní parametry pro původní hodnoty.</span><span class="sxs-lookup"><span data-stu-id="566f2-156">When using optimistic concurrency, the DB direct `Update()` and `Delete()` methods include input parameters for the original values as well.</span></span> <span data-ttu-id="566f2-157">Kromě toho je nutné změnit také kód v knihoven BLL pro použití vzorce aktualizace dávky (přetížení metody `Update()`, které přijímají objekty DataRows a DataTables namísto skalárních hodnot).</span><span class="sxs-lookup"><span data-stu-id="566f2-157">Moreover, the code in the BLL for using the batch update pattern (the `Update()` method overloads that accept DataRows and DataTables rather than scalar values) must be changed as well.</span></span>

<span data-ttu-id="566f2-158">Místo toho, abyste rozšířili naše stávající objekty TableAdapter DAL k používání optimistické souběžnosti (což by vyžadovalo změnu knihoven BLL na), vytvoříme místo toho novou typovou datovou sadu s názvem `NorthwindOptimisticConcurrency`, do které přidáme `Products` TableAdapter, která používá optimistickou souběžnost.</span><span class="sxs-lookup"><span data-stu-id="566f2-158">Rather than extend our existing DAL's TableAdapters to use optimistic concurrency (which would necessitate changing the BLL to accommodate), let's instead create a new Typed DataSet named `NorthwindOptimisticConcurrency`, to which we'll add a `Products` TableAdapter that uses optimistic concurrency.</span></span> <span data-ttu-id="566f2-159">Za tímto účelem vytvoříme třídu vrstvy `ProductsOptimisticConcurrencyBLL` obchodní logiky, která bude mít odpovídající úpravy pro podporu optimistické souběžnosti DAL.</span><span class="sxs-lookup"><span data-stu-id="566f2-159">Following that, we'll create a `ProductsOptimisticConcurrencyBLL` Business Logic Layer class that has the appropriate modifications to support the optimistic concurrency DAL.</span></span> <span data-ttu-id="566f2-160">Po navýšení tohoto základyu budete připraveni vytvořit stránku ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="566f2-160">Once this groundwork has been laid, we'll be ready to create the ASP.NET page.</span></span>

## <a name="step-2-creating-a-data-access-layer-that-supports-optimistic-concurrency"></a><span data-ttu-id="566f2-161">Krok 2: vytvoření vrstvy přístupu k datům, která podporuje optimistickou souběžnost</span><span class="sxs-lookup"><span data-stu-id="566f2-161">Step 2: Creating a Data Access Layer That Supports Optimistic Concurrency</span></span>

<span data-ttu-id="566f2-162">Chcete-li vytvořit novou typovou datovou sadu, klikněte pravým tlačítkem myši na složku `DAL` ve složce `App_Code` a přidejte novou datovou sadu s názvem `NorthwindOptimisticConcurrency`.</span><span class="sxs-lookup"><span data-stu-id="566f2-162">To create a new Typed DataSet, right-click on the `DAL` folder within the `App_Code` folder and add a new DataSet named `NorthwindOptimisticConcurrency`.</span></span> <span data-ttu-id="566f2-163">Jak jsme viděli v prvním kurzu, tak se k typované datové sadě přidá nový TableAdapter a automaticky se spustí Průvodce konfigurací TableAdapter.</span><span class="sxs-lookup"><span data-stu-id="566f2-163">As we saw in the first tutorial, doing so will add a new TableAdapter to the Typed DataSet, automatically launching the TableAdapter Configuration Wizard.</span></span> <span data-ttu-id="566f2-164">Na první obrazovce se zobrazí výzva k zadání databáze pro připojení k databázi Northwind pomocí nastavení `NORTHWNDConnectionString` z `Web.config`.</span><span class="sxs-lookup"><span data-stu-id="566f2-164">In the first screen, we're prompted to specify the database to connect to - connect to the same Northwind database using the `NORTHWNDConnectionString` setting from `Web.config`.</span></span>

<span data-ttu-id="566f2-165">[![se připojit ke stejné databázi Northwind](implementing-optimistic-concurrency-cs/_static/image8.png)](implementing-optimistic-concurrency-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-165">[![Connect to the Same Northwind Database](implementing-optimistic-concurrency-cs/_static/image8.png)](implementing-optimistic-concurrency-cs/_static/image7.png)</span></span>

<span data-ttu-id="566f2-166">**Obrázek 3**: Připojte se ke stejné databázi Northwind ([kliknutím zobrazíte obrázek v plné velikosti).](implementing-optimistic-concurrency-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-166">**Figure 3**: Connect to the Same Northwind Database ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image9.png))</span></span>

<span data-ttu-id="566f2-167">V dalším kroku se zobrazí výzva k dotazování na data: prostřednictvím příkazu SQL ad-hoc, nové uložené procedury nebo existující uložené procedury.</span><span class="sxs-lookup"><span data-stu-id="566f2-167">Next, we are prompted as to how to query the data: through an ad-hoc SQL statement, a new stored procedure, or an existing stored procedure.</span></span> <span data-ttu-id="566f2-168">Vzhledem k tomu, že jsme v naší původní úrovni DAL používali dotazy SQL ad hoc, použijte tuto možnost i tady.</span><span class="sxs-lookup"><span data-stu-id="566f2-168">Since we used ad-hoc SQL queries in our original DAL, use this option here as well.</span></span>

<span data-ttu-id="566f2-169">[![zadat data, která se mají načíst pomocí příkazu SQL ad hoc](implementing-optimistic-concurrency-cs/_static/image11.png)](implementing-optimistic-concurrency-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-169">[![Specify the Data to Retrieve Using an Ad-Hoc SQL Statement](implementing-optimistic-concurrency-cs/_static/image11.png)](implementing-optimistic-concurrency-cs/_static/image10.png)</span></span>

<span data-ttu-id="566f2-170">**Obrázek 4**: určení dat, která se mají načíst pomocí příkazu SQL ad hoc ([kliknutím zobrazíte obrázek v plné velikosti](implementing-optimistic-concurrency-cs/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="566f2-170">**Figure 4**: Specify the Data to Retrieve Using an Ad-Hoc SQL Statement ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image12.png))</span></span>

<span data-ttu-id="566f2-171">Na následující obrazovce zadejte dotaz SQL, který se použije k načtení informací o produktu.</span><span class="sxs-lookup"><span data-stu-id="566f2-171">On the following screen, enter the SQL query to use to retrieve the product information.</span></span> <span data-ttu-id="566f2-172">Pojďme použít přesně stejný dotaz SQL, který se používá pro `Products` TableAdapter z našeho původního DAL, který vrátí všechny `Product` sloupce společně s názvy dodavatele a kategorií produktů:</span><span class="sxs-lookup"><span data-stu-id="566f2-172">Let's use the exact same SQL query used for the `Products` TableAdapter from our original DAL, which returns all of the `Product` columns along with the product's supplier and category names:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample2.sql)]

<span data-ttu-id="566f2-173">[![použít stejný dotaz SQL z produktů, které TableAdapter původní DAL.](implementing-optimistic-concurrency-cs/_static/image14.png)](implementing-optimistic-concurrency-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-173">[![Use the Same SQL Query from the Products TableAdapter in the Original DAL](implementing-optimistic-concurrency-cs/_static/image14.png)](implementing-optimistic-concurrency-cs/_static/image13.png)</span></span>

<span data-ttu-id="566f2-174">**Obrázek 5**: použijte stejný dotaz SQL z `Products` TableAdapter v původním dal ([kliknutím zobrazíte obrázek v plné velikosti).](implementing-optimistic-concurrency-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-174">**Figure 5**: Use the Same SQL Query from the `Products` TableAdapter in the Original DAL ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image15.png))</span></span>

<span data-ttu-id="566f2-175">Než přejdete na další obrazovku, klikněte na tlačítko Upřesnit možnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-175">Before moving onto the next screen, click the Advanced Options button.</span></span> <span data-ttu-id="566f2-176">Chcete-li, aby tato TableAdapter využívala optimistické řízení souběžnosti, stačí zaškrtnout políčko použít optimistickou souběžnost.</span><span class="sxs-lookup"><span data-stu-id="566f2-176">To have this TableAdapter employ optimistic concurrency control, simply check the "Use optimistic concurrency" checkbox.</span></span>

<span data-ttu-id="566f2-177">[![Povolit řízení souběžnosti kontrolou zaškrtnutím políčka &quot;použít optimistickou souběžnost&quot;](implementing-optimistic-concurrency-cs/_static/image17.png)](implementing-optimistic-concurrency-cs/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-177">[![Enable Optimistic Concurrency Control by Checking the &quot;Use optimistic concurrency&quot; CheckBox](implementing-optimistic-concurrency-cs/_static/image17.png)](implementing-optimistic-concurrency-cs/_static/image16.png)</span></span>

<span data-ttu-id="566f2-178">**Obrázek 6**: povolení optimistického řízení souběžnosti zaškrtnutím políčka použít optimistickou souběžnost ([kliknutím zobrazíte obrázek v plné velikosti](implementing-optimistic-concurrency-cs/_static/image18.png))</span><span class="sxs-lookup"><span data-stu-id="566f2-178">**Figure 6**: Enable Optimistic Concurrency Control by Checking the "Use optimistic concurrency" CheckBox ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image18.png))</span></span>

<span data-ttu-id="566f2-179">Nakonec uveďte, že by měl TableAdapter použít vzory přístupu k datům, které naplní DataTable a vrátí DataTable. také naznačovat, že by měly být vytvořeny metody přímé databáze.</span><span class="sxs-lookup"><span data-stu-id="566f2-179">Lastly, indicate that the TableAdapter should use the data access patterns that both fill a DataTable and return a DataTable; also indicate that the DB direct methods should be created.</span></span> <span data-ttu-id="566f2-180">Změňte název metody pro návrat vzoru DataTable z GetData na GetProducts, aby bylo možné zrcadlit podle konvencí pojmenování, které jsme použili v naší původní DAL.</span><span class="sxs-lookup"><span data-stu-id="566f2-180">Change the method name for the Return a DataTable pattern from GetData to GetProducts, so as to mirror the naming conventions we used in our original DAL.</span></span>

<span data-ttu-id="566f2-181">[![TableAdapter využívat všechny vzory přístupu k datům](implementing-optimistic-concurrency-cs/_static/image20.png)](implementing-optimistic-concurrency-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-181">[![Have the TableAdapter Utilize All Data Access Patterns](implementing-optimistic-concurrency-cs/_static/image20.png)](implementing-optimistic-concurrency-cs/_static/image19.png)</span></span>

<span data-ttu-id="566f2-182">**Obrázek 7**: TableAdapter využije všechny vzory přístupu k datům ([kliknutím zobrazíte obrázek v plné velikosti](implementing-optimistic-concurrency-cs/_static/image21.png)).</span><span class="sxs-lookup"><span data-stu-id="566f2-182">**Figure 7**: Have the TableAdapter Utilize All Data Access Patterns ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image21.png))</span></span>

<span data-ttu-id="566f2-183">Po dokončení průvodce bude Návrhář DataSet obsahovat `Products` DataTable a TableAdapter se silným typem.</span><span class="sxs-lookup"><span data-stu-id="566f2-183">After completing the wizard, the DataSet Designer will include a strongly-typed `Products` DataTable and TableAdapter.</span></span> <span data-ttu-id="566f2-184">Přejmenujte DataTable z `Products` na `ProductsOptimisticConcurrency`, což lze provést tak, že kliknete pravým tlačítkem na záhlaví objektu DataTable a zvolíte možnost Přejmenovat z kontextové nabídky.</span><span class="sxs-lookup"><span data-stu-id="566f2-184">Take a moment to rename the DataTable from `Products` to `ProductsOptimisticConcurrency`, which you can do by right-clicking on the DataTable's title bar and choosing Rename from the context menu.</span></span>

<span data-ttu-id="566f2-185">[![objekt DataTable a TableAdapter byly přidány do typované datové sady.](implementing-optimistic-concurrency-cs/_static/image23.png)](implementing-optimistic-concurrency-cs/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-185">[![A DataTable and TableAdapter Have Been Added to the Typed DataSet](implementing-optimistic-concurrency-cs/_static/image23.png)](implementing-optimistic-concurrency-cs/_static/image22.png)</span></span>

<span data-ttu-id="566f2-186">**Obrázek 8**: do typované datové sady se přidala tabulka DataTable a TableAdapter ([kliknutím zobrazíte obrázek v plné velikosti](implementing-optimistic-concurrency-cs/_static/image24.png)).</span><span class="sxs-lookup"><span data-stu-id="566f2-186">**Figure 8**: A DataTable and TableAdapter Have Been Added to the Typed DataSet ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image24.png))</span></span>

<span data-ttu-id="566f2-187">Chcete-li zobrazit rozdíly mezi `UPDATE` a `DELETE` dotazech mezi `ProductsOptimisticConcurrency` TableAdapter (která používá Optimistická souběžnost) a produkty TableAdapter (což ne), klikněte na TableAdapter a přejděte na okno Vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-187">To see the differences between the `UPDATE` and `DELETE` queries between the `ProductsOptimisticConcurrency` TableAdapter (which uses optimistic concurrency) and the Products TableAdapter (which doesn't), click on the TableAdapter and go to the Properties window.</span></span> <span data-ttu-id="566f2-188">Ve vlastnostech `DeleteCommand` a `UpdateCommand` `CommandText` dílčí vlastnosti můžete zobrazit vlastní syntaxi SQL, která se pošle do databáze v případě, že jsou vyvolány metody týkající se aktualizace nebo odstranění DAL.</span><span class="sxs-lookup"><span data-stu-id="566f2-188">In the `DeleteCommand` and `UpdateCommand` properties' `CommandText` subproperties you can see the actual SQL syntax that is sent to the database when the DAL's update or delete-related methods are invoked.</span></span> <span data-ttu-id="566f2-189">Pro `ProductsOptimisticConcurrency` TableAdapter je použit příkaz `DELETE`:</span><span class="sxs-lookup"><span data-stu-id="566f2-189">For the `ProductsOptimisticConcurrency` TableAdapter the `DELETE` statement used is:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample3.sql)]

<span data-ttu-id="566f2-190">Vzhledem k tomu, že příkaz `DELETE` TableAdapter produktu v našem originálu DAL je mnohem jednodušší:</span><span class="sxs-lookup"><span data-stu-id="566f2-190">Whereas the `DELETE` statement for the Product TableAdapter in our original DAL is the much simpler:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample4.sql)]

<span data-ttu-id="566f2-191">Jak vidíte, klauzule `WHERE` v příkazu `DELETE` pro TableAdapter, který používá optimistickou souběžnost, zahrnuje porovnání mezi každou z existujících hodnot sloupců tabulky `Product` a původními hodnotami v době, kdy byl objekt GridView (nebo DetailsView) naposledy vyplněn.</span><span class="sxs-lookup"><span data-stu-id="566f2-191">As you can see, the `WHERE` clause in the `DELETE` statement for the TableAdapter that uses optimistic concurrency includes a comparison between each of the `Product` table's existing column values and the original values at the time the GridView (or DetailsView or FormView) was last populated.</span></span> <span data-ttu-id="566f2-192">Vzhledem k tomu, že všechna pole kromě `ProductID`, `ProductName`a `Discontinued` mohou mít `NULL` hodnoty, jsou zahrnuty další parametry a kontroly pro správné porovnání `NULL` hodnot v klauzuli `WHERE`.</span><span class="sxs-lookup"><span data-stu-id="566f2-192">Since all fields other than `ProductID`, `ProductName`, and `Discontinued` can have `NULL` values, additional parameters and checks are included to correctly compare `NULL` values in the `WHERE` clause.</span></span>

<span data-ttu-id="566f2-193">Pro tento kurz nebudeme přidávat žádné další datové tabulky pro optimistickou datovou sadu s povoleným souběžným zpracováním, protože naše stránka ASP.NET bude poskytovat jenom aktualizaci a odstraňování informací o produktu.</span><span class="sxs-lookup"><span data-stu-id="566f2-193">We won't be adding any additional DataTables to the optimistic concurrency-enabled DataSet for this tutorial, as our ASP.NET page will only provide updating and deleting product information.</span></span> <span data-ttu-id="566f2-194">Pořád ale potřebujeme přidat metodu `GetProductByProductID(productID)` do `ProductsOptimisticConcurrency` TableAdapter.</span><span class="sxs-lookup"><span data-stu-id="566f2-194">However, we do still need to add the `GetProductByProductID(productID)` method to the `ProductsOptimisticConcurrency` TableAdapter.</span></span>

<span data-ttu-id="566f2-195">Chcete-li to provést, klikněte pravým tlačítkem myši na záhlaví TableAdapter (oblast vpravo nad `Fill` a `GetProducts` názvy metod) a v místní nabídce vyberte možnost Přidat dotaz.</span><span class="sxs-lookup"><span data-stu-id="566f2-195">To accomplish this, right-click on the TableAdapter's title bar (the area right above the `Fill` and `GetProducts` method names) and choose Add Query from the context menu.</span></span> <span data-ttu-id="566f2-196">Tím se spustí Průvodce konfigurací dotazu TableAdapter.</span><span class="sxs-lookup"><span data-stu-id="566f2-196">This will launch the TableAdapter Query Configuration Wizard.</span></span> <span data-ttu-id="566f2-197">Stejně jako u našich počátečních konfigurací TableAdapter se můžete rozhodnout vytvořit metodu `GetProductByProductID(productID)` pomocí ad-hoc příkazu SQL (viz obrázek 4).</span><span class="sxs-lookup"><span data-stu-id="566f2-197">As with our TableAdapter's initial configuration, opt to create the `GetProductByProductID(productID)` method using an ad-hoc SQL statement (see Figure 4).</span></span> <span data-ttu-id="566f2-198">Vzhledem k tomu, že metoda `GetProductByProductID(productID)` vrací informace o konkrétním produktu, znamená to, že tento dotaz je `SELECT` typ dotazu, který vrací řádky.</span><span class="sxs-lookup"><span data-stu-id="566f2-198">Since the `GetProductByProductID(productID)` method returns information about a particular product, indicate that this query is a `SELECT` query type that returns rows.</span></span>

<span data-ttu-id="566f2-199">[![označit typ dotazu jako &quot;vyberte, který vrací řádky&quot;](implementing-optimistic-concurrency-cs/_static/image26.png)](implementing-optimistic-concurrency-cs/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-199">[![Mark the Query Type as a &quot;SELECT which returns rows&quot;](implementing-optimistic-concurrency-cs/_static/image26.png)](implementing-optimistic-concurrency-cs/_static/image25.png)</span></span>

<span data-ttu-id="566f2-200">**Obrázek 9**: označte typ dotazu jako`SELECT`, která vrací řádky ([kliknutím zobrazíte obrázek v plné velikosti).](implementing-optimistic-concurrency-cs/_static/image27.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-200">**Figure 9**: Mark the Query Type as a "`SELECT` which returns rows" ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image27.png))</span></span>

<span data-ttu-id="566f2-201">Na další obrazovce se zobrazí výzva k použití dotazu SQL s předem načteným výchozím dotazem TableAdapter.</span><span class="sxs-lookup"><span data-stu-id="566f2-201">On the next screen we're prompted for the SQL query to use, with the TableAdapter's default query pre-loaded.</span></span> <span data-ttu-id="566f2-202">Rozšiřte existující dotaz tak, aby zahrnoval klauzuli `WHERE ProductID = @ProductID`, jak je znázorněno na obrázku 10.</span><span class="sxs-lookup"><span data-stu-id="566f2-202">Augment the existing query to include the clause `WHERE ProductID = @ProductID`, as shown in Figure 10.</span></span>

<span data-ttu-id="566f2-203">[![do předem načteného dotazu přidat klauzuli WHERE, která vrátí konkrétní záznam produktu](implementing-optimistic-concurrency-cs/_static/image29.png)](implementing-optimistic-concurrency-cs/_static/image28.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-203">[![Add a WHERE Clause to the Pre-Loaded Query to Return a Specific Product Record](implementing-optimistic-concurrency-cs/_static/image29.png)](implementing-optimistic-concurrency-cs/_static/image28.png)</span></span>

<span data-ttu-id="566f2-204">**Obrázek 10**: přidání klauzule `WHERE` do předem načteného dotazu pro vrácení konkrétního záznamu produktu ([kliknutím zobrazíte obrázek v plné velikosti](implementing-optimistic-concurrency-cs/_static/image30.png))</span><span class="sxs-lookup"><span data-stu-id="566f2-204">**Figure 10**: Add a `WHERE` Clause to the Pre-Loaded Query to Return a Specific Product Record ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image30.png))</span></span>

<span data-ttu-id="566f2-205">Nakonec Změňte názvy generovaných metod na `FillByProductID` a `GetProductByProductID`.</span><span class="sxs-lookup"><span data-stu-id="566f2-205">Finally, change the generated method names to `FillByProductID` and `GetProductByProductID`.</span></span>

<span data-ttu-id="566f2-206">[![přejmenovat metody na FillByProductID a GetProductByProductID](implementing-optimistic-concurrency-cs/_static/image32.png)](implementing-optimistic-concurrency-cs/_static/image31.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-206">[![Rename the Methods to FillByProductID and GetProductByProductID](implementing-optimistic-concurrency-cs/_static/image32.png)](implementing-optimistic-concurrency-cs/_static/image31.png)</span></span>

<span data-ttu-id="566f2-207">**Obrázek 11**: přejmenování metod `FillByProductID` a `GetProductByProductID` ([kliknutím zobrazíte obrázek v plné velikosti](implementing-optimistic-concurrency-cs/_static/image33.png))</span><span class="sxs-lookup"><span data-stu-id="566f2-207">**Figure 11**: Rename the Methods to `FillByProductID` and `GetProductByProductID` ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image33.png))</span></span>

<span data-ttu-id="566f2-208">Po dokončení tohoto průvodce TableAdapter nyní obsahuje dvě metody pro načítání dat: `GetProducts()`, které vrátí *všechny* produkty. a `GetProductByProductID(productID)`, které vrátí zadaný produkt.</span><span class="sxs-lookup"><span data-stu-id="566f2-208">With this wizard complete, the TableAdapter now contains two methods for retrieving data: `GetProducts()`, which returns *all* products; and `GetProductByProductID(productID)`, which returns the specified product.</span></span>

## <a name="step-3-creating-a-business-logic-layer-for-the-optimistic-concurrency-enabled-dal"></a><span data-ttu-id="566f2-209">Krok 3: vytvoření vrstvy obchodní logiky pro optimistickou souběžnost s povoleným přeměnum DAL</span><span class="sxs-lookup"><span data-stu-id="566f2-209">Step 3: Creating a Business Logic Layer for the Optimistic Concurrency-Enabled DAL</span></span>

<span data-ttu-id="566f2-210">Naše existující třída `ProductsBLL` obsahuje příklady použití vzorových jak dávková aktualizace, tak i databáze Direct.</span><span class="sxs-lookup"><span data-stu-id="566f2-210">Our existing `ProductsBLL` class has examples of using both the batch update and DB direct patterns.</span></span> <span data-ttu-id="566f2-211">Metoda `AddProduct` a `UpdateProduct` přetížení používají vzor aktualizace Batch, který předává instanci `ProductRow` k metodě aktualizace TableAdapter.</span><span class="sxs-lookup"><span data-stu-id="566f2-211">The `AddProduct` method and `UpdateProduct` overloads both use the batch update pattern, passing in a `ProductRow` instance to the TableAdapter's Update method.</span></span> <span data-ttu-id="566f2-212">`DeleteProduct` metoda na druhé straně používá model přímé DB, který volá metodu `Delete(productID)` TableAdapter.</span><span class="sxs-lookup"><span data-stu-id="566f2-212">The `DeleteProduct` method, on the other hand, uses the DB direct pattern, calling the TableAdapter's `Delete(productID)` method.</span></span>

<span data-ttu-id="566f2-213">Pomocí nového `ProductsOptimisticConcurrency` TableAdapter metody DB Direct nyní vyžadují, aby byly původní hodnoty také předány.</span><span class="sxs-lookup"><span data-stu-id="566f2-213">With the new `ProductsOptimisticConcurrency` TableAdapter, the DB direct methods now require that the original values also be passed in.</span></span> <span data-ttu-id="566f2-214">Například metoda `Delete` nyní očekává deset vstupních parametrů: původní `ProductID`, `ProductName`, `SupplierID`, `CategoryID`, `QuantityPerUnit`, `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, `ReorderLevel`a `Discontinued`.</span><span class="sxs-lookup"><span data-stu-id="566f2-214">For example, the `Delete` method now expects ten input parameters: the original `ProductID`, `ProductName`, `SupplierID`, `CategoryID`, `QuantityPerUnit`, `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, `ReorderLevel`, and `Discontinued`.</span></span> <span data-ttu-id="566f2-215">Používá tyto další hodnoty vstupních parametrů v klauzuli `WHERE` příkazu `DELETE`, který se posílá do databáze. zadaný záznam se odstraní jenom v případě, že jsou aktuální hodnoty databáze namapované na původní.</span><span class="sxs-lookup"><span data-stu-id="566f2-215">It uses these additional input parameters' values in `WHERE` clause of the `DELETE` statement sent to the database, only deleting the specified record if the database's current values map up to the original ones.</span></span>

<span data-ttu-id="566f2-216">I když se signatura metody `Update` TableAdapter použitá ve vzorku aktualizace dávky nezměnila, kód potřebný k záznamu původní a nové hodnoty má.</span><span class="sxs-lookup"><span data-stu-id="566f2-216">While the method signature for the TableAdapter's `Update` method used in the batch update pattern hasn't changed, the code needed to record the original and new values has.</span></span> <span data-ttu-id="566f2-217">Proto se namísto pokusu o použití optimistické souběžnosti s naší existující `ProductsBLL` třídy vytvoří nová třída vrstvy obchodní logiky, která vám umožní pracovat s naším novým DAL.</span><span class="sxs-lookup"><span data-stu-id="566f2-217">Therefore, rather than attempt to use the optimistic concurrency-enabled DAL with our existing `ProductsBLL` class, let's create a new Business Logic Layer class for working with our new DAL.</span></span>

<span data-ttu-id="566f2-218">Přidejte třídu s názvem `ProductsOptimisticConcurrencyBLL` do složky `BLL` ve složce `App_Code`.</span><span class="sxs-lookup"><span data-stu-id="566f2-218">Add a class named `ProductsOptimisticConcurrencyBLL` to the `BLL` folder within the `App_Code` folder.</span></span>

![Přidání třídy ProductsOptimisticConcurrencyBLL do složky knihoven BLL](implementing-optimistic-concurrency-cs/_static/image34.png)

<span data-ttu-id="566f2-220">**Obrázek 12**: přidání třídy `ProductsOptimisticConcurrencyBLL` do složky knihoven BLL</span><span class="sxs-lookup"><span data-stu-id="566f2-220">**Figure 12**: Add the `ProductsOptimisticConcurrencyBLL` Class to the BLL Folder</span></span>

<span data-ttu-id="566f2-221">Dále přidejte následující kód do třídy `ProductsOptimisticConcurrencyBLL`:</span><span class="sxs-lookup"><span data-stu-id="566f2-221">Next, add the following code to the `ProductsOptimisticConcurrencyBLL` class:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample5.cs)]

<span data-ttu-id="566f2-222">Všimněte si, že příkaz using `NorthwindOptimisticConcurrencyTableAdapters` překračuje začátek deklarace třídy.</span><span class="sxs-lookup"><span data-stu-id="566f2-222">Note the using `NorthwindOptimisticConcurrencyTableAdapters` statement above the start of the class declaration.</span></span> <span data-ttu-id="566f2-223">Obor názvů `NorthwindOptimisticConcurrencyTableAdapters` obsahuje třídu `ProductsOptimisticConcurrencyTableAdapter`, která poskytuje metody DAL.</span><span class="sxs-lookup"><span data-stu-id="566f2-223">The `NorthwindOptimisticConcurrencyTableAdapters` namespace contains the `ProductsOptimisticConcurrencyTableAdapter` class, which provides the DAL's methods.</span></span> <span data-ttu-id="566f2-224">Také před deklarací třídy najdete atribut `System.ComponentModel.DataObject`, který instruuje Visual Studio, aby zahrnoval tuto třídu v rozevíracím seznamu Průvodce ObjectDataSource.</span><span class="sxs-lookup"><span data-stu-id="566f2-224">Also before the class declaration you'll find the `System.ComponentModel.DataObject` attribute, which instructs Visual Studio to include this class in the ObjectDataSource wizard's drop-down list.</span></span>

<span data-ttu-id="566f2-225">Vlastnost `Adapter` `ProductsOptimisticConcurrencyBLL`poskytuje rychlý přístup k instanci třídy `ProductsOptimisticConcurrencyTableAdapter` a řídí se vzorem použitým v našich původních třídách knihoven BLL (`ProductsBLL`, `CategoriesBLL`atd.).</span><span class="sxs-lookup"><span data-stu-id="566f2-225">The `ProductsOptimisticConcurrencyBLL`'s `Adapter` property provides quick access to an instance of the `ProductsOptimisticConcurrencyTableAdapter` class, and follows the pattern used in our original BLL classes (`ProductsBLL`, `CategoriesBLL`, and so on).</span></span> <span data-ttu-id="566f2-226">Nakonec metoda `GetProducts()` jednoduše zavolá do metody `GetProducts()` DAL a vrátí objekt `ProductsOptimisticConcurrencyDataTable` naplněný instancí `ProductsOptimisticConcurrencyRow` pro každý záznam produktu v databázi.</span><span class="sxs-lookup"><span data-stu-id="566f2-226">Finally, the `GetProducts()` method simply calls down into the DAL's `GetProducts()` method and returns a `ProductsOptimisticConcurrencyDataTable` object populated with a `ProductsOptimisticConcurrencyRow` instance for each product record in the database.</span></span>

## <a name="deleting-a-product-using-the-db-direct-pattern-with-optimistic-concurrency"></a><span data-ttu-id="566f2-227">Odstranění produktu pomocí přímého vzoru DB s optimistické souběžnosti</span><span class="sxs-lookup"><span data-stu-id="566f2-227">Deleting a Product Using the DB Direct Pattern with Optimistic Concurrency</span></span>

<span data-ttu-id="566f2-228">Při použití modelu přímého přenosu databáze proti DAL, který používá optimistickou souběžnost, musí metody předat nové a původní hodnoty.</span><span class="sxs-lookup"><span data-stu-id="566f2-228">When using the DB direct pattern against a DAL that uses optimistic concurrency, the methods must be passed the new and original values.</span></span> <span data-ttu-id="566f2-229">Pro odstranění nejsou k dispozici žádné nové hodnoty, takže je potřeba předávat jenom původní hodnoty.</span><span class="sxs-lookup"><span data-stu-id="566f2-229">For deleting, there are no new values, so only the original values need be passed in.</span></span> <span data-ttu-id="566f2-230">V našem knihoven BLL musíte přijmout všechny původní parametry jako vstupní parametry.</span><span class="sxs-lookup"><span data-stu-id="566f2-230">In our BLL, then, we must accept all of the original parameters as input parameters.</span></span> <span data-ttu-id="566f2-231">Pojďme mít metodu `DeleteProduct` ve třídě `ProductsOptimisticConcurrencyBLL` použijte metodu DB Direct.</span><span class="sxs-lookup"><span data-stu-id="566f2-231">Let's have the `DeleteProduct` method in the `ProductsOptimisticConcurrencyBLL` class use the DB direct method.</span></span> <span data-ttu-id="566f2-232">To znamená, že tato metoda musí převzít všechna deset datových polí produktu jako vstupní parametry a předat je do DAL, jak je znázorněno v následujícím kódu:</span><span class="sxs-lookup"><span data-stu-id="566f2-232">This means that this method needs to take in all ten product data fields as input parameters, and pass these to the DAL, as shown in the following code:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample6.cs)]

<span data-ttu-id="566f2-233">Pokud původní hodnoty – tyto hodnoty, které byly naposledy načteny do prvku GridView (nebo DetailsView nebo FormView), se liší od hodnot v databázi, když uživatel klikne na tlačítko Odstranit, klauzule `WHERE` nebude odpovídat žádnému záznamu databáze a nebudou ovlivněny žádné záznamy.</span><span class="sxs-lookup"><span data-stu-id="566f2-233">If the original values - those values that were last loaded into the GridView (or DetailsView or FormView) - differ from the values in the database when the user clicks the Delete button the `WHERE` clause won't match up with any database record and no records will be affected.</span></span> <span data-ttu-id="566f2-234">Proto bude metoda `Delete` TableAdapter vracet `0` a metoda `DeleteProduct` knihoven BLL vrátí `false`.</span><span class="sxs-lookup"><span data-stu-id="566f2-234">Hence, the TableAdapter's `Delete` method will return `0` and the BLL's `DeleteProduct` method will return `false`.</span></span>

## <a name="updating-a-product-using-the-batch-update-pattern-with-optimistic-concurrency"></a><span data-ttu-id="566f2-235">Aktualizace produktu pomocí vzorce aktualizace dávky s optimistické souběžnosti</span><span class="sxs-lookup"><span data-stu-id="566f2-235">Updating a Product Using the Batch Update Pattern with Optimistic Concurrency</span></span>

<span data-ttu-id="566f2-236">Jak bylo uvedeno dříve, TableAdapter metoda pro vzor aktualizace dávky má stejnou signaturu metody bez ohledu na to, zda je nebo není k dis`Update` Optimistická souběžnost.</span><span class="sxs-lookup"><span data-stu-id="566f2-236">As noted earlier, the TableAdapter's `Update` method for the batch update pattern has the same method signature regardless of whether or not optimistic concurrency is employed.</span></span> <span data-ttu-id="566f2-237">Konkrétně metoda `Update` očekává objekt DataRow, pole DataRows, DataTable nebo typovou datovou sadu.</span><span class="sxs-lookup"><span data-stu-id="566f2-237">Namely, the `Update` method expects a DataRow, an array of DataRows, a DataTable, or a Typed DataSet.</span></span> <span data-ttu-id="566f2-238">Pro zadání původních hodnot nejsou k dispozici žádné další vstupní parametry.</span><span class="sxs-lookup"><span data-stu-id="566f2-238">There are no additional input parameters for specifying the original values.</span></span> <span data-ttu-id="566f2-239">To je možné, protože objekt DataTable sleduje původní a změněné hodnoty pro jeho objekty DataRow (y).</span><span class="sxs-lookup"><span data-stu-id="566f2-239">This is possible because the DataTable keeps track of the original and modified values for its DataRow(s).</span></span> <span data-ttu-id="566f2-240">Když hodnota DAL vydá svůj `UPDATE` příkaz, naplní se parametry `@original_ColumnName` původními hodnotami objektu DataRow, zatímco parametry `@ColumnName` jsou naplněny změněnými hodnotami objektu DataRow.</span><span class="sxs-lookup"><span data-stu-id="566f2-240">When the DAL issues its `UPDATE` statement, the `@original_ColumnName` parameters are populated with the DataRow's original values, whereas the `@ColumnName` parameters are populated with the DataRow's modified values.</span></span>

<span data-ttu-id="566f2-241">Ve třídě `ProductsBLL` (která používá naši původní neoptimistickou souběžnost DAL) při použití vzorce aktualizace dávky k aktualizaci informací o produktu náš kód provede následující posloupnost událostí:</span><span class="sxs-lookup"><span data-stu-id="566f2-241">In the `ProductsBLL` class (which uses our original, non-optimistic concurrency DAL), when using the batch update pattern to update product information our code performs the following sequence of events:</span></span>

1. <span data-ttu-id="566f2-242">Přečtěte si informace o produktu Current Database do instance `ProductRow` pomocí `GetProductByProductID(productID)` metody TableAdapter</span><span class="sxs-lookup"><span data-stu-id="566f2-242">Read the current database product information into a `ProductRow` instance using the TableAdapter's `GetProductByProductID(productID)` method</span></span>
2. <span data-ttu-id="566f2-243">Přiřaďte nové hodnoty k instanci `ProductRow` z kroku 1.</span><span class="sxs-lookup"><span data-stu-id="566f2-243">Assign the new values to the `ProductRow` instance from Step 1</span></span>
3. <span data-ttu-id="566f2-244">Zavolejte metodu `Update` TableAdapter a předejte ji do instance `ProductRow`</span><span class="sxs-lookup"><span data-stu-id="566f2-244">Call the TableAdapter's `Update` method, passing in the `ProductRow` instance</span></span>

<span data-ttu-id="566f2-245">Tato sekvence kroků ale nebude správně podporovat optimistickou souběžnost, protože `ProductRow` naplněná v kroku 1 je naplněna přímo z databáze, což znamená, že původní hodnoty použité objektem DataRow jsou ty, které aktuálně existují v databázi, a nikoli ty, které byly vázány na prvek GridView na začátku procesu úprav.</span><span class="sxs-lookup"><span data-stu-id="566f2-245">This sequence of steps, however, won't correctly support optimistic concurrency because the `ProductRow` populated in Step 1 is populated directly from the database, meaning that the original values used by the DataRow are those that currently exist in the database, and not those that were bound to the GridView at the start of the editing process.</span></span> <span data-ttu-id="566f2-246">Místo toho musíme při použití optimistické souběžnosti s povolenou metodou DAL změnit přetížení metody `UpdateProduct`, aby bylo možné použít následující kroky:</span><span class="sxs-lookup"><span data-stu-id="566f2-246">Instead, when using an optimistic concurrency-enabled DAL, we need to alter the `UpdateProduct` method overloads to use the following steps:</span></span>

1. <span data-ttu-id="566f2-247">Přečtěte si informace o produktu Current Database do instance `ProductsOptimisticConcurrencyRow` pomocí `GetProductByProductID(productID)` metody TableAdapter</span><span class="sxs-lookup"><span data-stu-id="566f2-247">Read the current database product information into a `ProductsOptimisticConcurrencyRow` instance using the TableAdapter's `GetProductByProductID(productID)` method</span></span>
2. <span data-ttu-id="566f2-248">Přiřaďte *původní* hodnoty k instanci `ProductsOptimisticConcurrencyRow` z kroku 1.</span><span class="sxs-lookup"><span data-stu-id="566f2-248">Assign the *original* values to the `ProductsOptimisticConcurrencyRow` instance from Step 1</span></span>
3. <span data-ttu-id="566f2-249">Zavolejte metodu `AcceptChanges()` instance `ProductsOptimisticConcurrencyRow`, která instruuje, že aktuální hodnoty jsou "původní".</span><span class="sxs-lookup"><span data-stu-id="566f2-249">Call the `ProductsOptimisticConcurrencyRow` instance's `AcceptChanges()` method, which instructs the DataRow that its current values are the "original" ones</span></span>
4. <span data-ttu-id="566f2-250">Přiřaďte *nové* hodnoty k instanci `ProductsOptimisticConcurrencyRow`.</span><span class="sxs-lookup"><span data-stu-id="566f2-250">Assign the *new* values to the `ProductsOptimisticConcurrencyRow` instance</span></span>
5. <span data-ttu-id="566f2-251">Zavolejte metodu `Update` TableAdapter a předejte ji do instance `ProductsOptimisticConcurrencyRow`</span><span class="sxs-lookup"><span data-stu-id="566f2-251">Call the TableAdapter's `Update` method, passing in the `ProductsOptimisticConcurrencyRow` instance</span></span>

<span data-ttu-id="566f2-252">Krok 1 přečte všechny aktuální hodnoty databáze pro zadaný záznam produktu.</span><span class="sxs-lookup"><span data-stu-id="566f2-252">Step 1 reads in all of the current database values for the specified product record.</span></span> <span data-ttu-id="566f2-253">Tento krok je nadbytečný v `UpdateProduct` přetížení, které aktualizuje *všechny* sloupce produktu (protože tyto hodnoty jsou v kroku 2 přepsány), ale jsou nezbytné pro ta přetížení, kde jsou jako vstupní parametry předány pouze podmnožina hodnot sloupců.</span><span class="sxs-lookup"><span data-stu-id="566f2-253">This step is superfluous in the `UpdateProduct` overload that updates *all* of the product columns (as these values are overwritten in Step 2), but is essential for those overloads where only a subset of the column values are passed in as input parameters.</span></span> <span data-ttu-id="566f2-254">Po přiřazení původních hodnot k instanci `ProductsOptimisticConcurrencyRow` je volána metoda `AcceptChanges()`, která označuje aktuální hodnoty objektu DataRow jako původní hodnoty, které mají být použity v parametrech `@original_ColumnName` v příkazu `UPDATE`.</span><span class="sxs-lookup"><span data-stu-id="566f2-254">Once the original values have been assigned to the `ProductsOptimisticConcurrencyRow` instance, the `AcceptChanges()` method is called, which marks the current DataRow values as the original values to be used in the `@original_ColumnName` parameters in the `UPDATE` statement.</span></span> <span data-ttu-id="566f2-255">Dále jsou nové hodnoty parametrů přiřazeny `ProductsOptimisticConcurrencyRow` a nakonec je vyvolána metoda `Update`, která předává objekt DataRow.</span><span class="sxs-lookup"><span data-stu-id="566f2-255">Next, the new parameter values are assigned to the `ProductsOptimisticConcurrencyRow` and, finally, the `Update` method is invoked, passing in the DataRow.</span></span>

<span data-ttu-id="566f2-256">Následující kód ukazuje `UpdateProduct` přetížení, které přijímá všechna pole dat produktu jako vstupní parametry.</span><span class="sxs-lookup"><span data-stu-id="566f2-256">The following code shows the `UpdateProduct` overload that accepts all product data fields as input parameters.</span></span> <span data-ttu-id="566f2-257">I když tady není zobrazená, třída `ProductsOptimisticConcurrencyBLL` obsažená ve stahování pro tento kurz obsahuje taky `UpdateProduct` přetížení, které přijímá jenom název a cenu produktu jako vstupní parametry.</span><span class="sxs-lookup"><span data-stu-id="566f2-257">While not shown here, the `ProductsOptimisticConcurrencyBLL` class included in the download for this tutorial also contains an `UpdateProduct` overload that accepts just the product's name and price as input parameters.</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample7.cs)]

## <a name="step-4-passing-the-original-and-new-values-from-the-aspnet-page-to-the-bll-methods"></a><span data-ttu-id="566f2-258">Krok 4: předání původní a nové hodnoty ze stránky ASP.NET do metod knihoven BLL</span><span class="sxs-lookup"><span data-stu-id="566f2-258">Step 4: Passing the Original and New Values From the ASP.NET Page to the BLL Methods</span></span>

<span data-ttu-id="566f2-259">V případě, že je DAL a knihoven BLL kompletní, vše zůstává k vytvoření stránky ASP.NET, která může využít logiku optimistického souběžnosti integrovaného systému.</span><span class="sxs-lookup"><span data-stu-id="566f2-259">With the DAL and BLL complete, all that remains is to create an ASP.NET page that can utilize the optimistic concurrency logic built in to the system.</span></span> <span data-ttu-id="566f2-260">Konkrétně musí webový ovládací prvek data (GridView, DetailsView nebo FormView) pamatovat jeho původní hodnoty a prvek ObjectDataSource musí předat obě sady hodnot do vrstvy obchodní logiky.</span><span class="sxs-lookup"><span data-stu-id="566f2-260">Specifically, the data Web control (the GridView, DetailsView, or FormView) must remember its original values and the ObjectDataSource must pass both sets of values to the Business Logic Layer.</span></span> <span data-ttu-id="566f2-261">Kromě toho musí být stránka ASP.NET nakonfigurována tak, aby řádně zpracovávala narušení souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-261">Furthermore, the ASP.NET page must be configured to gracefully handle concurrency violations.</span></span>

<span data-ttu-id="566f2-262">Začněte otevřením stránky `OptimisticConcurrency.aspx` ve složce `EditInsertDelete` a přidáním prvku GridView do návrháře, nastavením jeho vlastnosti `ID` na `ProductsGrid`.</span><span class="sxs-lookup"><span data-stu-id="566f2-262">Start by opening the `OptimisticConcurrency.aspx` page in the `EditInsertDelete` folder and adding a GridView to the Designer, setting its `ID` property to `ProductsGrid`.</span></span> <span data-ttu-id="566f2-263">Z inteligentní značky GridViewu se můžete rozhodnout pro vytvoření nového prvku ObjectDataSource s názvem `ProductsOptimisticConcurrencyDataSource`.</span><span class="sxs-lookup"><span data-stu-id="566f2-263">From the GridView's smart tag, opt to create a new ObjectDataSource named `ProductsOptimisticConcurrencyDataSource`.</span></span> <span data-ttu-id="566f2-264">Vzhledem k tomu, že chceme, aby tato ObjectDataSource používala, která podporuje optimistickou souběžnost, nakonfigurujte ji tak, aby používala objekt `ProductsOptimisticConcurrencyBLL`.</span><span class="sxs-lookup"><span data-stu-id="566f2-264">Since we want this ObjectDataSource to use the DAL that supports optimistic concurrency, configure it to use the `ProductsOptimisticConcurrencyBLL` object.</span></span>

<span data-ttu-id="566f2-265">[![mají prvek ObjectDataSource použít objekt ProductsOptimisticConcurrencyBLL](implementing-optimistic-concurrency-cs/_static/image36.png)](implementing-optimistic-concurrency-cs/_static/image35.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-265">[![Have the ObjectDataSource Use the ProductsOptimisticConcurrencyBLL Object](implementing-optimistic-concurrency-cs/_static/image36.png)](implementing-optimistic-concurrency-cs/_static/image35.png)</span></span>

<span data-ttu-id="566f2-266">**Obrázek 13**: v prvku ObjectDataSource použijte objekt `ProductsOptimisticConcurrencyBLL` ([kliknutím zobrazíte obrázek v plné velikosti](implementing-optimistic-concurrency-cs/_static/image37.png)).</span><span class="sxs-lookup"><span data-stu-id="566f2-266">**Figure 13**: Have the ObjectDataSource Use the `ProductsOptimisticConcurrencyBLL` Object ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image37.png))</span></span>

<span data-ttu-id="566f2-267">V průvodci vyberte metody `GetProducts`, `UpdateProduct`a `DeleteProduct` z rozevíracích seznamů.</span><span class="sxs-lookup"><span data-stu-id="566f2-267">Choose the `GetProducts`, `UpdateProduct`, and `DeleteProduct` methods from drop-down lists in the wizard.</span></span> <span data-ttu-id="566f2-268">Pro metodu UpdateProduct použijte přetížení, které přijímá všechna datová pole produktu.</span><span class="sxs-lookup"><span data-stu-id="566f2-268">For the UpdateProduct method, use the overload that accepts all of the product's data fields.</span></span>

## <a name="configuring-the-objectdatasource-controls-properties"></a><span data-ttu-id="566f2-269">Konfigurace vlastností ovládacího prvku ObjectDataSource</span><span class="sxs-lookup"><span data-stu-id="566f2-269">Configuring the ObjectDataSource Control's Properties</span></span>

<span data-ttu-id="566f2-270">Po dokončení průvodce by deklarativní označení prvku ObjectDataSource mělo vypadat takto:</span><span class="sxs-lookup"><span data-stu-id="566f2-270">After completing the wizard, the ObjectDataSource's declarative markup should look like the following:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample8.aspx)]

<span data-ttu-id="566f2-271">Jak vidíte, kolekce `DeleteParameters` obsahuje instanci `Parameter` pro každý z deseti vstupních parametrů v metodě `DeleteProduct` třídy `ProductsOptimisticConcurrencyBLL`.</span><span class="sxs-lookup"><span data-stu-id="566f2-271">As you can see, the `DeleteParameters` collection contains a `Parameter` instance for each of the ten input parameters in the `ProductsOptimisticConcurrencyBLL` class's `DeleteProduct` method.</span></span> <span data-ttu-id="566f2-272">Podobně kolekce `UpdateParameters` obsahuje `Parameter` instanci pro každý vstupní parametr v `UpdateProduct`.</span><span class="sxs-lookup"><span data-stu-id="566f2-272">Likewise, the `UpdateParameters` collection contains a `Parameter` instance for each of the input parameters in `UpdateProduct`.</span></span>

<span data-ttu-id="566f2-273">V předchozích kurzech, které se týkají změny dat, bychom v tomto okamžiku odebrali vlastnost `OldValuesParameterFormatString` ObjectDataSource, protože tato vlastnost označuje, že metoda knihoven BLL očekává, že se původní (nebo původní) hodnoty mají předat, a také nové hodnoty.</span><span class="sxs-lookup"><span data-stu-id="566f2-273">For those previous tutorials that involved data modification, we'd remove the ObjectDataSource's `OldValuesParameterFormatString` property at this point, since this property indicates that the BLL method expects the old (or original) values to be passed in as well as the new values.</span></span> <span data-ttu-id="566f2-274">Kromě toho tato hodnota vlastnosti označuje názvy vstupních parametrů pro původní hodnoty.</span><span class="sxs-lookup"><span data-stu-id="566f2-274">Furthermore, this property value indicates the input parameter names for the original values.</span></span> <span data-ttu-id="566f2-275">Vzhledem k tomu, že do knihoven BLL přecházejí původní hodnoty, *neodstraňujte* tuto vlastnost.</span><span class="sxs-lookup"><span data-stu-id="566f2-275">Since we are passing in the original values into the BLL, do *not* remove this property.</span></span>

> [!NOTE]
> <span data-ttu-id="566f2-276">Hodnota vlastnosti `OldValuesParameterFormatString` musí být namapována na názvy vstupních parametrů v knihoven BLL, které očekávají původní hodnoty.</span><span class="sxs-lookup"><span data-stu-id="566f2-276">The value of the `OldValuesParameterFormatString` property must map to the input parameter names in the BLL that expect the original values.</span></span> <span data-ttu-id="566f2-277">Vzhledem k tomu, že jsme tyto parametry jmenovali `original_productName`, `original_supplierID`a tak dále, můžete hodnotu vlastnosti `OldValuesParameterFormatString` ponechat jako `original_{0}`.</span><span class="sxs-lookup"><span data-stu-id="566f2-277">Since we named these parameters `original_productName`, `original_supplierID`, and so on, you can leave the `OldValuesParameterFormatString` property value as `original_{0}`.</span></span> <span data-ttu-id="566f2-278">Pokud však vstupní parametry metod knihoven BLL měly názvy, například `old_productName`, `old_supplierID`a tak dále, je nutné aktualizovat vlastnost `OldValuesParameterFormatString` na `old_{0}`.</span><span class="sxs-lookup"><span data-stu-id="566f2-278">If, however, the BLL methods' input parameters had names like `old_productName`, `old_supplierID`, and so on, you'd need to update the `OldValuesParameterFormatString` property to `old_{0}`.</span></span>

<span data-ttu-id="566f2-279">Existuje jedno nastavení konečné vlastnosti, které je nutné provést, aby prvek ObjectDataSource správně předával původní hodnoty metodám knihoven BLL.</span><span class="sxs-lookup"><span data-stu-id="566f2-279">There's one final property setting that needs to be made in order for the ObjectDataSource to correctly pass the original values to the BLL methods.</span></span> <span data-ttu-id="566f2-280">Prvek ObjectDataSource má [vlastnost ConflictDetection](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx) , kterou lze přiřadit [jedné ze dvou hodnot](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx):</span><span class="sxs-lookup"><span data-stu-id="566f2-280">The ObjectDataSource has a [ConflictDetection property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx) that can be assigned to [one of two values](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx):</span></span>

- <span data-ttu-id="566f2-281">`OverwriteChanges` – výchozí hodnota; neodesílá původní hodnoty do původních vstupních parametrů metod knihoven BLL.</span><span class="sxs-lookup"><span data-stu-id="566f2-281">`OverwriteChanges` - the default value; does not send the original values to the BLL methods' original input parameters</span></span>
- <span data-ttu-id="566f2-282">`CompareAllValues` – pošle původní hodnoty metodám knihoven BLL; tuto možnost vyberte při použití optimistického řízení souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-282">`CompareAllValues` - does send the original values to the BLL methods; choose this option when using optimistic concurrency</span></span>

<span data-ttu-id="566f2-283">Chvíli počkejte, než se nastaví vlastnost `ConflictDetection` na `CompareAllValues`.</span><span class="sxs-lookup"><span data-stu-id="566f2-283">Take a moment to set the `ConflictDetection` property to `CompareAllValues`.</span></span>

## <a name="configuring-the-gridviews-properties-and-fields"></a><span data-ttu-id="566f2-284">Konfigurace vlastností a polí prvku GridView</span><span class="sxs-lookup"><span data-stu-id="566f2-284">Configuring the GridView's Properties and Fields</span></span>

<span data-ttu-id="566f2-285">Když jsou vlastnosti prvku ObjectDataSource správně nakonfigurované, pojďme věnovat pozornost nastavení prvku GridView.</span><span class="sxs-lookup"><span data-stu-id="566f2-285">With the ObjectDataSource's properties properly configured, let's turn our attention to setting up the GridView.</span></span> <span data-ttu-id="566f2-286">Vzhledem k tomu, že chceme, aby prvek GridView podporoval úpravy a odstranění, klikněte na zaškrtávací políčka Povolit úpravy a povolit odstranění z inteligentní značky prvku GridView.</span><span class="sxs-lookup"><span data-stu-id="566f2-286">First, since we want the GridView to support editing and deleting, click the Enable Editing and Enable Deleting checkboxes from the GridView's smart tag.</span></span> <span data-ttu-id="566f2-287">Tím se přidá CommandField, jehož `ShowEditButton` a `ShowDeleteButton` jsou obě nastaveny na `true`.</span><span class="sxs-lookup"><span data-stu-id="566f2-287">This will add a CommandField whose `ShowEditButton` and `ShowDeleteButton` are both set to `true`.</span></span>

<span data-ttu-id="566f2-288">Pokud je svázán s `ProductsOptimisticConcurrencyDataSource` ObjectDataSource, prvek GridView obsahuje pole pro každé datové pole produktu.</span><span class="sxs-lookup"><span data-stu-id="566f2-288">When bound to the `ProductsOptimisticConcurrencyDataSource` ObjectDataSource, the GridView contains a field for each of the product's data fields.</span></span> <span data-ttu-id="566f2-289">I když takový prvek GridView lze upravovat, uživatelské prostředí je cokoli, ale přijatelné.</span><span class="sxs-lookup"><span data-stu-id="566f2-289">While such a GridView can be edited, the user experience is anything but acceptable.</span></span> <span data-ttu-id="566f2-290">`CategoryID` a `SupplierID` BoundFields se vykreslí jako textová pole a vyžadují, aby uživatel zadal příslušnou kategorii a dodavatele jako čísla ID.</span><span class="sxs-lookup"><span data-stu-id="566f2-290">The `CategoryID` and `SupplierID` BoundFields will render as TextBoxes, requiring the user to enter the appropriate category and supplier as ID numbers.</span></span> <span data-ttu-id="566f2-291">Pro číselná pole nebude žádné formátování a žádné ovládací prvky ověřování, aby se zajistilo, že byl dodán název produktu a že jednotková cena, jednotky v zásobách, jednotky v objednávce a změnit pořadí hodnot úrovně jsou správné číselné hodnoty a jsou větší než nebo rovny. na nulu.</span><span class="sxs-lookup"><span data-stu-id="566f2-291">There will be no formatting for the numeric fields and no validation controls to ensure that the product's name has been supplied and that the unit price, units in stock, units on order, and reorder level values are both proper numeric values and are greater than or equal to zero.</span></span>

<span data-ttu-id="566f2-292">Jak jsme popsali v tématu *přidávání ověřovacích ovládacích prvků do rozhraní pro úpravy a vkládání* a *přizpůsobení kurzů rozhraní pro úpravu dat* , lze uživatelské rozhraní přizpůsobit nahrazením BoundFields pomocí templatefields.</span><span class="sxs-lookup"><span data-stu-id="566f2-292">As we discussed in the *Adding Validation Controls to the Editing and Inserting Interfaces* and *Customizing the Data Modification Interface* tutorials, the user interface can be customized by replacing the BoundFields with TemplateFields.</span></span> <span data-ttu-id="566f2-293">Tento prvek GridView a jeho rozhraní pro úpravy jsem změnil (a) následujícími způsoby:</span><span class="sxs-lookup"><span data-stu-id="566f2-293">I've modified this GridView and its editing interface in the following ways:</span></span>

- <span data-ttu-id="566f2-294">Odebrání `ProductID`, `SupplierName`a `CategoryName` BoundFields</span><span class="sxs-lookup"><span data-stu-id="566f2-294">Removed the `ProductID`, `SupplierName`, and `CategoryName` BoundFields</span></span>
- <span data-ttu-id="566f2-295">Byl převeden `ProductName` vlastnost BoundField na TemplateField a přidán ovládací prvek RequiredFieldValidation.</span><span class="sxs-lookup"><span data-stu-id="566f2-295">Converted the `ProductName` BoundField to a TemplateField and added a RequiredFieldValidation control.</span></span>
- <span data-ttu-id="566f2-296">Převedli jsme `CategoryID` a `SupplierID` BoundFields na TemplateFields a upravili jsme rozhraní pro úpravy tak, aby místo textových polí používala DropDownList.</span><span class="sxs-lookup"><span data-stu-id="566f2-296">Converted the `CategoryID` and `SupplierID` BoundFields to TemplateFields, and adjusted the editing interface to use DropDownLists rather than TextBoxes.</span></span> <span data-ttu-id="566f2-297">V těchto TemplateFieldch `ItemTemplates`se zobrazí `CategoryName` a `SupplierName` datová pole.</span><span class="sxs-lookup"><span data-stu-id="566f2-297">In these TemplateFields' `ItemTemplates`, the `CategoryName` and `SupplierName` data fields are displayed.</span></span>
- <span data-ttu-id="566f2-298">Převedly se `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`a `ReorderLevel` BoundFields na TemplateFields a přidali ovládací prvky CompareValidator.</span><span class="sxs-lookup"><span data-stu-id="566f2-298">Converted the `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, and `ReorderLevel` BoundFields to TemplateFields and added CompareValidator controls.</span></span>

<span data-ttu-id="566f2-299">Vzhledem k tomu, že jsme už prozkoumali, jak tyto úlohy provést v předchozích kurzech, stačí jenom vypsat tu konečnou deklarativní syntaxi a ponechání implementace v praxi.</span><span class="sxs-lookup"><span data-stu-id="566f2-299">Since we've already examined how to accomplish these tasks in previous tutorials, I'll just list the final declarative syntax here and leave the implementation as practice.</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample9.aspx)]

<span data-ttu-id="566f2-300">Máme moc blízko, že máme plně funkční příklad.</span><span class="sxs-lookup"><span data-stu-id="566f2-300">We're very close to having a fully-working example.</span></span> <span data-ttu-id="566f2-301">Existuje však několik odlišnostíů, které se budou podařit a mohou způsobovat problémy s námi.</span><span class="sxs-lookup"><span data-stu-id="566f2-301">However, there are a few subtleties that will creep up and cause us problems.</span></span> <span data-ttu-id="566f2-302">Dál potřebujeme některé rozhraní, které uživatele upozorní na to, kdy došlo k narušení souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-302">Additionally, we still need some interface that alerts the user when a concurrency violation has occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="566f2-303">Aby webové ovládací prvek data mohl správně předat původní hodnoty do prvku ObjectDataSource (které jsou poté předány do knihoven BLL), je důležité, aby vlastnost `EnableViewState` prvku GridView byla nastavena na `true` (výchozí).</span><span class="sxs-lookup"><span data-stu-id="566f2-303">In order for a data Web control to correctly pass the original values to the ObjectDataSource (which are then passed to the BLL), it's vital that the GridView's `EnableViewState` property is set to `true` (the default).</span></span> <span data-ttu-id="566f2-304">Pokud stav zobrazení zakážete, původní hodnoty se při postbacku ztratí.</span><span class="sxs-lookup"><span data-stu-id="566f2-304">If you disable view state, the original values are lost on postback.</span></span>

## <a name="passing-the-correct-original-values-to-the-objectdatasource"></a><span data-ttu-id="566f2-305">Předání správných původních hodnot prvku ObjectDataSource</span><span class="sxs-lookup"><span data-stu-id="566f2-305">Passing the Correct Original Values to the ObjectDataSource</span></span>

<span data-ttu-id="566f2-306">Existuje několik problémů se způsobem konfigurace prvku GridView.</span><span class="sxs-lookup"><span data-stu-id="566f2-306">There are a couple of problems with the way the GridView has been configured.</span></span> <span data-ttu-id="566f2-307">Pokud je vlastnost `ConflictDetection` prvku ObjectDataSource nastavena na hodnotu `CompareAllValues` (jako je naše), při volání metody `Update()` nebo `Delete()` prvku GridView (nebo DetailsView), se ObjectDataSource pokusí zkopírovat původní hodnoty prvku GridView do příslušných `Parameter` instancí.</span><span class="sxs-lookup"><span data-stu-id="566f2-307">If the ObjectDataSource's `ConflictDetection` property is set to `CompareAllValues` (as is ours), when the ObjectDataSource's `Update()` or `Delete()` methods are invoked by the GridView (or DetailsView or FormView), the ObjectDataSource attempts to copy the GridView's original values into its appropriate `Parameter` instances.</span></span> <span data-ttu-id="566f2-308">Pro grafické znázornění tohoto procesu se podívejte zpátky na obrázek 2.</span><span class="sxs-lookup"><span data-stu-id="566f2-308">Refer back to Figure 2 for a graphical representation of this process.</span></span>

<span data-ttu-id="566f2-309">Konkrétně jsou hodnoty z původních hodnot prvku GridView přiřazeny v případě, že jsou data svázána s prvku GridView.</span><span class="sxs-lookup"><span data-stu-id="566f2-309">Specifically, the GridView's original values are assigned the values in the two-way databinding statements each time the data is bound to the GridView.</span></span> <span data-ttu-id="566f2-310">Proto je nutné, aby všechny požadované původní hodnoty byly zachyceny prostřednictvím obousměrné vazby dat a aby byly poskytnuty v převoditelné podobě.</span><span class="sxs-lookup"><span data-stu-id="566f2-310">Therefore, it's essential that the required original values all are captured via two-way databinding and that they are provided in a convertible format.</span></span>

<span data-ttu-id="566f2-311">Pokud chcete zjistit, proč je to důležité, chvíli počkejte, než navštívíte naši stránku v prohlížeči.</span><span class="sxs-lookup"><span data-stu-id="566f2-311">To see why this is important, take a moment to visit our page in a browser.</span></span> <span data-ttu-id="566f2-312">Podle očekávání je v prvku GridView uveden každý produkt s tlačítkem upravit a odstranit ve sloupci nejvíce vlevo.</span><span class="sxs-lookup"><span data-stu-id="566f2-312">As expected, the GridView lists each product with an Edit and Delete button in the leftmost column.</span></span>

<span data-ttu-id="566f2-313">[![jsou produkty uvedeny v prvku GridView.](implementing-optimistic-concurrency-cs/_static/image39.png)](implementing-optimistic-concurrency-cs/_static/image38.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-313">[![The Products are Listed in a GridView](implementing-optimistic-concurrency-cs/_static/image39.png)](implementing-optimistic-concurrency-cs/_static/image38.png)</span></span>

<span data-ttu-id="566f2-314">**Obrázek 14**: produkty jsou uvedeny v prvku GridView ([kliknutím zobrazíte obrázek v plné velikosti](implementing-optimistic-concurrency-cs/_static/image40.png)).</span><span class="sxs-lookup"><span data-stu-id="566f2-314">**Figure 14**: The Products are Listed in a GridView ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image40.png))</span></span>

<span data-ttu-id="566f2-315">Pokud kliknete na tlačítko Odstranit pro libovolný produkt, je vyvolána `FormatException`.</span><span class="sxs-lookup"><span data-stu-id="566f2-315">If you click the Delete button for any product, a `FormatException` is thrown.</span></span>

<span data-ttu-id="566f2-316">[![pokusu o odstranění jakéhokoli výsledku produktu v rámci aplikace FormatException](implementing-optimistic-concurrency-cs/_static/image42.png)](implementing-optimistic-concurrency-cs/_static/image41.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-316">[![Attempting to Delete Any Product Results in a FormatException](implementing-optimistic-concurrency-cs/_static/image42.png)](implementing-optimistic-concurrency-cs/_static/image41.png)</span></span>

<span data-ttu-id="566f2-317">**Obrázek 15**: pokus o odstranění jakýchkoliv výsledků produktu v `FormatException` ([kliknutím zobrazíte obrázek v plné velikosti](implementing-optimistic-concurrency-cs/_static/image43.png))</span><span class="sxs-lookup"><span data-stu-id="566f2-317">**Figure 15**: Attempting to Delete Any Product Results in a `FormatException` ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image43.png))</span></span>

<span data-ttu-id="566f2-318">`FormatException` je vyvolána, když se prvek ObjectDataSource pokusí přečíst původní hodnotu `UnitPrice`.</span><span class="sxs-lookup"><span data-stu-id="566f2-318">The `FormatException` is raised when the ObjectDataSource attempts to read in the original `UnitPrice` value.</span></span> <span data-ttu-id="566f2-319">Vzhledem k tomu, že `ItemTemplate` má `UnitPrice` formátované jako měna (`<%# Bind("UnitPrice", "{0:C}") %>`), zahrnuje symbol měny, například $19,95.</span><span class="sxs-lookup"><span data-stu-id="566f2-319">Since the `ItemTemplate` has the `UnitPrice` formatted as a currency (`<%# Bind("UnitPrice", "{0:C}") %>`), it includes a currency symbol, like $19.95.</span></span> <span data-ttu-id="566f2-320">K `FormatException` dojde, když se prvek ObjectDataSource pokusí převést tento řetězec na `decimal`.</span><span class="sxs-lookup"><span data-stu-id="566f2-320">The `FormatException` occurs as the ObjectDataSource attempts to convert this string into a `decimal`.</span></span> <span data-ttu-id="566f2-321">K obcházení tohoto problému máme několik možností:</span><span class="sxs-lookup"><span data-stu-id="566f2-321">To circumvent this problem, we have a number of options:</span></span>

- <span data-ttu-id="566f2-322">Odebere formátování měny z `ItemTemplate`.</span><span class="sxs-lookup"><span data-stu-id="566f2-322">Remove the currency formatting from the `ItemTemplate`.</span></span> <span data-ttu-id="566f2-323">To znamená, že místo použití `<%# Bind("UnitPrice", "{0:C}") %>`stačí použít `<%# Bind("UnitPrice") %>`.</span><span class="sxs-lookup"><span data-stu-id="566f2-323">That is, instead of using `<%# Bind("UnitPrice", "{0:C}") %>`, simply use `<%# Bind("UnitPrice") %>`.</span></span> <span data-ttu-id="566f2-324">Nevýhodou je, že cena už není naformátovaná.</span><span class="sxs-lookup"><span data-stu-id="566f2-324">The downside of this is that the price is no longer formatted.</span></span>
- <span data-ttu-id="566f2-325">Umožňuje zobrazit `UnitPrice` v `ItemTemplate`formátovat jako měnu, ale k tomu použijte klíčové slovo `Eval`.</span><span class="sxs-lookup"><span data-stu-id="566f2-325">Display the `UnitPrice` formatted as a currency in the `ItemTemplate`, but use the `Eval` keyword to accomplish this.</span></span> <span data-ttu-id="566f2-326">Odvolání tohoto `Eval` provádí jednosměrnou vazbu.</span><span class="sxs-lookup"><span data-stu-id="566f2-326">Recall that `Eval` performs one-way databinding.</span></span> <span data-ttu-id="566f2-327">Pro původní hodnoty stále potřebujeme zadat `UnitPrice` hodnotu, takže v `ItemTemplate`pořád potřebujeme obousměrný příkaz DataBinding, ale dá se umístit do ovládacího prvku popisek webu, jehož vlastnost `Visible` je nastavená na `false`.</span><span class="sxs-lookup"><span data-stu-id="566f2-327">We still need to provide the `UnitPrice` value for the original values, so we'll still need a two-way databinding statement in the `ItemTemplate`, but this can be placed in a Label Web control whose `Visible` property is set to `false`.</span></span> <span data-ttu-id="566f2-328">V šabloně ItemTemplate můžeme použít následující kód:</span><span class="sxs-lookup"><span data-stu-id="566f2-328">We could use the following markup in the ItemTemplate:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample10.aspx)]

- <span data-ttu-id="566f2-329">Odeberte formátování měny z `ItemTemplate`pomocí `<%# Bind("UnitPrice") %>`.</span><span class="sxs-lookup"><span data-stu-id="566f2-329">Remove the currency formatting from the `ItemTemplate`, using `<%# Bind("UnitPrice") %>`.</span></span> <span data-ttu-id="566f2-330">V obslužné rutině události `RowDataBound` prvku GridView programově přístup k ovládacímu prvku popisek webu, ve kterém je zobrazena hodnota `UnitPrice` a nastavte její vlastnost `Text` na naformátovanou verzi.</span><span class="sxs-lookup"><span data-stu-id="566f2-330">In the GridView's `RowDataBound` event handler, programmatically access the Label Web control within which the `UnitPrice` value is displayed and set its `Text` property to the formatted version.</span></span>
- <span data-ttu-id="566f2-331">Ponechte `UnitPrice` formátovanou jako měnu.</span><span class="sxs-lookup"><span data-stu-id="566f2-331">Leave the `UnitPrice` formatted as a currency.</span></span> <span data-ttu-id="566f2-332">V obslužné rutině události `RowDeleting` prvku GridView nahraďte existující hodnotu `UnitPrice` ($19,95) skutečnou hodnotou typu Decimal pomocí `Decimal.Parse`.</span><span class="sxs-lookup"><span data-stu-id="566f2-332">In the GridView's `RowDeleting` event handler, replace the existing original `UnitPrice` value ($19.95) with an actual decimal value using `Decimal.Parse`.</span></span> <span data-ttu-id="566f2-333">Zjistili jsme, jak v knihoven BLL obslužné rutiny při [*zpracování výjimek na úrovni a dal v kurzu ASP.NET stránky*](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md) udělat něco podobného jako v obslužné rutině události `RowUpdating`.</span><span class="sxs-lookup"><span data-stu-id="566f2-333">We saw how to accomplish something similar in the `RowUpdating` event handler in the [*Handling BLL- and DAL-Level Exceptions in an ASP.NET Page*](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md) tutorial.</span></span>

<span data-ttu-id="566f2-334">V tomto příkladu jsem se rozhodl s druhým přístupem, a to přidáním skrytého webového ovládacího prvku popisek, jehož vlastnost `Text` je obousměrná data vázaná na neformátovanou `UnitPrice` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="566f2-334">For my example I chose to go with the second approach, adding a hidden Label Web control whose `Text` property is two-way data bound to the unformatted `UnitPrice` value.</span></span>

<span data-ttu-id="566f2-335">Po vyřešení tohoto problému zkuste znovu kliknout na tlačítko Odstranit pro libovolný produkt.</span><span class="sxs-lookup"><span data-stu-id="566f2-335">After solving this problem, try clicking the Delete button for any product again.</span></span> <span data-ttu-id="566f2-336">Tentokrát získáte `InvalidOperationException`, když se ObjectDataSource pokusí vyvolat metodu `UpdateProduct` knihoven BLL.</span><span class="sxs-lookup"><span data-stu-id="566f2-336">This time you'll get an `InvalidOperationException` when the ObjectDataSource attempts to invoke the BLL's `UpdateProduct` method.</span></span>

<span data-ttu-id="566f2-337">[![prvek ObjectDataSource nemůže najít metodu se vstupními parametry, které chce odeslat.](implementing-optimistic-concurrency-cs/_static/image45.png)](implementing-optimistic-concurrency-cs/_static/image44.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-337">[![The ObjectDataSource Cannot Find a Method with the Input Parameters it Wants to Send](implementing-optimistic-concurrency-cs/_static/image45.png)](implementing-optimistic-concurrency-cs/_static/image44.png)</span></span>

<span data-ttu-id="566f2-338">**Obrázek 16**: prvek ObjectDataSource nemůže najít metodu se vstupními parametry, které chce odeslat ([kliknutím zobrazíte obrázek v plné velikosti).](implementing-optimistic-concurrency-cs/_static/image46.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-338">**Figure 16**: The ObjectDataSource Cannot Find a Method with the Input Parameters it Wants to Send ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image46.png))</span></span>

<span data-ttu-id="566f2-339">Při prohlížení zprávy o výjimce je jasné, že prvek ObjectDataSource chce vyvolat metodu knihoven BLL `DeleteProduct`, která zahrnuje `original_CategoryName` a vstupní parametry `original_SupplierName`.</span><span class="sxs-lookup"><span data-stu-id="566f2-339">Looking at the exception's message, it's clear that the ObjectDataSource wants to invoke a BLL `DeleteProduct` method that includes `original_CategoryName` and `original_SupplierName` input parameters.</span></span> <span data-ttu-id="566f2-340">Důvodem je, že `ItemTemplate` s pro `CategoryID` a `SupplierID` TemplateFields aktuálně obsahují obousměrné příkazy BIND s datovými poli `CategoryName` a `SupplierName`.</span><span class="sxs-lookup"><span data-stu-id="566f2-340">This is because the `ItemTemplate` s for the `CategoryID` and `SupplierID` TemplateFields currently contain two-way Bind statements with the `CategoryName` and `SupplierName` data fields.</span></span> <span data-ttu-id="566f2-341">Místo toho je potřeba zahrnout `Bind` příkazy do datových polí `CategoryID` a `SupplierID`.</span><span class="sxs-lookup"><span data-stu-id="566f2-341">Instead, we need to include `Bind` statements with the `CategoryID` and `SupplierID` data fields.</span></span> <span data-ttu-id="566f2-342">Chcete-li to provést, nahraďte existující příkazy BIND příkazy `Eval` a poté přidejte skryté ovládací prvky popisek, jejichž `Text` vlastnosti jsou vázány na `CategoryID` a `SupplierID` datových polí pomocí obousměrné datové sady, jak je znázorněno níže:</span><span class="sxs-lookup"><span data-stu-id="566f2-342">To accomplish this, replace the existing Bind statements with `Eval` statements, and then add hidden Label controls whose `Text` properties are bound to the `CategoryID` and `SupplierID` data fields using two-way databinding, as shown below:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample11.aspx)]

<span data-ttu-id="566f2-343">S těmito změnami teď dokážeme úspěšně odstranit a upravit informace o produktu!</span><span class="sxs-lookup"><span data-stu-id="566f2-343">With these changes, we are now able to successfully delete and edit product information!</span></span> <span data-ttu-id="566f2-344">V kroku 5 se podíváme na to, jak ověřit, že se zjišťují narušení souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-344">In Step 5 we'll look at how to verify that concurrency violations are being detected.</span></span> <span data-ttu-id="566f2-345">Prozatím ale počkejte několik minut, než se pokusíte aktualizovat a odstranit pár záznamů, abyste zajistili, že aktualizace a odstraňování pro jednoho uživatele funguje podle očekávání.</span><span class="sxs-lookup"><span data-stu-id="566f2-345">But for now, take a few minutes to try updating and deleting a few records to ensure that updating and deleting for a single user works as expected.</span></span>

## <a name="step-5-testing-the-optimistic-concurrency-support"></a><span data-ttu-id="566f2-346">Krok 5: testování podpory optimistického řízení souběžnosti</span><span class="sxs-lookup"><span data-stu-id="566f2-346">Step 5: Testing the Optimistic Concurrency Support</span></span>

<span data-ttu-id="566f2-347">Aby bylo možné ověřit, že došlo k narušení souběžnosti (místo toho, aby se data nemusela přepsat), musíme na této stránce otevřít dva okna prohlížeče.</span><span class="sxs-lookup"><span data-stu-id="566f2-347">In order to verify that concurrency violations are being detected (rather than resulting in data being blindly overwritten), we need to open two browser windows to this page.</span></span> <span data-ttu-id="566f2-348">V obou instancích prohlížeče klikněte na tlačítko Upravit pro příkaz Chai.</span><span class="sxs-lookup"><span data-stu-id="566f2-348">In both browser instances, click on the Edit button for Chai.</span></span> <span data-ttu-id="566f2-349">Pak v jednom z prohlížečů změňte název na "Chai čaj" a klikněte na aktualizovat.</span><span class="sxs-lookup"><span data-stu-id="566f2-349">Then, in just one of the browsers, change the name to "Chai Tea" and click Update.</span></span> <span data-ttu-id="566f2-350">Aktualizace by měla být úspěšná a vracet prvek GridView do stavu před úpravou "Chai čaj" jako nový název produktu.</span><span class="sxs-lookup"><span data-stu-id="566f2-350">The update should succeed and return the GridView to its pre-editing state, with "Chai Tea" as the new product name.</span></span>

<span data-ttu-id="566f2-351">V ostatních instancích okna prohlížeče se ale v textovém poli název produktu stále zobrazuje "Chai".</span><span class="sxs-lookup"><span data-stu-id="566f2-351">In the other browser window instance, however, the product name TextBox still shows "Chai".</span></span> <span data-ttu-id="566f2-352">V tomto druhém okně prohlížeče aktualizujte `UnitPrice` na `25.00`.</span><span class="sxs-lookup"><span data-stu-id="566f2-352">In this second browser window, update the `UnitPrice` to `25.00`.</span></span> <span data-ttu-id="566f2-353">Bez podpory optimistického řízení souběžnosti po kliknutí na aktualizovat ve druhé instanci prohlížeče se změní název produktu zpět na "Chai". tím se přepíší změny provedené první instancí prohlížeče.</span><span class="sxs-lookup"><span data-stu-id="566f2-353">Without optimistic concurrency support, clicking update in the second browser instance would change the product name back to "Chai", thereby overwriting the changes made by the first browser instance.</span></span> <span data-ttu-id="566f2-354">S využitím optimistické souběžnosti, ale kliknutím na tlačítko Aktualizovat v druhé instanci prohlížeče dojde k [DBConcurrencyException –](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx).</span><span class="sxs-lookup"><span data-stu-id="566f2-354">With optimistic concurrency employed, however, clicking the Update button in the second browser instance results in a [DBConcurrencyException](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx).</span></span>

<span data-ttu-id="566f2-355">[![, když se zjistí porušení souběžnosti, vyvolá se DBConcurrencyException –.](implementing-optimistic-concurrency-cs/_static/image48.png)](implementing-optimistic-concurrency-cs/_static/image47.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-355">[![When a Concurrency Violation is Detected, a DBConcurrencyException is Thrown](implementing-optimistic-concurrency-cs/_static/image48.png)](implementing-optimistic-concurrency-cs/_static/image47.png)</span></span>

<span data-ttu-id="566f2-356">**Obrázek 17**: když se zjistí porušení souběžnosti, vyvolá se `DBConcurrencyException` ([kliknutím zobrazíte obrázek v plné velikosti).](implementing-optimistic-concurrency-cs/_static/image49.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-356">**Figure 17**: When a Concurrency Violation is Detected, a `DBConcurrencyException` is Thrown ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image49.png))</span></span>

<span data-ttu-id="566f2-357">`DBConcurrencyException` se vyvolá pouze v případě, že je využíván vzor hromadné aktualizace dávky DAL.</span><span class="sxs-lookup"><span data-stu-id="566f2-357">The `DBConcurrencyException` is only thrown when the DAL's batch update pattern is utilized.</span></span> <span data-ttu-id="566f2-358">Model přímé databáze nevyvolává výjimku, ale pouze označuje, že nebyly ovlivněny žádné řádky.</span><span class="sxs-lookup"><span data-stu-id="566f2-358">The DB direct pattern does not raise an exception, it merely indicates that no rows were affected.</span></span> <span data-ttu-id="566f2-359">K tomu je potřeba, aby oba instance prohlížeče vracely stav před úpravou.</span><span class="sxs-lookup"><span data-stu-id="566f2-359">To illustrate this, return both browser instances' GridView to their pre-editing state.</span></span> <span data-ttu-id="566f2-360">Potom v první instanci prohlížeče klikněte na tlačítko Upravit a změňte název produktu z "Chai čaj" zpět na "Chai" a klikněte na aktualizovat.</span><span class="sxs-lookup"><span data-stu-id="566f2-360">Next, in the first browser instance, click the Edit button and change the product name from "Chai Tea" back to "Chai" and click Update.</span></span> <span data-ttu-id="566f2-361">V druhém okně prohlížeče klikněte na tlačítko Odstranit pro příkaz Chai.</span><span class="sxs-lookup"><span data-stu-id="566f2-361">In the second browser window, click the Delete button for Chai.</span></span>

<span data-ttu-id="566f2-362">Po kliknutí na tlačítko Odstranit se stránka publikuje zpět, prvek GridView Vyvolá metodu `Delete()` prvku ObjectDataSource a prvek ObjectDataSource se zavolá do `DeleteProduct` metody `ProductsOptimisticConcurrencyBLL` třídy, přičemž se přesměruje na původní hodnoty.</span><span class="sxs-lookup"><span data-stu-id="566f2-362">Upon clicking Delete, the page posts back, the GridView invokes the ObjectDataSource's `Delete()` method, and the ObjectDataSource calls down into the `ProductsOptimisticConcurrencyBLL` class's `DeleteProduct` method, passing along the original values.</span></span> <span data-ttu-id="566f2-363">Původní hodnota `ProductName` druhé instance prohlížeče je "Chai čaj", která se neshoduje s aktuální `ProductName` hodnotou v databázi.</span><span class="sxs-lookup"><span data-stu-id="566f2-363">The original `ProductName` value for the second browser instance is "Chai Tea", which doesn't match up with the current `ProductName` value in the database.</span></span> <span data-ttu-id="566f2-364">Proto příkaz `DELETE` vydaný pro databázi má vliv na nulové řádky, protože v databázi není žádný záznam, který splňuje klauzule `WHERE`.</span><span class="sxs-lookup"><span data-stu-id="566f2-364">Therefore the `DELETE` statement issued to the database affects zero rows since there's no record in the database that the `WHERE` clause satisfies.</span></span> <span data-ttu-id="566f2-365">Metoda `DeleteProduct` vrací `false` a data prvku ObjectDataSource jsou znovu svázána s ovládacím prvkem GridView.</span><span class="sxs-lookup"><span data-stu-id="566f2-365">The `DeleteProduct` method returns `false` and the ObjectDataSource's data is rebound to the GridView.</span></span>

<span data-ttu-id="566f2-366">V perspektivě koncového uživatele kliknutí na tlačítko Odstranit pro Chai čaj v druhém okně prohlížeče způsobilo, že se obrazovka Flash a po návratu zpátky produkt pořád obsahuje, i když je teď uvedený jako "Chai" (Změna názvu produktu vytvořeného prvním prohlížečem). instance).</span><span class="sxs-lookup"><span data-stu-id="566f2-366">From the end user's perspective, clicking on the Delete button for Chai Tea in the second browser window caused the screen to flash and, upon coming back, the product is still there, although now it's listed as "Chai" (the product name change made by the first browser instance).</span></span> <span data-ttu-id="566f2-367">Pokud uživatel klikne na tlačítko Odstranit znovu, odstranění bude úspěšné, protože původní hodnota `ProductName` ovládacího prvku GridView ("Chai") nyní odpovídá hodnotě v databázi.</span><span class="sxs-lookup"><span data-stu-id="566f2-367">If the user clicks the Delete button again, the Delete will succeed, as the GridView's original `ProductName` value ("Chai") now matches up with the value in the database.</span></span>

<span data-ttu-id="566f2-368">V obou těchto případech je činnost koncového uživatele mnohem z ideálního.</span><span class="sxs-lookup"><span data-stu-id="566f2-368">In both of these cases, the user experience is far from ideal.</span></span> <span data-ttu-id="566f2-369">Jasně nechceme uživateli zobrazit Nitty-Gritty podrobnosti o výjimce `DBConcurrencyException` při použití vzorce aktualizace dávky.</span><span class="sxs-lookup"><span data-stu-id="566f2-369">We clearly don't want to show the user the nitty-gritty details of the `DBConcurrencyException` exception when using the batch update pattern.</span></span> <span data-ttu-id="566f2-370">A chování při použití vzoru DB Direct je trochu matoucí, protože příkaz uživatele se nezdařil, ale nedošlo k přesnému uvedení důvodu.</span><span class="sxs-lookup"><span data-stu-id="566f2-370">And the behavior when using the DB direct pattern is somewhat confusing as the users command failed, but there was no precise indication of why.</span></span>

<span data-ttu-id="566f2-371">Abychom tyto dva problémy napravili, můžeme na stránce Vytvořit popisek webové ovládací prvky, které poskytují vysvětlení, proč se aktualizace nebo odstranění nepovedlo.</span><span class="sxs-lookup"><span data-stu-id="566f2-371">To remedy these two issues, we can create Label Web controls on the page that provide an explanation to why an update or delete failed.</span></span> <span data-ttu-id="566f2-372">Pro vzor dávkové aktualizace můžeme určit, zda došlo k výjimce `DBConcurrencyException` v obslužné rutině události na post-Level prvku GridView a zobrazit popisek upozornění podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="566f2-372">For the batch update pattern, we can determine whether or not a `DBConcurrencyException` exception occurred in the GridView's post-level event handler, displaying the warning label as needed.</span></span> <span data-ttu-id="566f2-373">Pro metodu DB Direct můžeme zkontrolovat návratovou hodnotu metody knihoven BLL (což je `true`, pokud byl ovlivněn jeden řádek, `false` jinak) a podle potřeby zobrazit informační zprávu.</span><span class="sxs-lookup"><span data-stu-id="566f2-373">For the DB direct method, we can examine the return value of the BLL method (which is `true` if one row was affected, `false` otherwise) and display an informational message as needed.</span></span>

## <a name="step-6-adding-informational-messages-and-displaying-them-in-the-face-of-a-concurrency-violation"></a><span data-ttu-id="566f2-374">Krok 6: Přidání informačních zpráv a jejich zobrazení na tvář narušení souběžnosti</span><span class="sxs-lookup"><span data-stu-id="566f2-374">Step 6: Adding Informational Messages and Displaying Them in the Face of a Concurrency Violation</span></span>

<span data-ttu-id="566f2-375">Když dojde k narušení souběžnosti, chování se projeví v závislosti na tom, jestli se použil vzor pro dávkovou aktualizaci nebo přímý DB.</span><span class="sxs-lookup"><span data-stu-id="566f2-375">When a concurrency violation occurs, the behavior exhibited depends on whether the DAL's batch update or DB direct pattern was used.</span></span> <span data-ttu-id="566f2-376">Náš kurz používá oba vzory s vzorem aktualizace dávky, který se používá pro aktualizaci, a vzor databáze Direct použitý k odstranění.</span><span class="sxs-lookup"><span data-stu-id="566f2-376">Our tutorial uses both patterns, with the batch update pattern being used for updating and the DB direct pattern used for deleting.</span></span> <span data-ttu-id="566f2-377">Chcete-li začít, přidejte na naši stránku dva webové ovládací prvky Label, které vysvětlují, že při pokusu o odstranění nebo aktualizaci dat došlo k narušení souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-377">To get started, let's add two Label Web controls to our page that explain that a concurrency violation occurred when attempting to delete or update data.</span></span> <span data-ttu-id="566f2-378">Nastavte vlastnosti ovládacího prvku popisek `Visible` a `EnableViewState` na `false`; To způsobí, že budou skryté na každé návštěvě stránky s výjimkou toho, že se jedná o konkrétní stránky, u nichž je jejich vlastnost `Visible` programově nastavená na `true`.</span><span class="sxs-lookup"><span data-stu-id="566f2-378">Set the Label control's `Visible` and `EnableViewState` properties to `false`; this will cause them to be hidden on each page visit except for those particular page visits where their `Visible` property is programmatically set to `true`.</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample12.aspx)]

<span data-ttu-id="566f2-379">Kromě nastavení vlastností `Visible`, `EnabledViewState`a `Text` jsem také nastavil (a) vlastnost `CssClass` na `Warning`, což způsobí zobrazení popisku ve velkém, červené, kurzívě a tučném písmu.</span><span class="sxs-lookup"><span data-stu-id="566f2-379">In addition to setting their `Visible`, `EnabledViewState`, and `Text` properties, I've also set the `CssClass` property to `Warning`, which causes the Label's to be displayed in a large, red, italic, bold font.</span></span> <span data-ttu-id="566f2-380">Tato třída CSS `Warning` byla definována a přidána do stylů. CSS zpátky při *zkoumání událostí souvisejících s kurzem vložení, aktualizace a odstranění* .</span><span class="sxs-lookup"><span data-stu-id="566f2-380">This CSS `Warning` class was defined and added to Styles.css back in the *Examining the Events Associated with Inserting, Updating, and Deleting* tutorial.</span></span>

<span data-ttu-id="566f2-381">Po přidání těchto popisků by měl Návrhář v aplikaci Visual Studio vypadat podobně jako obrázek 18.</span><span class="sxs-lookup"><span data-stu-id="566f2-381">After adding these Labels, the Designer in Visual Studio should look similar to Figure 18.</span></span>

<span data-ttu-id="566f2-382">[na stránku se přidaly dva ovládací prvky Label ![.](implementing-optimistic-concurrency-cs/_static/image51.png)](implementing-optimistic-concurrency-cs/_static/image50.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-382">[![Two Label Controls Have Been Added to the Page](implementing-optimistic-concurrency-cs/_static/image51.png)](implementing-optimistic-concurrency-cs/_static/image50.png)</span></span>

<span data-ttu-id="566f2-383">**Obrázek 18**: na stránku bylo přidáno dva ovládací prvky popisku ([kliknutím zobrazíte obrázek v plné velikosti).](implementing-optimistic-concurrency-cs/_static/image52.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-383">**Figure 18**: Two Label Controls Have Been Added to the Page ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image52.png))</span></span>

<span data-ttu-id="566f2-384">S těmito webovými ovládacími prvky popisků jsme připraveni zjistit, jak určit, kdy došlo k narušení souběžnosti. v takovém případě je možné vlastnost `Visible` popisku nastavit na `true`a zobrazit informační zprávu.</span><span class="sxs-lookup"><span data-stu-id="566f2-384">With these Label Web controls in place, we're ready to examine how to determine when a concurrency violation has occurred, at which point the appropriate Label's `Visible` property can be set to `true`, displaying the informational message.</span></span>

## <a name="handling-concurrency-violations-when-updating"></a><span data-ttu-id="566f2-385">Manipulace s porušením souběžnosti při aktualizaci</span><span class="sxs-lookup"><span data-stu-id="566f2-385">Handling Concurrency Violations When Updating</span></span>

<span data-ttu-id="566f2-386">Nejdřív se podíváme na to, jak zvládnout porušení souběžnosti při použití vzorce aktualizace dávky.</span><span class="sxs-lookup"><span data-stu-id="566f2-386">Let's first look at how to handle concurrency violations when using the batch update pattern.</span></span> <span data-ttu-id="566f2-387">Vzhledem k tomu, že taková porušení se vzorkem aktualizace dávky způsobí vyvolání výjimky `DBConcurrencyException`, musíme na naši stránku ASP.NET přidat kód, který určí, jestli během procesu aktualizace došlo k výjimce `DBConcurrencyException`.</span><span class="sxs-lookup"><span data-stu-id="566f2-387">Since such violations with the batch update pattern cause a `DBConcurrencyException` exception to be thrown, we need to add code to our ASP.NET page to determine whether a `DBConcurrencyException` exception occurred during the update process.</span></span> <span data-ttu-id="566f2-388">Pokud ano, měli byste uživateli zobrazit zprávu, že jejich změny nebyly uloženy, protože jiná uživatel změnil stejná data mezi tím, kdy začala upravovat záznam a po kliknutí na tlačítko Aktualizovat.</span><span class="sxs-lookup"><span data-stu-id="566f2-388">If so, we should display a message to the user explaining that their changes were not saved because another user had modified the same data between when they started editing the record and when they clicked the Update button.</span></span>

<span data-ttu-id="566f2-389">Jak jsme viděli v kurzu *zpracování knihoven BLL a na úrovni dal v kurzu stránky ASP.NET* , takové výjimky se dají detekovat a potlačit v obslužných rutinách událostí na úrovni ovládacího prvku webové správy dat.</span><span class="sxs-lookup"><span data-stu-id="566f2-389">As we saw in the *Handling BLL- and DAL-Level Exceptions in an ASP.NET Page* tutorial, such exceptions can be detected and suppressed in the data Web control's post-level event handlers.</span></span> <span data-ttu-id="566f2-390">Proto musíme vytvořit obslužnou rutinu události pro událost `RowUpdated` prvku GridView, která kontroluje, zda byla vyvolána výjimka `DBConcurrencyException`.</span><span class="sxs-lookup"><span data-stu-id="566f2-390">Therefore, we need to create an event handler for the GridView's `RowUpdated` event that checks if a `DBConcurrencyException` exception has been thrown.</span></span> <span data-ttu-id="566f2-391">Tato obslužná rutina události je předána odkaz na jakoukoliv výjimku, která byla vyvolána během procesu aktualizace, jak je znázorněno v následujícím kódu obslužné rutiny události:</span><span class="sxs-lookup"><span data-stu-id="566f2-391">This event handler is passed a reference to any exception that was raised during the updating process, as shown in the event handler code below:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample13.cs)]

<span data-ttu-id="566f2-392">Na straně `DBConcurrencyException` výjimky tato obslužná rutina události zobrazuje ovládací prvek `UpdateConflictMessage` popisek a indikuje, že byla výjimka zpracována.</span><span class="sxs-lookup"><span data-stu-id="566f2-392">In the face of a `DBConcurrencyException` exception, this event handler displays the `UpdateConflictMessage` Label control and indicates that the exception has been handled.</span></span> <span data-ttu-id="566f2-393">Pokud je tento kód na místě, když při aktualizaci záznamu dojde k narušení souběžnosti, změny uživatele se ztratí, protože by přepsali změny jiného uživatele ve stejnou dobu.</span><span class="sxs-lookup"><span data-stu-id="566f2-393">With this code in place, when a concurrency violation occurs when updating a record, the user's changes are lost, since they would have overwritten another user's modifications at the same time.</span></span> <span data-ttu-id="566f2-394">Konkrétně je prvek GridView vrácen do svého stavu před úpravou a svázán s aktuálními daty databáze.</span><span class="sxs-lookup"><span data-stu-id="566f2-394">In particular, the GridView is returned to its pre-editing state and bound to the current database data.</span></span> <span data-ttu-id="566f2-395">Tím se aktualizuje řádek prvku GridView o změny provedené jiným uživatelem, které byly dříve neviditelné.</span><span class="sxs-lookup"><span data-stu-id="566f2-395">This will update the GridView row with the other user's changes, which were previously not visible.</span></span> <span data-ttu-id="566f2-396">Kromě toho ovládací prvek popisek `UpdateConflictMessage` vysvětlí uživateli, co se právě stalo.</span><span class="sxs-lookup"><span data-stu-id="566f2-396">Additionally, the `UpdateConflictMessage` Label control will explain to the user what just happened.</span></span> <span data-ttu-id="566f2-397">Tato posloupnost událostí je podrobně popsána na obrázku 19.</span><span class="sxs-lookup"><span data-stu-id="566f2-397">This sequence of events is detailed in Figure 19.</span></span>

<span data-ttu-id="566f2-398">[![, že se aktualizace uživatelů ztratí při narušení souběžnosti](implementing-optimistic-concurrency-cs/_static/image54.png)](implementing-optimistic-concurrency-cs/_static/image53.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-398">[![A User s Updates are Lost in the Face of a Concurrency Violation](implementing-optimistic-concurrency-cs/_static/image54.png)](implementing-optimistic-concurrency-cs/_static/image53.png)</span></span>

<span data-ttu-id="566f2-399">**Obrázek 19**: při narušení souběžnosti dojde ke ztrátě aktualizací uživatelů ([kliknutím zobrazíte obrázek s plnou velikostí](implementing-optimistic-concurrency-cs/_static/image55.png)).</span><span class="sxs-lookup"><span data-stu-id="566f2-399">**Figure 19**: A User s Updates are Lost in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image55.png))</span></span>

> [!NOTE]
> <span data-ttu-id="566f2-400">Alternativně, namísto vrácení prvku GridView do stavu před úpravou, můžeme opustit prvek GridView ve svém stavu úprav nastavením vlastnosti `KeepInEditMode` předaného objektu `GridViewUpdatedEventArgs` na hodnotu true.</span><span class="sxs-lookup"><span data-stu-id="566f2-400">Alternatively, rather than returning the GridView to the pre-editing state, we could leave the GridView in its editing state by setting the `KeepInEditMode` property of the passed-in `GridViewUpdatedEventArgs` object to true.</span></span> <span data-ttu-id="566f2-401">Pokud tento postup použijete, je však nutné, aby se data znovu navázala na prvek GridView (vyvoláním jeho `DataBind()` metody), aby byly hodnoty ostatních uživatelů načteny do rozhraní pro úpravy.</span><span class="sxs-lookup"><span data-stu-id="566f2-401">If you take this approach, however, be certain to rebind the data to the GridView (by invoking its `DataBind()` method) so that the other user's values are loaded into the editing interface.</span></span> <span data-ttu-id="566f2-402">Kód, který je k dispozici ke stažení v tomto kurzu, má tyto dva řádky kódu v obslužné rutině události `RowUpdated` s komentářem. jednoduše Odkomentujte tyto řádky kódu, aby ovládací prvek GridView zůstal v režimu úprav po porušení souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-402">The code available for download with this tutorial has these two lines of code in the `RowUpdated` event handler commented out; simply uncomment these lines of code to have the GridView remain in edit mode after a concurrency violation.</span></span>

## <a name="responding-to-concurrency-violations-when-deleting"></a><span data-ttu-id="566f2-403">Reakce na porušení souběžnosti při odstraňování</span><span class="sxs-lookup"><span data-stu-id="566f2-403">Responding to Concurrency Violations When Deleting</span></span>

<span data-ttu-id="566f2-404">Při přímém vzoru DB není při narušení souběžnosti vyvolána žádná výjimka.</span><span class="sxs-lookup"><span data-stu-id="566f2-404">With the DB direct pattern, there is no exception raised in the face of a concurrency violation.</span></span> <span data-ttu-id="566f2-405">Místo toho databázový příkaz jednoduše neovlivní žádné záznamy, protože klauzule WHERE neodpovídá žádnému záznamu.</span><span class="sxs-lookup"><span data-stu-id="566f2-405">Instead, the database statement simply affects no records, as the WHERE clause does not match with any record.</span></span> <span data-ttu-id="566f2-406">Všechny metody změny dat vytvořené v knihoven BLL byly navrženy tak, aby vracely logickou hodnotu, která určuje, zda ovlivnila přesně jeden záznam.</span><span class="sxs-lookup"><span data-stu-id="566f2-406">All of the data modification methods created in the BLL have been designed such that they return a Boolean value indicating whether or not they affected precisely one record.</span></span> <span data-ttu-id="566f2-407">Proto, aby bylo možné zjistit, jestli při odstraňování záznamu došlo k narušení souběžnosti, můžeme prostudovat návratovou hodnotu metody `DeleteProduct` knihoven BLL.</span><span class="sxs-lookup"><span data-stu-id="566f2-407">Therefore, to determine if a concurrency violation occurred when deleting a record, we can examine the return value of the BLL's `DeleteProduct` method.</span></span>

<span data-ttu-id="566f2-408">Návratovou hodnotu pro metodu knihoven BLL lze prozkoumat v obslužných rutinách události na úrovni ovládacího prvku ObjectDataSource prostřednictvím vlastnosti `ReturnValue` objektu `ObjectDataSourceStatusEventArgs` předaného do obslužné rutiny události.</span><span class="sxs-lookup"><span data-stu-id="566f2-408">The return value for a BLL method can be examined in the ObjectDataSource's post-level event handlers through the `ReturnValue` property of the `ObjectDataSourceStatusEventArgs` object passed into the event handler.</span></span> <span data-ttu-id="566f2-409">Vzhledem k tomu, že vás zajímá určení návratové hodnoty z metody `DeleteProduct`, musíme vytvořit obslužnou rutinu události pro událost `Deleted` prvku ObjectDataSource.</span><span class="sxs-lookup"><span data-stu-id="566f2-409">Since we are interested in determining the return value from the `DeleteProduct` method, we need to create an event handler for the ObjectDataSource's `Deleted` event.</span></span> <span data-ttu-id="566f2-410">Vlastnost `ReturnValue` je typu `object` a může být `null`, pokud byla vyvolána výjimka a metoda byla přerušena před tím, než by mohla vracet hodnotu.</span><span class="sxs-lookup"><span data-stu-id="566f2-410">The `ReturnValue` property is of type `object` and can be `null` if an exception was raised and the method was interrupted before it could return a value.</span></span> <span data-ttu-id="566f2-411">Proto je třeba nejprve zajistit, aby vlastnost `ReturnValue` nebyla `null` a je logická hodnota.</span><span class="sxs-lookup"><span data-stu-id="566f2-411">Therefore, we should first ensure that the `ReturnValue` property is not `null` and is a Boolean value.</span></span> <span data-ttu-id="566f2-412">Za předpokladu, že tato kontrola projde, zobrazí se `DeleteConflictMessage` ovládací prvek popisek, pokud je `ReturnValue` `false`.</span><span class="sxs-lookup"><span data-stu-id="566f2-412">Assuming this check passes, we show the `DeleteConflictMessage` Label control if the `ReturnValue` is `false`.</span></span> <span data-ttu-id="566f2-413">To lze provést pomocí následujícího kódu:</span><span class="sxs-lookup"><span data-stu-id="566f2-413">This can be accomplished by using the following code:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample14.cs)]

<span data-ttu-id="566f2-414">V případě porušení souběžnosti se žádost o odstranění uživatele zruší.</span><span class="sxs-lookup"><span data-stu-id="566f2-414">In the face of a concurrency violation, the user's delete request is canceled.</span></span> <span data-ttu-id="566f2-415">Prvek GridView se aktualizuje a zobrazí změny, ke kterým došlo pro daný záznam mezi časem, kdy uživatel stránku načetl, a když klikl na tlačítko Odstranit.</span><span class="sxs-lookup"><span data-stu-id="566f2-415">The GridView is refreshed, showing the changes that occurred for that record between the time the user loaded the page and when he clicked the Delete button.</span></span> <span data-ttu-id="566f2-416">Pokud takové porušení nastane, zobrazí se popisek `DeleteConflictMessage`, který vysvětluje, co se právě stalo (viz obrázek 20).</span><span class="sxs-lookup"><span data-stu-id="566f2-416">When such a violation transpires, the `DeleteConflictMessage` Label is shown, explaining what just happened (see Figure 20).</span></span>

<span data-ttu-id="566f2-417">[![odstranění uživatele se zrušilo na straně porušení souběžnosti.](implementing-optimistic-concurrency-cs/_static/image57.png)](implementing-optimistic-concurrency-cs/_static/image56.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-417">[![A User s Delete is Canceled in the Face of a Concurrency Violation](implementing-optimistic-concurrency-cs/_static/image57.png)](implementing-optimistic-concurrency-cs/_static/image56.png)</span></span>

<span data-ttu-id="566f2-418">**Obrázek 20**: odstranění uživatele se zrušilo na straně porušení souběžnosti ([kliknutím zobrazíte obrázek v plné velikosti).](implementing-optimistic-concurrency-cs/_static/image58.png)</span><span class="sxs-lookup"><span data-stu-id="566f2-418">**Figure 20**: A User s Delete is Canceled in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image58.png))</span></span>

## <a name="summary"></a><span data-ttu-id="566f2-419">Přehled</span><span class="sxs-lookup"><span data-stu-id="566f2-419">Summary</span></span>

<span data-ttu-id="566f2-420">Příležitosti pro narušení souběžnosti existují v každé aplikaci, která umožňuje více souběžným uživatelům aktualizovat nebo odstraňovat data.</span><span class="sxs-lookup"><span data-stu-id="566f2-420">Opportunities for concurrency violations exist in every application that allows multiple, concurrent users to update or delete data.</span></span> <span data-ttu-id="566f2-421">Pokud se taková porušení neúčtují pro, když dva uživatelé současně aktualizují stejná data, která jsou v posledním zápisu "WINS", přepíše změny provedené ostatními uživateli.</span><span class="sxs-lookup"><span data-stu-id="566f2-421">If such violations are not accounted for, when two users simultaneously update the same data whoever gets in the last write "wins," overwriting the other user's changes changes.</span></span> <span data-ttu-id="566f2-422">Vývojáři mohou případně implementovat buď optimistické, nebo pesimistické řízení souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-422">Alternatively, developers can implement either optimistic or pessimistic concurrency control.</span></span> <span data-ttu-id="566f2-423">Optimistické řízení souběžnosti předpokládá, že narušení souběžnosti jsou zřídka a jednoduše nepovoluje příkaz Update nebo DELETE, který by představoval narušení souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-423">Optimistic concurrency control assumes that concurrency violations are infrequent and simply disallows an update or delete command that would constitute a concurrency violation.</span></span> <span data-ttu-id="566f2-424">Pesimistické řízení souběžnosti předpokládá, že narušení souběžnosti často a jednoduše odmítání aktualizace jednoho uživatele nebo příkazu k odstranění není přijatelné.</span><span class="sxs-lookup"><span data-stu-id="566f2-424">Pessimistic concurrency control assumes that concurrency violations are frequent and simply rejecting one user's update or delete command is not acceptable.</span></span> <span data-ttu-id="566f2-425">Díky pesimistické kontrole souběžnosti aktualizace záznamů zahrnuje jejich uzamykání, což brání ostatním uživatelům v úpravách nebo odstraňování záznamu v době, kdy je uzamčen.</span><span class="sxs-lookup"><span data-stu-id="566f2-425">With pessimistic concurrency control, updating a record involves locking it, thereby preventing any other users from modifying or deleting the record while it is locked.</span></span>

<span data-ttu-id="566f2-426">Typová datová sada v rozhraní .NET poskytuje funkce pro podporu optimistického řízení souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="566f2-426">The Typed DataSet in .NET provides functionality for supporting optimistic concurrency control.</span></span> <span data-ttu-id="566f2-427">Konkrétně příkazy `UPDATE` a `DELETE` vydané do databáze obsahují všechny sloupce tabulky, čímž se zajistí, že aktualizace nebo odstranění budou provedeny pouze v případě, že se aktuální data záznamu shodují s původními daty, která měla uživatel při provádění aktualizace nebo odstranění.</span><span class="sxs-lookup"><span data-stu-id="566f2-427">In particular, the `UPDATE` and `DELETE` statements issued to the database include all of the table's columns, thereby ensuring that the update or delete will only occur if the record's current data matches with the original data the user had when performing their update or delete.</span></span> <span data-ttu-id="566f2-428">Jakmile je DAL nakonfigurovaný tak, aby podporoval optimistickou souběžnost, metody knihoven BLL je potřeba aktualizovat.</span><span class="sxs-lookup"><span data-stu-id="566f2-428">Once the DAL has been configured to support optimistic concurrency, the BLL methods need to be updated.</span></span> <span data-ttu-id="566f2-429">Kromě toho musí být stránka ASP.NET, která volá do knihoven BLL, nakonfigurována tak, aby prvek ObjectDataSource načítají původní hodnoty z ovládacího prvku data a předává je do knihoven BLL.</span><span class="sxs-lookup"><span data-stu-id="566f2-429">Additionally, the ASP.NET page that calls down into the BLL must be configured such that the ObjectDataSource retrieves the original values from its data Web control and passes them down into the BLL.</span></span>

<span data-ttu-id="566f2-430">Jak jsme viděli v tomto kurzu, implementace optimistického řízení souběžnosti ve webové aplikaci ASP.NET zahrnuje aktualizaci DAL a knihoven BLL a přidání podpory na stránku ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="566f2-430">As we saw in this tutorial, implementing optimistic concurrency control in an ASP.NET web application involves updating the DAL and BLL and adding support in the ASP.NET page.</span></span> <span data-ttu-id="566f2-431">Bez ohledu na to, jestli tato přidaná práce představuje moudrou investici vašeho času a úsilí, záleží na vaší aplikaci.</span><span class="sxs-lookup"><span data-stu-id="566f2-431">Whether or not this added work is a wise investment of your time and effort depends on your application.</span></span> <span data-ttu-id="566f2-432">Pokud nechcete, aby souběžní uživatelé aktualizovali data, nebo se data, která aktualizují, liší od sebe, pak řízení souběžnosti není klíčový problém.</span><span class="sxs-lookup"><span data-stu-id="566f2-432">If you infrequently have concurrent users updating data, or the data they are updating is different from one another, then concurrency control is not a key issue.</span></span> <span data-ttu-id="566f2-433">Pokud ale pravidelně máte na svém webu více uživatelů, kteří pracují se stejnými daty, řízení souběžnosti může zabránit tomu, aby se aktualizace jednoho uživatele nebo odstranění z unwittingly přepsaly jiným.</span><span class="sxs-lookup"><span data-stu-id="566f2-433">If, however, you routinely have multiple users on your site working with the same data, concurrency control can help prevent one user's updates or deletes from unwittingly overwriting another's.</span></span>

<span data-ttu-id="566f2-434">Šťastné programování!</span><span class="sxs-lookup"><span data-stu-id="566f2-434">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="566f2-435">O autorovi</span><span class="sxs-lookup"><span data-stu-id="566f2-435">About the Author</span></span>

<span data-ttu-id="566f2-436">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), autor 7 ASP/ASP. NET Books a zakladatel of [4GuysFromRolla.com](http://www.4guysfromrolla.com), pracoval s webovými technologiemi Microsoftu od 1998.</span><span class="sxs-lookup"><span data-stu-id="566f2-436">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="566f2-437">Scott funguje jako nezávislý konzultant, Trainer a zapisovač.</span><span class="sxs-lookup"><span data-stu-id="566f2-437">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="566f2-438">Nejnovější kniha je [*Sams naučit se ASP.NET 2,0 za 24 hodin*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span><span class="sxs-lookup"><span data-stu-id="566f2-438">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="566f2-439">Dá se získat na [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="566f2-439">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="566f2-440">nebo prostřednictvím svého blogu, který najdete na adrese [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span><span class="sxs-lookup"><span data-stu-id="566f2-440">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="566f2-441">[Předchozí](customizing-the-data-modification-interface-cs.md)
> [Další](adding-client-side-confirmation-when-deleting-cs.md)</span><span class="sxs-lookup"><span data-stu-id="566f2-441">[Previous](customizing-the-data-modification-interface-cs.md)
[Next](adding-client-side-confirmation-when-deleting-cs.md)</span></span>
