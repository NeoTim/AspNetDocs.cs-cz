---
title: Hierarchie účelů a víceklientská architektura v ASP.NET Core
author: rick-anderson
description: Získejte informace o řetězec hierarchie účelů a víceklientská architektura jako má vztah k rozhraní API ASP.NET Core Data Protection.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/consumer-apis/purpose-strings-multitenancy
ms.openlocfilehash: 1133d40e7b325d58b3f70e7387494dae36ff8ac9
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/01/2019
ms.locfileid: "57072745"
---
# <a name="purpose-hierarchy-and-multi-tenancy-in-aspnet-core"></a><span data-ttu-id="83c46-103">Hierarchie účelů a víceklientská architektura v ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="83c46-103">Purpose hierarchy and multi-tenancy in ASP.NET Core</span></span>

<span data-ttu-id="83c46-104">Protože `IDataProtector` je také implicitně `IDataProtectionProvider`, účely je možné zřetězit.</span><span class="sxs-lookup"><span data-stu-id="83c46-104">Since an `IDataProtector` is also implicitly an `IDataProtectionProvider`, purposes can be chained together.</span></span> <span data-ttu-id="83c46-105">V tomto smyslu `provider.CreateProtector([ "purpose1", "purpose2" ])` je ekvivalentní `provider.CreateProtector("purpose1").CreateProtector("purpose2")`.</span><span class="sxs-lookup"><span data-stu-id="83c46-105">In this sense, `provider.CreateProtector([ "purpose1", "purpose2" ])` is equivalent to `provider.CreateProtector("purpose1").CreateProtector("purpose2")`.</span></span>

<span data-ttu-id="83c46-106">To umožňuje některé zajímavé hierarchických vztahů prostřednictvím systému ochrany dat.</span><span class="sxs-lookup"><span data-stu-id="83c46-106">This allows for some interesting hierarchical relationships through the data protection system.</span></span> <span data-ttu-id="83c46-107">V předchozím příkladu z [Contoso.Messaging.SecureMessage](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose), komponenta SecureMessage můžete volat `provider.CreateProtector("Contoso.Messaging.SecureMessage")` jednou počáteční a uložte do mezipaměti výsledek do privátní `_myProvider` pole.</span><span class="sxs-lookup"><span data-stu-id="83c46-107">In the earlier example of [Contoso.Messaging.SecureMessage](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose), the SecureMessage component can call `provider.CreateProtector("Contoso.Messaging.SecureMessage")` once up-front and cache the result into a private `_myProvider` field.</span></span> <span data-ttu-id="83c46-108">Budoucí ochrany mohou být vytvořeny prostřednictvím volání do `_myProvider.CreateProtector("User: username")`, a tyto ochrany by se použít k zabezpečení jednotlivých zpráv.</span><span class="sxs-lookup"><span data-stu-id="83c46-108">Future protectors can then be created via calls to `_myProvider.CreateProtector("User: username")`, and these protectors would be used for securing the individual messages.</span></span>

<span data-ttu-id="83c46-109">To také může být obráceně.</span><span class="sxs-lookup"><span data-stu-id="83c46-109">This can also be flipped.</span></span> <span data-ttu-id="83c46-110">Vezměte v úvahu jednu logickou aplikaci více tenantů (systém správy obsahu zdá se, že přiměřené) a každý klient může mít nakonfigurovanou vlastní ověřování a stav systému pro správu hostitele.</span><span class="sxs-lookup"><span data-stu-id="83c46-110">Consider a single logical application which hosts multiple tenants (a CMS seems reasonable), and each tenant can be configured with its own authentication and state management system.</span></span> <span data-ttu-id="83c46-111">Zastřešující aplikace má hlavní jednoho zprostředkovatele a volá `provider.CreateProtector("Tenant 1")` a `provider.CreateProtector("Tenant 2")` poskytnout vlastní izolované řez systému ochrany dat každého tenanta.</span><span class="sxs-lookup"><span data-stu-id="83c46-111">The umbrella application has a single master provider, and it calls `provider.CreateProtector("Tenant 1")` and `provider.CreateProtector("Tenant 2")` to give each tenant its own isolated slice of the data protection system.</span></span> <span data-ttu-id="83c46-112">Klienti pak může odvodit vlastní jednotlivých ochrany podle vlastních potřeb, ale bez ohledu na to, jak usilovně se snaží nelze vytvářet ochrany, které kolidují s žádným jiným klientem v systému.</span><span class="sxs-lookup"><span data-stu-id="83c46-112">The tenants could then derive their own individual protectors based on their own needs, but no matter how hard they try they cannot create protectors which collide with any other tenant in the system.</span></span> <span data-ttu-id="83c46-113">Graficky je reprezentováno níže.</span><span class="sxs-lookup"><span data-stu-id="83c46-113">Graphically, this is represented as below.</span></span>

![Účely více tenantů](purpose-strings-multitenancy/_static/purposes-multi-tenancy.png)

>[!WARNING]
> <span data-ttu-id="83c46-115">Předpokladem zastřešující řízení aplikací, které rozhraní API jsou dostupná pro jednotlivé tenanty a že klienti nelze spustit libovolný kód na serveru.</span><span class="sxs-lookup"><span data-stu-id="83c46-115">This assumes the umbrella application controls which APIs are available to individual tenants and that tenants cannot execute arbitrary code on the server.</span></span> <span data-ttu-id="83c46-116">Pokud tenanta může spustit libovolný kód, může provádějí privátní reflexe pro přerušení záruky izolace, nebo může jen číst hlavní klíčový materiál přímo a odvodit libovolné podklíče přejí.</span><span class="sxs-lookup"><span data-stu-id="83c46-116">If a tenant can execute arbitrary code, they could perform private reflection to break the isolation guarantees, or they could just read the master keying material directly and derive whatever subkeys they desire.</span></span>

<span data-ttu-id="83c46-117">Systém ochrany dat ve skutečnosti používá řazení více tenantů v její výchozí konfiguraci out-of-the-box.</span><span class="sxs-lookup"><span data-stu-id="83c46-117">The data protection system actually uses a sort of multi-tenancy in its default out-of-the-box configuration.</span></span> <span data-ttu-id="83c46-118">Ve výchozím nastavení je hlavní klíčový materiál uložen ve složce profilu uživatele účet pracovního procesu (nebo registru pro identity fondu aplikací služby IIS).</span><span class="sxs-lookup"><span data-stu-id="83c46-118">By default master keying material is stored in the worker process account's user profile folder (or the registry, for IIS application pool identities).</span></span> <span data-ttu-id="83c46-119">Ale je ve skutečnosti poměrně běžných jeden účet použít ke spuštění více aplikací, a tedy tyto aplikace skončili byste hlavního klíče materiál pro sdílení obsahu.</span><span class="sxs-lookup"><span data-stu-id="83c46-119">But it's actually fairly common to use a single account to run multiple applications, and thus all these applications would end up sharing the master keying material.</span></span> <span data-ttu-id="83c46-120">Tento problém vyřešit, systém ochrany dat automaticky vloží jedinečný každou aplikaci identifikátor jako první prvek v řetězci celkové účel.</span><span class="sxs-lookup"><span data-stu-id="83c46-120">To solve this, the data protection system automatically inserts a unique-per-application identifier as the first element in the overall purpose chain.</span></span> <span data-ttu-id="83c46-121">Toto implicitní účelu slouží k [izolaci jednotlivých aplikací](xref:security/data-protection/configuration/overview#per-application-isolation) vzájemně efektivně zpracováním každou aplikaci jako jedinečný tenanta v rámci systému a proces vytvoření ochrany pomocí vypadá stejné jako na obrázku výše.</span><span class="sxs-lookup"><span data-stu-id="83c46-121">This implicit purpose serves to [isolate individual applications](xref:security/data-protection/configuration/overview#per-application-isolation) from one another by effectively treating each application as a unique tenant within the system, and the protector creation process looks identical to the image above.</span></span>
