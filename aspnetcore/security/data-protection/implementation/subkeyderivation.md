---
title: Odvozování podklíčů a ověřené šifrování v ASP.NET Core
author: rick-anderson
description: Přečtěte si podrobnosti implementace ochrany dat ASP.NET Core podklíče odvození a ověřené šifrování.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: 37e7b01700e8a6b755b5ed16a9d7d75a9eeb970e
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/01/2019
ms.locfileid: "57072817"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="a7db5-103">Odvozování podklíčů a ověřené šifrování v ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="a7db5-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="a7db5-104">Většina klíčů v aktualizační kanál, který klíč bude obsahovat určitou formu entropie a budou mít vylepšením informace s oznámením "režimu CBC šifrování + ověřování HMAC" nebo "GCM šifrování + ověřování".</span><span class="sxs-lookup"><span data-stu-id="a7db5-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="a7db5-105">V těchto případech označujeme vložený entropie materiál hlavního klíče (nebo KM) pro tento klíč a provádíme funkce odvození klíče k odvození klíče, které se použije pro vlastní kryptografické operace.</span><span class="sxs-lookup"><span data-stu-id="a7db5-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="a7db5-106">Klíče jsou abstraktní a jak je uvedeno níže nemusí chovat vlastní implementaci.</span><span class="sxs-lookup"><span data-stu-id="a7db5-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="a7db5-107">Pokud klíč poskytuje vlastní implementaci `IAuthenticatedEncryptor` místo pomocí jedné z našich předdefinované objekty pro vytváření, mechanismus popsané v této části už neplatí.</span><span class="sxs-lookup"><span data-stu-id="a7db5-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="a7db5-108">Odvozování podklíčů a další ověření dat</span><span class="sxs-lookup"><span data-stu-id="a7db5-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="a7db5-109">`IAuthenticatedEncryptor` Rozhraní slouží jako základní rozhraní pro všechny operace ověřené šifrování.</span><span class="sxs-lookup"><span data-stu-id="a7db5-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="a7db5-110">Jeho `Encrypt` metoda má dvě vyrovnávací paměti: ve formátu prostého textu a additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="a7db5-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="a7db5-111">Tok obsah ve formátu prostého textu beze změny volání `IDataProtector.Protect`, ale AAD je generováno systémem a se skládá ze tří součástí:</span><span class="sxs-lookup"><span data-stu-id="a7db5-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="a7db5-112">Magic hlavička pro 32bitovou verzi 09 F0 F0 C9, identifikující tuto verzi systému ochrany dat.</span><span class="sxs-lookup"><span data-stu-id="a7db5-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="a7db5-113">Id klíče 128 bitů.</span><span class="sxs-lookup"><span data-stu-id="a7db5-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="a7db5-114">Řetězec s proměnnou délkou vytvořený z řetězu účel, který vytvořili `IDataProtector` , který je provedením této operace.</span><span class="sxs-lookup"><span data-stu-id="a7db5-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="a7db5-115">Protože AAD je jedinečný pro n-tice všechny tři komponenty, můžeme je použít k odvození nové klíče z KM namísto použití KM samotné ve všech našich kryptografických operací.</span><span class="sxs-lookup"><span data-stu-id="a7db5-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="a7db5-116">Pro všechna volání `IAuthenticatedEncryptor.Encrypt`, proběhne následující proces odvození klíče:</span><span class="sxs-lookup"><span data-stu-id="a7db5-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="a7db5-117">(K_E, K_H) = SP800_108_CTR_HMACSHA512 (contextHeader K_M AAD, || keyModifier)</span><span class="sxs-lookup"><span data-stu-id="a7db5-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="a7db5-118">Tady, voláme KDF SP800 108 NIST v režimu čítače (naleznete v tématu [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), s. 5.1) s následujícími parametry:</span><span class="sxs-lookup"><span data-stu-id="a7db5-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="a7db5-119">Odvození klíče key (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="a7db5-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="a7db5-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="a7db5-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="a7db5-121">label = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="a7db5-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="a7db5-122">context = contextHeader || keyModifier</span><span class="sxs-lookup"><span data-stu-id="a7db5-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="a7db5-123">Hlavičku kontextu má proměnlivou délku a v podstatě slouží jako kryptografický otisk algoritmy, které jsme už odvozování K_E a K_H.</span><span class="sxs-lookup"><span data-stu-id="a7db5-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="a7db5-124">Modifikátor klíče je řetězec 128bitové náhodně vygenerovaný pro každé volání `Encrypt` a slouží k zajištění s zahlcení pravděpodobnost, že KE a KH jsou jedinečné pro tuto operaci šifrování konkrétní ověřování i v případě, že všechny ostatní vstupy do KDF je konstantní.</span><span class="sxs-lookup"><span data-stu-id="a7db5-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="a7db5-125">Pro šifrování v režimu CBC + HMAC operace ověřování | K_E | Délka bloku symetrický šifrovací klíč, a | K_H | je velikost digest HMAC rutiny.</span><span class="sxs-lookup"><span data-stu-id="a7db5-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="a7db5-126">Gcm – šifrování + ověřování operace | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="a7db5-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="a7db5-127">Režimu CBC šifrování + ověřování HMAC</span><span class="sxs-lookup"><span data-stu-id="a7db5-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="a7db5-128">Jakmile K_E je generován prostřednictvím mechanismu výše, jsme generování náhodných inicializační vektor a spuštění šifrovací algoritmus symetrického bloku k zakódování jako prostý text.</span><span class="sxs-lookup"><span data-stu-id="a7db5-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="a7db5-129">Inicializační vektor a šifrovaného textu se spusťte pomocí rutiny HMAC inicializován s klíčem K_H vytvoří počítači MAC.</span><span class="sxs-lookup"><span data-stu-id="a7db5-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="a7db5-130">Tento proces a návratová hodnota je reprezentován graficky níže.</span><span class="sxs-lookup"><span data-stu-id="a7db5-130">This process and the return value is represented graphically below.</span></span>

![Proces v režimu CBC a návrat](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="a7db5-132">*výstup: = keyModifier || vektor IV || E_cbc (data K_E, iv) || Metoda HMAC (K_H, iv || E_cbc (data K_E, iv))*</span><span class="sxs-lookup"><span data-stu-id="a7db5-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="a7db5-133">`IDataProtector.Protect` Bude implementace [předřaďte magic záhlaví a id klíče](xref:security/data-protection/implementation/authenticated-encryption-details) do výstupu před vrácením řízení volajícímu.</span><span class="sxs-lookup"><span data-stu-id="a7db5-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="a7db5-134">Protože jsou implicitně magic záhlaví a id klíče součástí [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), a protože modifikátorem klíče se zobrazí jako vstup KDF, to znamená, že každý jeden bajt vrácená velikost datové části je ověřována MAC.</span><span class="sxs-lookup"><span data-stu-id="a7db5-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="a7db5-135">Režim Galois/čítač šifrování + ověřování</span><span class="sxs-lookup"><span data-stu-id="a7db5-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="a7db5-136">Jakmile K_E je generován prostřednictvím mechanismu výše, jsme generovat náhodná hodnota nonce 96 bitů a spusťte šifrovací algoritmus symetrického bloku k zakódování jako prostý text a vytvoření 128bitové ověřovací značka.</span><span class="sxs-lookup"><span data-stu-id="a7db5-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Proces režimu GCM a návrat](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="a7db5-138">*výstup: = keyModifier || Hodnota Nonce || E_gcm (K_E, nonce, data) || authTag*</span><span class="sxs-lookup"><span data-stu-id="a7db5-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="a7db5-139">Přestože GCM nativně podporuje koncept AAD, jsme se stále tak AAD jenom pro původní KDF vyjádří má být předán prázdný řetězec GCM pro její parametr AAD.</span><span class="sxs-lookup"><span data-stu-id="a7db5-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="a7db5-140">Důvod pro to má dvě fáze.</span><span class="sxs-lookup"><span data-stu-id="a7db5-140">The reason for this is two-fold.</span></span> <span data-ttu-id="a7db5-141">Nejprve je potřeba [pro podporu flexibilitu](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) jsme nikdy nechcete používat K_M přímo jako šifrovací klíč.</span><span class="sxs-lookup"><span data-stu-id="a7db5-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="a7db5-142">Kromě toho GCM žáků velmi přísná jedinečnost jeho vstupů.</span><span class="sxs-lookup"><span data-stu-id="a7db5-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="a7db5-143">Pravděpodobnost, že rutina šifrování GCM někdy vyvolané na dvou nebo více různých sad vstupních dat se stejným (klíče, nonce) pár nesmí být delší než 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="a7db5-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="a7db5-144">Pokud opravíme K_E jsme nemůžete provést více než 2 ^ 32 operace šifrování, než jsme spustit afoul o 2 ^ omezit -32.</span><span class="sxs-lookup"><span data-stu-id="a7db5-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="a7db5-145">To může jevit jako velmi velký počet operací, ale vysokým provozem webový server můžete projít 4 miliard žádostí za pouhé dní, i v rámci normálního dobu života těchto klíčů.</span><span class="sxs-lookup"><span data-stu-id="a7db5-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="a7db5-146">Chcete-li i nadále 2 ^ omezení pravděpodobnosti-32, Pokračujeme použít modifikátor klíče 128 bitů a hodnota nonce 96-bit, který výrazně přesahuje počet operací použitelné pro jakékoli dané K_M.</span><span class="sxs-lookup"><span data-stu-id="a7db5-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="a7db5-147">Pro zjednodušení návrhu sdílíme KDF cesta kódu mezi operacemi CBC a GCM a vzhledem k tomu, KDF již náleží AAD není nutné předat rutině GCM.</span><span class="sxs-lookup"><span data-stu-id="a7db5-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
